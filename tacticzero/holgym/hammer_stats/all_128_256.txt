
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Mon May 17 01:15:23 2021)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
> > > > Loading holyHammer
> > > > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > > > > > > > signature JSON =
  sig
    datatype json =
        ARRAY of json list
      | BOOL of bool
      | NULL
      | NUMBER of real
      | OBJECT of (string * json) list
      | STRING of string
    val parse: string -> json result
    datatype 'a result = ERROR of string | OK of 'a
    val serialise: json -> string
    val serialiseIndented: json -> string
  end
structure Json: JSON
val it = (): unit
val it = (): unit
val infile = "test_dep_dict.json": string
val readjson = fn: string -> Json.json Json.result
val readfirstkey = fn: string -> string
val allterms = fn: string -> term list
val json_string_to_string = fn: Json.json -> string
val string_to_term = fn: string -> term
val value_to_input = fn: string * Json.json -> term * string list
val value_to_term = fn: string * Json.json -> term
val firstpair = fn: string -> (term * string list) list
val construct_hh_input = fn: term * string list -> tactic
val gen_data = fn: string -> (term * string list) list
val gen_premises = fn: goal -> int -> string list -> string list
val gen_premises_better = fn:
   goal -> int -> string list -> int -> string list
val premise_filter = fn: ''a list -> ''a list -> ''a list
val premise_filter_better = fn: ''a list -> ''a list -> int -> ''a list
val premise_selection = fn: goal -> int -> string list
val it = (): unit
val run_hh_pb = fn: (term * string list) list -> prover list -> int -> tactic
val run_hh_pb_better = fn:
   (term * string list) list -> prover list -> int -> int -> tactic
val it = (): unit
>
*** Emacs/HOL command completed ***

> val data = gen_data infile;
val data =
   [(“∀s t. t ⊆ s ⇒ s DIFF (s DIFF t) = t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", "boolTheory.LEFT_EXISTS_IMP_THM",
      ...]),
    (“∀set e. e ∈ POW set ⇔ e ⊆ set”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", ...]),
    (“FINITE 𝕌(:α # β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM", ...]),
    (“∀f s t. FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", ...]),
    (“{x | T} = 𝕌(:α)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", ...]),
    (“COMPL ∅ = 𝕌(:α)”,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", "pred_setTheory.SUBSET_DEF",
      "pred_setTheory.SING_DEF", "pred_setTheory.schroeder_close_def",
      "pred_setTheory.RINV_LO", "pred_setTheory.REST_DEF",
      "pred_setTheory.REL_RESTRICT_DEF", "pred_setTheory.PSUBSET_DEF",
      "pred_setTheory.LINV_OPT_def", "pred_setTheory.LINV_LO",
      "pred_setTheory.INTER_DEF", "pred_setTheory.INSERT_DEF",
      "pred_setTheory.INJ_DEF", "pred_setTheory.IMAGE_DEF",
      "pred_setTheory.HAS_SIZE", "pred_setTheory.GSPECIFICATION",
      "pred_setTheory.FUNSET", "pred_setTheory.FINITE_DEF",
      "pred_setTheory.EMPTY_DEF", "pred_setTheory.disjUNION_def",
      "pred_setTheory.DISJOINT_DEF", "pred_setTheory.DIFF_DEF",
      "pred_setTheory.DFUNSET", "pred_setTheory.DELETE_DEF",
      "pred_setTheory.CROSS_DEF", "pred_setTheory.count_def",
      "pred_setTheory.COMPL_DEF", "pred_setTheory.CHOICE_DEF",
      "pred_setTheory.CARD_DEF", "pred_setTheory.BIJ_DEF",
      "pred_setTheory.BIGUNION", "pred_setTheory.BIGINTER",
      "pred_setTheory.UNIV_SUBSET", "pred_setTheory.UNIV_NOT_EMPTY",
      "pred_setTheory.UNIV_FUNSET_UNIV", "pred_setTheory.UNIV_BOOL",
      "pred_setTheory.UNIV_applied", "pred_setTheory.UNION_UNIV",
      "pred_setTheory.UNION_SUBSET", "pred_setTheory.UNION_OVER_INTER",
      "pred_setTheory.UNION_IDEMPOT", "pred_setTheory.UNION_EMPTY",
      "pred_setTheory.UNION_DIFF_EQ", "pred_setTheory.UNION_DIFF",
      "pred_setTheory.UNION_COMM", "pred_setTheory.UNION_ASSOC",
      "pred_setTheory.UNION_applied", "pred_setTheory.transitive_PSUBSET",
      "pred_setTheory.TC_SUBSET_THM", "pred_setTheory.TC_PSUBSET",
      "pred_setTheory.SURJ_INJ_INV", "pred_setTheory.SURJ_IMP_INJ",
      "pred_setTheory.SURJ_IMAGE", "pred_setTheory.SURJ_ID",
      "pred_setTheory.SURJ_EMPTY", "pred_setTheory.SURJ_COMPOSE",
      "pred_setTheory.SURJ_CARD", "pred_setTheory.SUM_UNIV",
      "pred_setTheory.SUBSET_UNIV", "pred_setTheory.SUBSET_UNION_ABSORPTION",
      "pred_setTheory.SUBSET_UNION", "pred_setTheory.SUBSET_transitive",
      "pred_setTheory.SUBSET_TRANS", "pred_setTheory.SUBSET_THM",
      "pred_setTheory.SUBSET_reflexive", "pred_setTheory.SUBSET_REFL",
      "pred_setTheory.SUBSET_OF_INSERT", "pred_setTheory.SUBSET_K",
      "pred_setTheory.SUBSET_INTER_ABSORPTION",
      "pred_setTheory.SUBSET_INTER2", "pred_setTheory.SUBSET_INTER1",
      "pred_setTheory.SUBSET_INTER", "pred_setTheory.SUBSET_INSERT_DELETE",
      "pred_setTheory.SUBSET_INSERT", "pred_setTheory.SUBSET_IMAGE",
      "pred_setTheory.SUBSET_FINITE_I", "pred_setTheory.SUBSET_FINITE",
      "pred_setTheory.SUBSET_EQ_CARD", "pred_setTheory.SUBSET_EMPTY",
      "pred_setTheory.SUBSET_DISJOINT", "pred_setTheory.SUBSET_DELETE",
      "pred_setTheory.SUBSET_CROSS", "pred_setTheory.SUBSET_BIGUNION_I",
      "pred_setTheory.SUBSET_BIGUNION", "pred_setTheory.SUBSET_BIGINTER",
      "pred_setTheory.SUBSET_applied", "pred_setTheory.SUBSET_ANTISYM_EQ",
      "pred_setTheory.SUBSET_ANTISYM", "pred_setTheory.SUBSET_ADD",
      "pred_setTheory.SPECIFICATION", "pred_setTheory.SING_UNION",
      "pred_setTheory.SING_INSERT", ...]),
    (“∀s t. s = t ⇔ ∀x. x ∈ s ⇔ x ∈ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      ...]),
    (“∀s. (∃f. BIJ f 𝕌(:num) s) ⇒ countable s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", ...]),
    (“∀a0 a1 a0' a1'. a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", ...]),
    (“∀s1 s2. BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM", ...]),
    (“∀f s t. s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λn. s × f n) t)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", ...]),
    (“PMATCH_EQUIV_ROWS v rows1 rows2 ⇒ PMATCH v rows1 = PMATCH v rows2”,
     ["patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE"]),
    (“∀l x. SEG 1 (LENGTH l) (SNOC x l) = [x]”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (“∀s. FINITE s ⇒ countable s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (“∀l. FINITE (set l)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      ...]),
    (“∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (“∀x s. x ∈ x INSERT s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (“∀n l. n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      ...]),
    (“∀v p g p' g' RES.
          PMATCH_ROW_COND_EX v p g ⇒
          (∀x. g x ⇒ ((∃x'. p' x' = p x ∧ g' x') ⇔ RES)) ⇒
          (PMATCH_ROW_COND_EX v p' g' ⇔ RES)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_AUX_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_def",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_OK",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_REWRITE",
      "patternMatchesTheory.REDUNDANT_ROWS_INFO_TO_PMATCH_EQ",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_ROWS_INFO_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_SUC",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_NIL",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_LT",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_GE",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_0",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_WEAKEN",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FULL_DEF",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FALSE",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_REWRITES",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC_PMATCH_ROW",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_NIL",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_EXTRACT_IS_EXHAUSTIVE",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_CONS",
      "patternMatchesTheory.FST_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.EL2_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL1_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_THMS",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", ...]),
    (“∀x. ∅ DELETE x = ∅”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", ...]),
    (“∀s t. s DIFF t ∩ s = s DIFF t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", ...]),
    (“∀n l1 l2. TAKE n (l1 ⧺ l2) = TAKE n l1 ⧺ TAKE (n − LENGTH l1) l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (“∀s t u. s ∩ (t ∩ u) = s ∩ t ∩ u”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (“∀P. (∀l. LENGTH l = 0 ⇒ P l) ⇔ P []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES", ...]),
    (“ASSOC $++”,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L",
      "combinTheory.MONOID_DISJ_F", "combinTheory.MONOID_CONJ_T",
      "combinTheory.literal_case_FORALL_ELIM",
      "combinTheory.LET_FORALL_ELIM", "combinTheory.K_THM",
      "combinTheory.K_o_THM", "combinTheory.I_THM", "combinTheory.I_o_ID",
      "combinTheory.GEN_literal_case_RATOR",
      "combinTheory.GEN_literal_case_RAND", "combinTheory.GEN_LET_RATOR",
      "combinTheory.GEN_LET_RAND", "combinTheory.FCOMM_ASSOC",
      "combinTheory.FAIL_THM", "combinTheory.C_THM", "combinTheory.C_ABS_L",
      "combinTheory.ASSOC_SYM", "combinTheory.ASSOC_DISJ",
      "combinTheory.ASSOC_CONJ", "combinTheory.APPLY_UPDATE_THM",
      "combinTheory.APPLY_UPDATE_ID", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.UNIQUE_DEF",
      "listTheory.TL_DEF", "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF",
      "listTheory.SUM", "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.OPT_MMAP_def", "listTheory.oHD_def",
      "listTheory.oEL_def", ...]),
    (“PMATCH_ROW_REDUNDANT v [] i ⇔ F”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (“∀ZRECSPACE'.
          ZRECSPACE' ind_type$ZBOT ∧
          (∀c i r.
               (∀n. ZRECSPACE' (r n)) ⇒ ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
          ∀a0. ZRECSPACE a0 ⇒ ZRECSPACE' a0”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "ind_typeTheory.ZRECSPACE_def", "ind_typeTheory.ZCONSTR",
      "ind_typeTheory.ZBOT", "ind_typeTheory.NUMSUM_DEST",
      "ind_typeTheory.NUMSUM", "ind_typeTheory.NUMPAIR_DEST",
      "ind_typeTheory.NUMPAIR", "ind_typeTheory.INJP", "ind_typeTheory.INJN",
      "ind_typeTheory.INJF", "ind_typeTheory.INJA",
      "ind_typeTheory.ZRECSPACE_rules", "ind_typeTheory.ZCONSTR_ZBOT",
      "ind_typeTheory.NUMSUM_INJ", "ind_typeTheory.NUMPAIR_INJ_LEMMA",
      "ind_typeTheory.NUMPAIR_INJ", "ind_typeTheory.INJP_INJ",
      "ind_typeTheory.INJN_INJ", "ind_typeTheory.INJF_INJ",
      "ind_typeTheory.INJA_INJ", "ind_typeTheory.INJ_INVERSE2",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (“∀l1 l2.
          LENGTH l1 = LENGTH l2 ⇒
          ∀x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "pairTheory.UNCURRY_VAR",
      "pairTheory.SWAP_def", "pairTheory.RPROD_DEF",
      "pairTheory.prod_TY_DEF", "pairTheory.PROD_ALL_def",
      "pairTheory.PAIR_MAP", "pairTheory.pair_CASE_def", "pairTheory.PAIR",
      "pairTheory.LEX_DEF", "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (“¬SHORTLEX R l []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", ...]),
    (“∀e. ∃fn. fn () = e”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "oneTheory.one_TY_DEF", "oneTheory.one_DEF", "oneTheory.one_Axiom",
      "oneTheory.one_axiom", "oneTheory.one", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", ...]),
    (“∀l. l ≠ [] ⇒ FRONT l ⧺ [LAST l] = l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", ...]),
    (“∀l n. n < LENGTH l ⇒ LAST (DROP n l) = LAST l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", ...]),
    (“∀n l. n ≤ LENGTH l ⇒ ∀x. BUTLASTN n (x::l) = x::BUTLASTN n l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (“∀f s t. DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (“(∃ls. P ls) ⇔ ∃n f. P (GENLIST f n)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1", ...]),
    (“nub [] = []”,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.NULL_DEF", "listTheory.nub_def",
      "listTheory.MAP", "listTheory.LUPDATE_def", "listTheory.LRC_def",
      "listTheory.LLEX_def", "listTheory.list_TY_DEF",
      "listTheory.LIST_TO_SET_DEF", "listTheory.list_size_def",
      "listTheory.LIST_LIFT2_def", "listTheory.LIST_IGNORE_BIND_def",
      "listTheory.LIST_GUARD_def", "listTheory.list_case_def",
      "listTheory.LIST_BIND_def", "listTheory.LIST_APPLY_def",
      "listTheory.LENGTH", "listTheory.LEN_DEF", "listTheory.LAST_DEF",
      "listTheory.isPREFIX", "listTheory.INDEX_OF_def",
      "listTheory.INDEX_FIND_def", "listTheory.HD", "listTheory.GENLIST_AUX",
      "listTheory.GENLIST", "listTheory.FRONT_DEF", "listTheory.FOLDR",
      "listTheory.FOLDL", "listTheory.FLAT", "listTheory.FIND_def",
      "listTheory.FILTER", "listTheory.EXISTS_DEF", "listTheory.EVERYi_def",
      "listTheory.EVERY_DEF", "listTheory.EL", "listTheory.DROP_def",
      "listTheory.APPEND", "listTheory.ALL_DISTINCT", "listTheory.ZIP_UNZIP",
      "listTheory.ZIP_MAP", "listTheory.ZIP_GENLIST", "listTheory.ZIP",
      "listTheory.WF_SHORTLEX_same_lengths", "listTheory.WF_SHORTLEX",
      "listTheory.WF_LIST_PRED", "listTheory.UNZIP_ZIP",
      "listTheory.UNZIP_THM", "listTheory.UNZIP_MAP",
      "listTheory.UNION_APPEND", ...]),
    (“WF R⁺ ⇔ WF R”,
     ["relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.SC_DEF", "relationTheory.RTC_def",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.equivalence_def",
      "relationTheory.EQC_DEF", "relationTheory.EMPTY_REL_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.WF_TC",
      "relationTheory.WF_SUBSET", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_irreflexive", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_INDUCTION_THM", "relationTheory.WF_EMPTY_REL",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_EQC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_MONOTONE",
      "relationTheory.TC_lifts_transitive_relations",
      "relationTheory.TC_lifts_monotonicities",
      "relationTheory.TC_lifts_invariants",
      "relationTheory.TC_lifts_equalities",
      "relationTheory.TC_INDUCT_RIGHT1", "relationTheory.TC_INDUCT_LEFT1",
      "relationTheory.TC_INDUCT_ALT_RIGHT",
      "relationTheory.TC_INDUCT_ALT_LEFT", "relationTheory.TC_INDUCT",
      "relationTheory.TC_implies_one_step", "relationTheory.TC_IDEM",
      "relationTheory.TC_CASES2_E", "relationTheory.TC_CASES2",
      "relationTheory.TC_CASES1_E", "relationTheory.TC_CASES1",
      "relationTheory.symmetric_TC", "relationTheory.symmetric_SC_identity",
      "relationTheory.symmetric_RC", "relationTheory.symmetric_EQC",
      "relationTheory.STRONG_EQC_INDUCTION", "relationTheory.SC_SYMMETRIC",
      "relationTheory.SC_MONOTONE", "relationTheory.SC_lifts_monotonicities",
      "relationTheory.SC_lifts_equalities", "relationTheory.SC_IDEM",
      "relationTheory.RTC_TC_RC", "relationTheory.RTC_SINGLE",
      "relationTheory.RTC_strongind", ...]),
    (“∀n. countable (count n)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE", ...]),
    (“{x | y = x} = {y}”,
     ["pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM", ...]),
    (“∀x l. SNOC x l = l ⧺ [x]”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (“∀s t. DISJOINT s t ⇔ ∀x. x ∈ s ⇒ x ∉ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (“GENLIST f 0 = [] ∧ GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (“∀s x. x ⊂ {s} ⇔ x = ∅”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (“∀R. symmetric Rᵀ ⇔ symmetric R”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_ON_WFREC",
      "relationTheory.TC_TRANSITIVE", "relationTheory.TC_SUBSET",
      "relationTheory.TC_STRONG_INDUCT_RIGHT1", ...]),
    (“∀t1 t2. (if F then t1 else t2) = t2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", ...]),
    (“∀l1 l2. set (l1 ⧺ l2) = set l1 ∪ set l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", ...]),
    (“∀l1 l2. l2 ≼ l1 ⇔ ∃l. l1 = l2 ⧺ l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (“∀R. irreflexive Rᵀ ⇔ irreflexive R”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC", ...]),
    (“∀s. CHOICE s ∉ REST s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", ...]),
    (“∀l1 l2. l1 ⧺ l2 = FOLDL (λl' x. SNOC x l') l1 l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", ...]),
    (“∀L n. LEN L n = LENGTH L + n”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (“∀x x' y y'. (x ⇒ y' ⇒ y) ∧ (¬y' ⇒ x ⇒ x') ⇒ (x' ⇒ y') ⇒ x ⇒ y”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (“∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", ...]),
    (“∀n1 n2. count n1 = count n2 ⇔ n1 = n2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      ...]),
    (“∀n. 0 < n ⇒ ∀x l. EL n (x::l) = EL (PRE n) l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM", ...]),
    (“∀e l. LIST_ELEM_COUNT e l > 0 ⇔ MEM e l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (“∀t. t ∨ t ⇔ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (“(∀x y. f x = f y ⇔ x = y) ⇒
      (DISJOINT (IMAGE f s1) (IMAGE f s2) ⇔ DISJOINT s1 s2)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM", ...]),
    (“∀x x' y y'. (y ⇒ x' ⇒ x) ∧ (x' ⇒ y' ⇒ y) ⇒ x' ∧ y' ⇒ x ∧ y”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", ...]),
    (“∀n. DROP n [] = []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (“∀s. s ⊂ 𝕌(:α) ⇔ ∃x. x ∉ s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (“Q ($some P) ⇒ (∃x. P x ∧ Q (SOME x)) ∨ (∀x. ¬P x) ∧ Q NONE”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.NONE_DEF", "optionTheory.THE_DEF",
      "optionTheory.SOME_SOME_APPLY", "optionTheory.some_intro",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME",
      "optionTheory.OPTREL_refl", "optionTheory.OPTREL_O",
      "optionTheory.OPTREL_MONO", "optionTheory.OPTREL_eq",
      "optionTheory.option_nchotomy", "optionTheory.OPTION_MCOMP_ID",
      "optionTheory.OPTION_MCOMP_ASSOC", "optionTheory.OPTION_MAP_id",
      "optionTheory.OPTION_MAP_EQ_SOME",
      "optionTheory.OPTION_MAP_EQ_NONE_both_ways",
      "optionTheory.OPTION_MAP_EQ_NONE", "optionTheory.OPTION_MAP_CONG",
      "optionTheory.OPTION_MAP_COMPOSE", "optionTheory.OPTION_MAP_CASE", ...]),
    (“transitive $SUBSET”,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.WCR_def",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.the_fun_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.STRORD", "relationTheory.StrongOrder",
      "relationTheory.StrongLinearOrder", "relationTheory.SN_def",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", "relationTheory.RRESTRICT_DEF",
      "relationTheory.RRANGE", "relationTheory.RINTER",
      "relationTheory.RESTRICT_DEF", "relationTheory.reflexive_def",
      "relationTheory.RDOM_DELETE_DEF", "relationTheory.RDOM_DEF",
      "relationTheory.RCOMPL", "relationTheory.rcdiamond_def",
      "relationTheory.RC_DEF", "relationTheory.PreOrder",
      "relationTheory.Order", "relationTheory.O_DEF",
      "relationTheory.nf_def", "relationTheory.LinearOrder",
      "relationTheory.irreflexive_def", ...]),
    (“∀f g s t u. INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L", ...]),
    (“∀y s f. IMAGE f s y ⇔ ∃x. y = f x ∧ x ∈ s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", ...]),
    (“∀f g s t u. SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC", ...]),
    (“∀f. INVOL f ⇒ ∀a b. f a = f b ⇔ a = b”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.INVOL_DEF",
      "relationTheory.inv_image_def", "relationTheory.inv_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", ...]),
    (“∀l1 l2 l3. l1 ⧺ (l2 ⧺ l3) = l1 ⧺ l2 ⧺ l3”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (“$OLEAST P = NONE ⇔ ∀n. ¬P n”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "whileTheory.WHILE",
      "whileTheory.OLEAST_def", "whileTheory.LEAST_DEF",
      "whileTheory.HOARE_SPEC_DEF", "whileTheory.WHILE_RULE",
      "whileTheory.WHILE_INDUCTION", "whileTheory.OLEAST_INTRO",
      "whileTheory.OLEAST_EQNS", "whileTheory.LESS_LEAST",
      "whileTheory.LEAST_T", "whileTheory.LEAST_LESS_EQ",
      "whileTheory.LEAST_INTRO", "whileTheory.LEAST_EXISTS_IMP",
      "whileTheory.LEAST_EXISTS", "whileTheory.LEAST_EQ",
      "whileTheory.LEAST_ELIM", "whileTheory.ITERATION",
      "whileTheory.FULL_LEAST_INTRO", "optionTheory.some_def",
      "optionTheory.SOME_DEF", "optionTheory.OPTREL_def",
      "optionTheory.option_TY_DEF", "optionTheory.option_REP_ABS_DEF",
      "optionTheory.OPTION_MCOMP_def", "optionTheory.OPTION_MAP_DEF",
      "optionTheory.OPTION_MAP2_DEF", "optionTheory.OPTION_IGNORE_BIND_def",
      "optionTheory.OPTION_GUARD_def", "optionTheory.OPTION_CHOICE_def", ...]),
    (“∀n l1 l2. DROP n (l1 ⧺ l2) = DROP n l1 ⧺ DROP (n − LENGTH l1) l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", ...]),
    (“∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1", ...]),
    (“∀opt. (∃x. opt = SOME x) ∨ opt = NONE”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.OPTION_ALL_def", "optionTheory.NONE_DEF",
      "optionTheory.THE_DEF", "optionTheory.SOME_SOME_APPLY",
      "optionTheory.some_intro", "optionTheory.some_F",
      "optionTheory.some_EQ", "optionTheory.some_elim",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME", ...]),
    (“SURJ f s t ⇒ ∃g. INJ g t s ∧ ∀y. y ∈ t ⇒ f (g y) = y”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", ...]),
    (“∀R x y z. R꙳ x y ∧ R y z ⇒ R⁺ x z”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", "relationTheory.irreflexive_def",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.RTC_TRANSITIVE",
      "relationTheory.transitive_RC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_lifts_transitive_relations", ...]),
    (“∀f s t. INJ f s t ∧ INFINITE s ⇒ INFINITE t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", ...]),
    (“∀x1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2 ⇒ LENGTH l1 = LENGTH l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", ...]),
    (“∀x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF", ...]),
    (“∀P n.
          (∀l. LENGTH l = SUC n ⇒ P l) ⇔
          ∀l. LENGTH l = n ⇒ (λl. ∀x. P (x::l)) l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", ...]),
    (“x ∈ RDOM (RRESTRICT R s) ⇔ x ∈ RDOM R ∧ x ∈ s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.STRORD",
      "relationTheory.StrongOrder", "relationTheory.StrongLinearOrder",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", ...]),
    (“∀x l. FRONT (SNOC x l) = l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", ...]),
    (“∀l x. MEM x (REVERSE l) ⇔ MEM x l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF", ...]),
    (“∀l. NULL l ⇔ FOLDL (λx l'. F) T l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", ...]),
    (“∀l m x. MEM x (DROP m l) ⇒ MEM x l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF", ...]),
    (“∀x. ISR x ⇒ INR (OUTR x) = x”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "sumTheory.sum_TY_DEF", "sumTheory.sum_ISO_DEF", "sumTheory.OUTR",
      "sumTheory.OUTL", "sumTheory.ISR", "sumTheory.ISL",
      "sumTheory.IS_SUM_REP", "sumTheory.INR_DEF", "sumTheory.INL_DEF",
      "sumTheory.sum_INDUCT", "sumTheory.sum_distinct1",
      "sumTheory.sum_distinct", "sumTheory.sum_CASES", "sumTheory.sum_Axiom",
      ...]),
    (“[f] <*> l = MAP f l”,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SET_TO_LIST_primitive_def", "listTheory.REVERSE_DEF",
      "listTheory.REV_DEF", "listTheory.PAD_RIGHT", "listTheory.PAD_LEFT",
      ...]),
    (“∀n x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", ...]),
    (“∀s x y. x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      ...]),
    (“∀n l1 l2. l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", ...]),
    (“∀R. reflexive (RC R)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", ...]),
    (“R1 ∘ᵣ R2 ∘ᵣ R3 = (R1 ∘ᵣ R2) ∘ᵣ R3”,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF", ...]),
    (“∀n. 0 < n ⇒ ∀x l. ELL n (SNOC x l) = ELL (PRE n) l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", ...]),
    (“∀l1 l2.
          ALL_DISTINCT (l1 ⧺ l2) ⇔
          ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (“∀l. l ≠ [] ⇒ BUTLASTN 1 l = FRONT l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", ...]),
    (“∀s t. BIGUNION {s; t} = s ∪ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF", ...]),
    (“∀l2 l1. ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ⧺ l2) = HD l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", ...]),
    (“reflexive (R1 LEX R2) ⇔ reflexive R1 ∨ reflexive R2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def", ...]),
    (“INJ f s (IMAGE f s) ⇒ (countable (IMAGE f s) ⇔ countable s)”,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", ...]),
    (“MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g)”,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF", ...]),
    (“FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)”, ["pred_setTheory.UNIV_DEF", ...]),
    (“∀A B C. A ∧ B ⇒ C ⇔ A ⇒ B ⇒ C”, [...]), ...]: (term * string list) list
> run_hh_pb_better data [holyHammer.Eprover, holyHammer.Vampire, holyHammer.Z3] 256 128;
∀s t. t ⊆ s ⇒ s DIFF (s DIFF t) = t
proof failed.
Failed theorem:
∀s t. t ⊆ s ⇒ s DIFF (s DIFF t) = t
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀set e. e ∈ POW set ⇔ e ⊆ set
proof failed.
Failed theorem:
∀set e. e ∈ POW set ⇔ e ⊆ set
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FINITE 𝕌(:α # β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.CROSS_UNIV , pred_setTheory.FINITE_CROSS_EQ , pred_setTheory.UNIV_NOT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.CROSS_UNIV, pred_setTheory.FINITE_CROSS_EQ, pred_setTheory.UNIV_NOT_EMPTY]
∀f s t. FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_BIJ]
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.FINITE_BIJ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_BIJ]
{x | T} = 𝕌(:α)
proof failed.
Failed theorem:
{x | T} = 𝕌(:α)
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
COMPL ∅ = 𝕌(:α)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.COMPL_COMPL , pred_setTheory.COMPL_DEF , pred_setTheory.DIFF_UNIV]
minimized proof:
  metis_tac [pred_setTheory.COMPL_COMPL, pred_setTheory.COMPL_DEF, pred_setTheory.DIFF_UNIV]
∀s t. s = t ⇔ ∀x. x ∈ s ⇔ x ∈ t
proof found by z3:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
proof failed.
Failed theorem:
∀s t. s = t ⇔ ∀x. x ∈ s ⇔ x ∈ t
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. (∃f. BIJ f 𝕌(:num) s) ⇒ countable s
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.BIJ_DEF , pred_setTheory.countable_surj]
minimized proof:
  metis_tac [pred_setTheory.BIJ_DEF, pred_setTheory.countable_surj]
∀a0 a1 a0' a1'. a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'
proof found by vampire:
  metisTools.METIS_TAC [listTheory.HD , listTheory.TL]
minimized proof:
  metis_tac [listTheory.HD, listTheory.TL]
∀s1 s2. BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
proof failed.
Failed theorem:
∀s1 s2. BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f s t. s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λn. s × f n) t)
proof failed.
Failed theorem:
∀f s t. s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λn. s × f n) t)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_EQUIV_ROWS v rows1 rows2 ⇒ PMATCH v rows1 = PMATCH v rows2
proof found by eprover:
  metisTools.METIS_TAC [patternMatchesTheory.PMATCH_EQUIV_ROWS_def]
minimized proof:
  metis_tac [patternMatchesTheory.PMATCH_EQUIV_ROWS_def]
∀l x. SEG 1 (LENGTH l) (SNOC x l) = [x]
proof found by eprover:
  metisTools.METIS_TAC [arithmeticTheory.LESS_EQ_MONO , arithmeticTheory.ONE , arithmeticTheory.SUB_0 , arithmeticTheory.SUB_EQUAL_0 , arithmeticTheory.SUB_LESS_EQ , arithmeticTheory.ZERO_LESS_EQ , listTheory.LENGTH , listTheory.SNOC_APPEND , rich_listTheory.SEG , rich_listTheory.SEG_APPEND2]
minimized proof:
  metis_tac [arithmeticTheory.ONE, arithmeticTheory.SUB_0, arithmeticTheory.SUB_EQUAL_0, arithmeticTheory.SUB_LESS_EQ, listTheory.LENGTH, listTheory.SNOC_APPEND, rich_listTheory.SEG, rich_listTheory.SEG_APPEND2]
∀s. FINITE s ⇒ countable s
proof failed.
Failed theorem:
∀s. FINITE s ⇒ countable s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. FINITE (set l)
proof failed.
Failed theorem:
∀l. FINITE (set l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls)
proof failed.
Failed theorem:
∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x s. x ∈ x INSERT s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
∀n l. n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.INSERT_applied]
proof failed.
Failed theorem:
∀n l. n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀v p g p' g' RES.
    PMATCH_ROW_COND_EX v p g ⇒
    (∀x. g x ⇒ ((∃x'. p' x' = p x ∧ g' x') ⇔ RES)) ⇒
    (PMATCH_ROW_COND_EX v p' g' ⇔ RES)
proof failed.
Failed theorem:
∀v p g p' g' RES.
    PMATCH_ROW_COND_EX v p g ⇒
    (∀x. g x ⇒ ((∃x'. p' x' = p x ∧ g' x') ⇔ RES)) ⇒
    (PMATCH_ROW_COND_EX v p' g' ⇔ RES)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x. ∅ DELETE x = ∅
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.DELETE_NON_ELEMENT , pred_setTheory.NOT_IN_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.DELETE_NON_ELEMENT, pred_setTheory.NOT_IN_EMPTY]
∀s t. s DIFF t ∩ s = s DIFF t
proof failed.
Failed theorem:
∀s t. s DIFF t ∩ s = s DIFF t
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l1 l2. TAKE n (l1 ⧺ l2) = TAKE n l1 ⧺ TAKE (n − LENGTH l1) l2
proof failed.
Failed theorem:
∀n l1 l2. TAKE n (l1 ⧺ l2) = TAKE n l1 ⧺ TAKE (n − LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t u. s ∩ (t ∩ u) = s ∩ t ∩ u
proof failed.
Failed theorem:
∀s t u. s ∩ (t ∩ u) = s ∩ t ∩ u
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P. (∀l. LENGTH l = 0 ⇒ P l) ⇔ P []
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH , listTheory.NULL_EQ , listTheory.NULL_LENGTH]
minimized proof:
  metis_tac [listTheory.NULL_EQ, listTheory.NULL_LENGTH]
ASSOC $++
proof found by eprover:
  metisTools.METIS_TAC [combinTheory.ASSOC_DEF , listTheory.APPEND_ASSOC]
minimized proof:
  metis_tac [combinTheory.ASSOC_DEF, listTheory.APPEND_ASSOC]
PMATCH_ROW_REDUNDANT v [] i ⇔ F
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT v [] i ⇔ F
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀ZRECSPACE'.
    ZRECSPACE' ind_type$ZBOT ∧
    (∀c i r. (∀n. ZRECSPACE' (r n)) ⇒ ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
    ∀a0. ZRECSPACE a0 ⇒ ZRECSPACE' a0
proof failed.
Failed theorem:
∀ZRECSPACE'.
    ZRECSPACE' ind_type$ZBOT ∧
    (∀c i r. (∀n. ZRECSPACE' (r n)) ⇒ ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
    ∀a0. ZRECSPACE a0 ⇒ ZRECSPACE' a0
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l1 l2.
    LENGTH l1 = LENGTH l2 ⇒
    ∀x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
proof failed.
Failed theorem:
∀l1 l2.
    LENGTH l1 = LENGTH l2 ⇒
    ∀x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
¬SHORTLEX R l []
proof failed.
Failed theorem:
¬SHORTLEX R l []
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀e. ∃fn. fn () = e
proof found by eprover:
  metisTools.METIS_TAC []
proof failed.
Failed theorem:
∀e. ∃fn. fn () = e
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. l ≠ [] ⇒ FRONT l ⧺ [LAST l] = l
proof failed.
Failed theorem:
∀l. l ≠ [] ⇒ FRONT l ⧺ [LAST l] = l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l n. n < LENGTH l ⇒ LAST (DROP n l) = LAST l
proof failed.
Failed theorem:
∀l n. n < LENGTH l ⇒ LAST (DROP n l) = LAST l
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l. n ≤ LENGTH l ⇒ ∀x. BUTLASTN n (x::l) = x::BUTLASTN n l
proof failed.
Failed theorem:
∀n l. n ≤ LENGTH l ⇒ ∀x. BUTLASTN n (x::l) = x::BUTLASTN n l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f s t. DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)
proof failed.
Failed theorem:
∀f s t. DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∃ls. P ls) ⇔ ∃n f. P (GENLIST f n)
proof failed.
Failed theorem:
(∃ls. P ls) ⇔ ∃n f. P (GENLIST f n)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
nub [] = []
proof found by eprover:
  metisTools.METIS_TAC [listTheory.nub_def]
minimized proof:
  metis_tac [listTheory.nub_def]
WF R⁺ ⇔ WF R
proof failed.
Failed theorem:
WF R⁺ ⇔ WF R
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n. countable (count n)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.FINITE_COUNT , pred_setTheory.finite_countable]
minimized proof:
  metis_tac [pred_setTheory.FINITE_COUNT, pred_setTheory.finite_countable]
{x | y = x} = {y}
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.COUNTABLE_ALT]
proof failed.
Failed theorem:
{x | y = x} = {y}
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x l. SNOC x l = l ⧺ [x]
proof failed.
Failed theorem:
∀x l. SNOC x l = l ⧺ [x]
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t. DISJOINT s t ⇔ ∀x. x ∈ s ⇒ x ∉ t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EXISTS_REFL , boolTheory.IN_DEF , pred_setTheory.DISJOINT_SYM , pred_setTheory.IN_DISJOINT]
minimized proof:
  metis_tac [pred_setTheory.IN_DISJOINT]
GENLIST f 0 = [] ∧ GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []
proof found by vampire:
  metisTools.METIS_TAC [listTheory.GENLIST , listTheory.GENLIST_GENLIST_AUX]
minimized proof:
  metis_tac [listTheory.GENLIST, listTheory.GENLIST_GENLIST_AUX]
∀s x. x ⊂ {s} ⇔ x = ∅
proof failed.
Failed theorem:
∀s x. x ⊂ {s} ⇔ x = ∅
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R. symmetric Rᵀ ⇔ symmetric R
proof found by eprover:
  metisTools.METIS_TAC [relationTheory.inv_SC , relationTheory.inv_inv , relationTheory.symmetric_SC_identity]
minimized proof:
  metis_tac [relationTheory.inv_SC, relationTheory.inv_inv, relationTheory.symmetric_SC_identity]
∀t1 t2. (if F then t1 else t2) = t2
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.bool_case_thm]
minimized proof:
  metis_tac []
∀l1 l2. set (l1 ⧺ l2) = set l1 ∪ set l2
proof failed.
Failed theorem:
∀l1 l2. set (l1 ⧺ l2) = set l1 ∪ set l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l1 l2. l2 ≼ l1 ⇔ ∃l. l1 = l2 ⧺ l
proof failed.
Failed theorem:
∀l1 l2. l2 ≼ l1 ⇔ ∃l. l1 = l2 ⧺ l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R. irreflexive Rᵀ ⇔ irreflexive R
proof failed.
Failed theorem:
∀R. irreflexive Rᵀ ⇔ irreflexive R
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. CHOICE s ∉ REST s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.IN_REST]
minimized proof:
  metis_tac [pred_setTheory.IN_REST]
∀l1 l2. l1 ⧺ l2 = FOLDL (λl' x. SNOC x l') l1 l2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.REST_applied]
proof failed.
Failed theorem:
∀l1 l2. l1 ⧺ l2 = FOLDL (λl' x. SNOC x l') l1 l2
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀L n. LEN L n = LENGTH L + n
proof failed.
Failed theorem:
∀L n. LEN L n = LENGTH L + n
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x x' y y'. (x ⇒ y' ⇒ y) ∧ (¬y' ⇒ x ⇒ x') ⇒ (x' ⇒ y') ⇒ x ⇒ y
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e
proof failed.
Failed theorem:
∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n1 n2. count n1 = count n2 ⇔ n1 = n2
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.CARD_COUNT]
minimized proof:
  metis_tac [pred_setTheory.CARD_COUNT]
∀n. 0 < n ⇒ ∀x l. EL n (x::l) = EL (PRE n) l
proof failed.
Failed theorem:
∀n. 0 < n ⇒ ∀x l. EL n (x::l) = EL (PRE n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀e l. LIST_ELEM_COUNT e l > 0 ⇔ MEM e l
proof failed.
Failed theorem:
∀e l. LIST_ELEM_COUNT e l > 0 ⇔ MEM e l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀t. t ∨ t ⇔ t
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀x y. f x = f y ⇔ x = y) ⇒
(DISJOINT (IMAGE f s1) (IMAGE f s2) ⇔ DISJOINT s1 s2)
proof failed.
Failed theorem:
(∀x y. f x = f y ⇔ x = y) ⇒
(DISJOINT (IMAGE f s1) (IMAGE f s2) ⇔ DISJOINT s1 s2)
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x x' y y'. (y ⇒ x' ⇒ x) ∧ (x' ⇒ y' ⇒ y) ⇒ x' ∧ y' ⇒ x ∧ y
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n. DROP n [] = []
proof failed.
Failed theorem:
∀n. DROP n [] = []
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. s ⊂ 𝕌(:α) ⇔ ∃x. x ∉ s
proof failed.
Failed theorem:
∀s. s ⊂ 𝕌(:α) ⇔ ∃x. x ∉ s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
Q ($some P) ⇒ (∃x. P x ∧ Q (SOME x)) ∨ (∀x. ¬P x) ∧ Q NONE
proof failed.
Failed theorem:
Q ($some P) ⇒ (∃x. P x ∧ Q (SOME x)) ∨ (∀x. ¬P x) ∧ Q NONE
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
transitive $SUBSET
proof failed.
Failed theorem:
transitive $SUBSET
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f g s t u. INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u
proof failed.
Failed theorem:
∀f g s t u. INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀y s f. IMAGE f s y ⇔ ∃x. y = f x ∧ x ∈ s
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_IMAGE]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_IMAGE]
∀f g s t u. SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u
proof failed.
Failed theorem:
∀f g s t u. SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f. INVOL f ⇒ ∀a b. f a = f b ⇔ a = b
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.INVOL]
minimized proof:
  metis_tac [relationTheory.INVOL]
∀l1 l2 l3. l1 ⧺ (l2 ⧺ l3) = l1 ⧺ l2 ⧺ l3
proof failed.
Failed theorem:
∀l1 l2 l3. l1 ⧺ (l2 ⧺ l3) = l1 ⧺ l2 ⧺ l3
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
$OLEAST P = NONE ⇔ ∀n. ¬P n
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , optionTheory.IS_NONE_DEF , optionTheory.IS_NONE_EQ_NONE , optionTheory.IS_SOME_DEF , whileTheory.OLEAST_INTRO]
minimized proof:
  metis_tac [optionTheory.IS_NONE_EQ_NONE, optionTheory.IS_SOME_DEF, whileTheory.OLEAST_INTRO]
∀n l1 l2. DROP n (l1 ⧺ l2) = DROP n l1 ⧺ DROP (n − LENGTH l1) l2
proof failed.
Failed theorem:
∀n l1 l2. DROP n (l1 ⧺ l2) = DROP n l1 ⧺ DROP (n − LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l
proof failed.
Failed theorem:
∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀opt. (∃x. opt = SOME x) ∨ opt = NONE
proof found by eprover:
  metisTools.METIS_TAC [optionTheory.option_nchotomy]
minimized proof:
  metis_tac [optionTheory.option_nchotomy]
SURJ f s t ⇒ ∃g. INJ g t s ∧ ∀y. y ∈ t ⇒ f (g y) = y
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.option_nchotomy]
proof failed.
Failed theorem:
SURJ f s t ⇒ ∃g. INJ g t s ∧ ∀y. y ∈ t ⇒ f (g y) = y
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R x y z. R꙳ x y ∧ R y z ⇒ R⁺ x z
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.RC_DEF , relationTheory.RTC_RTC , relationTheory.RTC_TC_RC , relationTheory.TC_RTC , relationTheory.TC_RULES]
minimized proof:
  metis_tac [relationTheory.RC_DEF, relationTheory.RTC_TC_RC, relationTheory.TC_RULES]
∀f s t. INJ f s t ∧ INFINITE s ⇒ INFINITE t
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_INJ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_INJ]
∀x1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2 ⇒ LENGTH l1 = LENGTH l2
proof found by z3:
  metisTools.METIS_TAC [listTheory.SNOC_11]
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FRONT_SNOC]
minimized proof:
  metis_tac [listTheory.FRONT_SNOC]
∀x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
proof failed.
Failed theorem:
∀x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P n. (∀l. LENGTH l = SUC n ⇒ P l) ⇔ ∀l. LENGTH l = n ⇒ (λl. ∀x. P (x::l)) l
proof failed.
Failed theorem:
∀P n. (∀l. LENGTH l = SUC n ⇒ P l) ⇔ ∀l. LENGTH l = n ⇒ (λl. ∀x. P (x::l)) l
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
x ∈ RDOM (RRESTRICT R s) ⇔ x ∈ RDOM R ∧ x ∈ s
proof failed.
Failed theorem:
x ∈ RDOM (RRESTRICT R s) ⇔ x ∈ RDOM R ∧ x ∈ s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x l. FRONT (SNOC x l) = l
proof failed.
Failed theorem:
∀x l. FRONT (SNOC x l) = l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l x. MEM x (REVERSE l) ⇔ MEM x l
proof failed.
Failed theorem:
∀l x. MEM x (REVERSE l) ⇔ MEM x l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. NULL l ⇔ FOLDL (λx l'. F) T l
proof failed.
Failed theorem:
∀l. NULL l ⇔ FOLDL (λx l'. F) T l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l m x. MEM x (DROP m l) ⇒ MEM x l
proof failed.
Failed theorem:
∀l m x. MEM x (DROP m l) ⇒ MEM x l
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x. ISR x ⇒ INR (OUTR x) = x
proof failed.
Failed theorem:
∀x. ISR x ⇒ INR (OUTR x) = x
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
[f] <*> l = MAP f l
proof failed.
Failed theorem:
[f] <*> l = MAP f l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
proof failed.
Failed theorem:
∀n x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s x y. x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}
proof failed.
Failed theorem:
∀s x y. x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l1 l2. l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2
proof failed.
Failed theorem:
∀n l1 l2. l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R. reflexive (RC R)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , relationTheory.RC_DEF , relationTheory.reflexive_def]
minimized proof:
  metis_tac [relationTheory.RC_DEF, relationTheory.reflexive_def]
R1 ∘ᵣ R2 ∘ᵣ R3 = (R1 ∘ᵣ R2) ∘ᵣ R3
proof failed.
Failed theorem:
R1 ∘ᵣ R2 ∘ᵣ R3 = (R1 ∘ᵣ R2) ∘ᵣ R3
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n. 0 < n ⇒ ∀x l. ELL n (SNOC x l) = ELL (PRE n) l
proof failed.
Failed theorem:
∀n. 0 < n ⇒ ∀x l. ELL n (SNOC x l) = ELL (PRE n) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l1 l2.
    ALL_DISTINCT (l1 ⧺ l2) ⇔
    ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2
proof failed.
Failed theorem:
∀l1 l2.
    ALL_DISTINCT (l1 ⧺ l2) ⇔
    ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. l ≠ [] ⇒ BUTLASTN 1 l = FRONT l
proof found by z3:
  metisTools.METIS_TAC [arithmeticTheory.ONE , listTheory.APPEND_FRONT_LAST , listTheory.LENGTH , listTheory.LENGTH_NIL , rich_listTheory.BUTLASTN_LENGTH_APPEND]
minimized proof:
  metis_tac [arithmeticTheory.ONE, listTheory.APPEND_FRONT_LAST, listTheory.LENGTH, rich_listTheory.BUTLASTN_LENGTH_APPEND]
∀s t. BIGUNION {s; t} = s ∪ t
proof failed.
Failed theorem:
∀s t. BIGUNION {s; t} = s ∪ t
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l2 l1. ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ⧺ l2) = HD l2
proof failed.
Failed theorem:
∀l2 l1. ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ⧺ l2) = HD l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
reflexive (R1 LEX R2) ⇔ reflexive R1 ∨ reflexive R2
proof failed.
Failed theorem:
reflexive (R1 LEX R2) ⇔ reflexive R1 ∨ reflexive R2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INJ f s (IMAGE f s) ⇒ (countable (IMAGE f s) ⇔ countable s)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.NOT_IN_EMPTY , pred_setTheory.image_countable , pred_setTheory.inj_countable]
minimized proof:
  metis_tac [pred_setTheory.image_countable, pred_setTheory.inj_countable]
MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g)
proof failed.
Failed theorem:
MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)
proof failed.
Failed theorem:
FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀A B C. A ∧ B ⇒ C ⇔ A ⇒ B ⇒ C
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP SND (FILTER (λ(x,y). y ≠ z) ls) = FILTER (λy. z ≠ y) (MAP SND ls)
proof failed.
Failed theorem:
MAP SND (FILTER (λ(x,y). y ≠ z) ls) = FILTER (λy. z ≠ y) (MAP SND ls)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REPLICATE n a ⧺ REPLICATE m a = REPLICATE (n + m) a
proof failed.
Failed theorem:
REPLICATE n a ⧺ REPLICATE m a = REPLICATE (n + m) a
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀b. ¬b ⇒ (b ⇔ F)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
∀x y a b. (x,y) = (a,b) ⇔ x = a ∧ y = b
proof found by vampire:
  metisTools.METIS_TAC [pairTheory.PAIR_EQ]
minimized proof:
  metis_tac [pairTheory.PAIR_EQ]
∀f n x. MAP f (REPLICATE n x) = REPLICATE n (f x)
proof failed.
Failed theorem:
∀f n x. MAP f (REPLICATE n x) = REPLICATE n (f x)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l. n < LENGTH l ⇒ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
proof failed.
Failed theorem:
∀n l. n < LENGTH l ⇒ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_COND_EX i p g ⇒
PMATCH_ROW p g r i = SOME (r (@x. PMATCH_ROW_COND p g i x))
proof failed.
Failed theorem:
PMATCH_ROW_COND_EX i p g ⇒
PMATCH_ROW p g r i = SOME (r (@x. PMATCH_ROW_COND p g i x))
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R1 R2 x y. (R1 ∩ᵣ R2)꙳ x y ⇒ (R1꙳ ∩ᵣ R2꙳) x y
proof failed.
Failed theorem:
∀R1 R2 x y. (R1 ∩ᵣ R2)꙳ x y ⇒ (R1꙳ ∩ᵣ R2꙳) x y
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P a s. (∃x. x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃x. x ∈ s ∧ P x
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.COMPONENT , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
∀f g z. SUM_MAP f g z = if ISL z then INL (f (OUTL z)) else INR (g (OUTR z))
proof failed.
Failed theorem:
∀f g z. SUM_MAP f g z = if ISL z then INL (f (OUTL z)) else INR (g (OUTR z))
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
proof failed.
Failed theorem:
∀l. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f1 f2 l. MAP f1 l = MAP f2 l ⇔ ∀e. MEM e l ⇒ f1 e = f2 e
proof failed.
Failed theorem:
∀f1 f2 l. MAP f1 l = MAP f2 l ⇔ ∀e. MEM e l ⇒ f1 e = f2 e
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
$= ᵀ = $=
proof found by z3:
  metisTools.METIS_TAC [relationTheory.EqIsBothRSUBSET , relationTheory.inv_inv , relationTheory.reflexive_Id_RSUBSET , relationTheory.reflexive_inv , relationTheory.symmetric_inv , relationTheory.symmetric_inv_RSUBSET , relationTheory.symmetric_inv_identity]
minimized proof:
  metis_tac [relationTheory.EqIsBothRSUBSET, relationTheory.inv_inv, relationTheory.reflexive_Id_RSUBSET, relationTheory.reflexive_inv, relationTheory.symmetric_inv_RSUBSET, relationTheory.symmetric_inv_identity]
∀n l. n < LENGTH l ⇒ ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l
proof failed.
Failed theorem:
∀n l. n < LENGTH l ⇒ ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x s. ∅ ≠ x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.NOT_INSERT_EMPTY]
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.NOT_INSERT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.NOT_INSERT_EMPTY]
(¬SHORTLEX R [] [] ∧ ¬SHORTLEX R (h1::t1) []) ∧ SHORTLEX R [] (h2::t2) ∧
(SHORTLEX R (h1::t1) (h2::t2) ⇔
 LENGTH t1 < LENGTH t2 ∨
 LENGTH t1 = LENGTH t2 ∧ (R h1 h2 ∨ h1 = h2 ∧ SHORTLEX R t1 t2))
proof failed.
Failed theorem:
(¬SHORTLEX R [] [] ∧ ¬SHORTLEX R (h1::t1) []) ∧ SHORTLEX R [] (h2::t2) ∧
(SHORTLEX R (h1::t1) (h2::t2) ⇔
 LENGTH t1 < LENGTH t2 ∨
 LENGTH t1 = LENGTH t2 ∧ (R h1 h2 ∨ h1 = h2 ∧ SHORTLEX R t1 t2))
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀v. PMATCH_IS_EXHAUSTIVE v [] ⇔ F) ∧
∀v r rs.
    PMATCH_IS_EXHAUSTIVE v (r::rs) ⇔ r v ≠ NONE ∨ PMATCH_IS_EXHAUSTIVE v rs
proof failed.
Failed theorem:
(∀v. PMATCH_IS_EXHAUSTIVE v [] ⇔ F) ∧
∀v r rs.
    PMATCH_IS_EXHAUSTIVE v (r::rs) ⇔ r v ≠ NONE ∨ PMATCH_IS_EXHAUSTIVE v rs
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀s. 𝕌(:α) ∩ s = s) ∧ ∀s. s ∩ 𝕌(:α) = s
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_INTER2 , pred_setTheory.SUBSET_INTER_ABSORPTION , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_INTER2, pred_setTheory.SUBSET_INTER_ABSORPTION, pred_setTheory.SUBSET_UNIV]
∀f s t. BIJ f s t ⇔ f ∈ FUNSET s t ∧ ∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ y = f x
proof failed.
Failed theorem:
∀f s t. BIJ f s t ⇔ f ∈ FUNSET s t ∧ ∀y. y ∈ t ⇒ ∃!x. x ∈ s ∧ y = f x
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l. n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l
proof failed.
Failed theorem:
∀n l. n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l2 l1. IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1
proof found by z3:
  metisTools.METIS_TAC [listTheory.SWAP_REVERSE_SYM , rich_listTheory.IS_PREFIX_REVERSE]
minimized proof:
  metis_tac [listTheory.SWAP_REVERSE_SYM, rich_listTheory.IS_PREFIX_REVERSE]
∀s x y. x ∈ s DELETE y ⇔ x ∈ s ∧ x ≠ y
proof failed.
Failed theorem:
∀s x y. x ∈ s DELETE y ⇔ x ∈ s ∧ x ≠ y
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀ls n.
    n ≤ LENGTH ls ⇒ REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls − n) ls)
proof found by z3:
  metisTools.METIS_TAC [listTheory.REVERSE_11 , rich_listTheory.DROP_LASTN]
minimized proof:
  metis_tac [rich_listTheory.DROP_LASTN]
∀f. PREIMAGE f ∅ = ∅
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , rich_listTheory.DROP_LASTN]
proof failed.
Failed theorem:
∀f. PREIMAGE f ∅ = ∅
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f l. MAP f (REVERSE l) = REVERSE (MAP f l)
proof failed.
Failed theorem:
∀f l. MAP f (REVERSE l) = REVERSE (MAP f l)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t x. (s ∪ t) x ⇔ x ∈ s ∨ x ∈ t
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_UNION]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_UNION]
∀n. LENGTH (COUNT_LIST n) = n
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH_GENLIST , rich_listTheory.COUNT_LIST_GENLIST]
minimized proof:
  metis_tac [listTheory.LENGTH_GENLIST, rich_listTheory.COUNT_LIST_GENLIST]
(∃p. P p) ⇔ ∃p_1 p_2. P (p_1,p_2)
proof found by z3:
  metisTools.METIS_TAC [boolTheory.UNWIND_THM2 , pairTheory.ABS_PAIR_THM]
minimized proof:
  metis_tac [pairTheory.ABS_PAIR_THM]
∀l1 l2. l1 ⧺ l2 = FOLDR CONS l2 l1
proof failed.
Failed theorem:
∀l1 l2. l1 ⧺ l2 = FOLDR CONS l2 l1
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s x. COMPL (x INSERT s) = COMPL s DELETE x
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.COMPL_DEF , pred_setTheory.DELETE_INTER , pred_setTheory.DIFF_INSERT , pred_setTheory.DIFF_INTER_COMPL]
minimized proof:
  metis_tac [pred_setTheory.COMPL_DEF, pred_setTheory.DELETE_INTER, pred_setTheory.DIFF_INSERT, pred_setTheory.DIFF_INTER_COMPL]
∀t. t ⇒ T ⇔ T
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
countable ∅
proof found by eprover:
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.FINITE_EMPTY , pred_setTheory.finite_countable]
  metisTools.METIS_TAC [pred_setTheory.FINITE_EMPTY , pred_setTheory.finite_countable]
minimized proof:
  metis_tac [pred_setTheory.FINITE_EMPTY, pred_setTheory.finite_countable]
∀R. Order R ⇔ StrongOrder (STRORD R)
proof failed.
Failed theorem:
∀R. Order R ⇔ StrongOrder (STRORD R)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x x' y y'. (x ⇒ y ⇒ y') ∧ (¬y' ⇒ x' ⇒ x) ⇒ (x ⇒ y) ⇒ x' ⇒ y'
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
x ≼ y::ys ⇔ x = [] ∨ ∃xs. x = y::xs ∧ xs ≼ ys
proof failed.
Failed theorem:
x ≼ y::ys ⇔ x = [] ∨ ∃xs. x = y::xs ∧ xs ≼ ys
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P l m. EVERY P l ⇒ EVERY P (TAKE m l)
proof found by z3:
  metisTools.METIS_TAC [listTheory.EVERY_APPEND , listTheory.TAKE_DROP]
minimized proof:
  metis_tac [listTheory.EVERY_APPEND, listTheory.TAKE_DROP]
IS_SOME (OPTION_BIND x g) ⇒ IS_SOME x
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_SOME_DEF , optionTheory.NOT_IS_SOME_EQ_NONE , optionTheory.OPTION_BIND_def]
minimized proof:
  metis_tac [optionTheory.NOT_IS_SOME_EQ_NONE, optionTheory.OPTION_BIND_def]
(∀x y. R x y ⇒ Q x y) ⇒ R꙳ x y ⇒ Q꙳ x y
proof failed.
Failed theorem:
(∀x y. R x y ⇒ Q x y) ⇒ R꙳ x y ⇒ Q꙳ x y
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x. x ≼ x
proof failed.
Failed theorem:
∀x. x ≼ x
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
count 0 = ∅
proof failed.
Failed theorem:
count 0 = ∅
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀x. P x ⇒ Q x) ⇒ EXISTS P l ⇒ EXISTS Q l
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.F_DEF , boolTheory.IN_DEF , listTheory.EXISTS_MEM]
minimized proof:
  metis_tac [listTheory.EXISTS_MEM]
∀s t. s ⊆ t ⇒ s ∩ t = s
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_INTER_ABSORPTION]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_INTER_ABSORPTION]
∀R x y. R x y ⇒ R⁺ x y
proof found by eprover:
  metisTools.METIS_TAC [relationTheory.TC_RULES]
minimized proof:
  metis_tac [relationTheory.TC_RULES]
∀xs. FILTER (λx. T) xs = xs
proof found by eprover:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_ID]
proof failed.
Failed theorem:
∀xs. FILTER (λx. T) xs = xs
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. (λx. x) PERMUTES s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.TC_DEF]
proof failed.
Failed theorem:
∀s. (λx. x) PERMUTES s
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l1 n. LENGTH l1 ≤ n ⇒ ∀l2. TAKE n (l1 ⧺ l2) = l1 ⧺ TAKE (n − LENGTH l1) l2
proof found by eprover:
  metisTools.METIS_TAC [arithmeticTheory.EQ_LESS_EQ , arithmeticTheory.LESS_EQ_REFL , arithmeticTheory.NOT_LESS , arithmeticTheory.SUB_EQUAL_0 , boolTheory.EQ_CLAUSES , listTheory.APPEND_NIL , listTheory.TAKE_0 , listTheory.TAKE_APPEND1 , listTheory.TAKE_APPEND2 , listTheory.TAKE_LENGTH_TOO_LONG]
minimized proof:
  metis_tac [arithmeticTheory.EQ_LESS_EQ, arithmeticTheory.NOT_LESS, arithmeticTheory.SUB_EQUAL_0, listTheory.APPEND_NIL, listTheory.TAKE_0, listTheory.TAKE_APPEND1, listTheory.TAKE_APPEND2, listTheory.TAKE_LENGTH_TOO_LONG]
∀s. INFINITE s ⇒ ∀t. s ⊆ t ⇒ INFINITE t
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_FINITE]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_FINITE]
option_CASE NONE = (λv f. v) ∧ option_CASE (SOME x) = (λv f. f x)
proof found by eprover:
  metisTools.METIS_TAC [optionTheory.option_case_def]
minimized proof:
  metis_tac [optionTheory.option_case_def]
∀t. t ⇒ F ⇔ ¬t
proof found by z3:
  metisTools.METIS_TAC [boolTheory.IMP_CLAUSES]
minimized proof:
  metis_tac []
∀f1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
proof failed.
Failed theorem:
∀f1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f P Q. FUNSET P Q f ⇔ ∀x. x ∈ P ⇒ f x ∈ Q
proof failed.
Failed theorem:
∀f P Q. FUNSET P Q f ⇔ ∀x. x ∈ P ⇒ f x ∈ Q
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
𝕌(:α + β) = IMAGE INL 𝕌(:α) ∪ IMAGE INR 𝕌(:β)
proof failed.
Failed theorem:
𝕌(:α + β) = IMAGE INL 𝕌(:α) ∪ IMAGE INR 𝕌(:β)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x s. s ⊆ x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.DELETE_SUBSET , pred_setTheory.SUBSET_INSERT_DELETE]
minimized proof:
  metis_tac [pred_setTheory.DELETE_SUBSET, pred_setTheory.SUBSET_INSERT_DELETE]
∀l x. l ≠ x::l ∧ x::l ≠ l
proof failed.
Failed theorem:
∀l x. l ≠ x::l ∧ x::l ≠ l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_SET ∅ = 1 ∧
∀x s. FINITE s ⇒ PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
proof failed.
Failed theorem:
PROD_SET ∅ = 1 ∧
∀x s. FINITE s ⇒ PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f s x. PREIMAGE f s x ⇔ f x ∈ s
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.IN_PREIMAGE , pred_setTheory.SPECIFICATION]
minimized proof:
  metis_tac [pred_setTheory.IN_PREIMAGE, pred_setTheory.SPECIFICATION]
∀f e l1 l2. FOLDR f e (l1 ⧺ l2) = FOLDR f (FOLDR f e l2) l1
proof failed.
Failed theorem:
∀f e l1 l2. FOLDR f e (l1 ⧺ l2) = FOLDR f (FOLDR f e l2) l1
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l. n ≤ LENGTH l ⇒ DROP n l = LASTN (LENGTH l − n) l
proof failed.
Failed theorem:
∀n l. n ≤ LENGTH l ⇒ DROP n l = LASTN (LENGTH l − n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l. n ≤ LENGTH l ⇒ LENGTH (TAKE n l) = n
proof failed.
Failed theorem:
∀n l. n ≤ LENGTH l ⇒ LENGTH (TAKE n l) = n
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
0 < n ⇒ DROP n (x::xs) = DROP (n − 1) xs
proof failed.
Failed theorem:
0 < n ⇒ DROP n (x::xs) = DROP (n − 1) xs
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. AND_EL l ⇔ FOLDL $/\ T l
proof failed.
Failed theorem:
∀l. AND_EL l ⇔ FOLDL $/\ T l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P l. FILTER P l = [] ⇔ EVERY (λx. ¬P x) l
proof failed.
Failed theorem:
∀P l. FILTER P l = [] ⇔ EVERY (λx. ¬P x) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀v rows p infos.
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ⇔
    p ∧ EVERY (λr. r v = NONE) rows
proof failed.
Failed theorem:
∀v rows p infos.
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ⇔
    p ∧ EVERY (λr. r v = NONE) rows
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. s ∩ s = s
proof failed.
Failed theorem:
∀s. s ∩ s = s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x y z. x DIFF y DIFF z = x DIFF z DIFF y
proof failed.
Failed theorem:
∀x y z. x DIFF y DIFF z = x DIFF z DIFF y
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀c x x' y y'.
    (c ⇒ x' ⇒ x) ∧ (¬c ⇒ y' ⇒ y) ⇒
    (if c then x' else y') ⇒
    if c then x else y
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_IMP , boolTheory.COND_EXPAND_OR , boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
∀x. SING {x}
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.SING_DEF]
minimized proof:
  metis_tac [pred_setTheory.SING_DEF]
(a,b) ∈ {(x,x) | P x} ⇔ P a ∧ a = b
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SING_DEF]
proof failed.
Failed theorem:
(a,b) ∈ {(x,x) | P x} ⇔ P a ∧ a = b
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀M M' v f.
    M = M' ∧ (M' = [] ⇒ v = v') ∧ (∀a0 a1. M' = a0::a1 ⇒ f a0 a1 = f' a0 a1) ⇒
    list_CASE M v f = list_CASE M' v' f'
proof failed.
Failed theorem:
∀M M' v f.
    M = M' ∧ (M' = [] ⇒ v = v') ∧ (∀a0 a1. M' = a0::a1 ⇒ f a0 a1 = f' a0 a1) ⇒
    list_CASE M v f = list_CASE M' v' f'
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x l. SNOC x l ≠ []
proof found by eprover:
  metisTools.METIS_TAC [listTheory.NOT_CONS_NIL , listTheory.REVERSE_DEF , listTheory.REVERSE_SNOC]
minimized proof:
  metis_tac [listTheory.NOT_CONS_NIL, listTheory.REVERSE_DEF, listTheory.REVERSE_SNOC]
∀g f.
    FCOMM g f ⇒
    ∀e. LEFT_ID g e ⇒ ∀l. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
proof failed.
Failed theorem:
∀g f.
    FCOMM g f ⇒
    ∀e. LEFT_ID g e ⇒ ∀l. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀m n. m < SUC n ⇒ m ≠ n ⇒ m < n
proof found by eprover:
  metisTools.METIS_TAC [prim_recTheory.LESS_THM]
minimized proof:
  metis_tac [prim_recTheory.LESS_THM]
∀s t u. s ⊂ t ∧ t ⊂ u ⇒ s ⊂ u
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , prim_recTheory.LESS_THM]
proof failed.
Failed theorem:
∀s t u. s ⊂ t ∧ t ⊂ u ⇒ s ⊂ u
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t. FINITE s ∧ FINITE t ⇒ CARD (s ∪ t) = CARD s + CARD t − CARD (s ∩ t)
proof failed.
Failed theorem:
∀s t. FINITE s ∧ FINITE t ⇒ CARD (s ∪ t) = CARD s + CARD t − CARD (s ∩ t)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. 𝕌(:α) ⊆ s ⇔ s = 𝕌(:α)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_ANTISYM , pred_setTheory.SUBSET_REFL , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_ANTISYM, pred_setTheory.SUBSET_UNIV]
∀v rows p infos.
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_ANTISYM , pred_setTheory.SUBSET_UNIV]
proof failed.
Failed theorem:
∀v rows p infos.
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
LIST_REL R xs (h::t) ⇔ ∃h' t'. xs = h'::t' ∧ R h' h ∧ LIST_REL R t' t
proof failed.
Failed theorem:
LIST_REL R xs (h::t) ⇔ ∃h' t'. xs = h'::t' ∧ R h' h ∧ LIST_REL R t' t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ R꙳ x y ⇒ P y
proof failed.
Failed theorem:
(∀x y. P x ∧ R x y ⇒ P y) ⇒ ∀x y. P x ∧ R꙳ x y ⇒ P y
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(p ⇔ if q then r else s) ⇔
(p ∨ q ∨ ¬s) ∧ (p ∨ ¬r ∨ ¬q) ∧ (p ∨ ¬r ∨ ¬s) ∧ (¬q ∨ r ∨ ¬p) ∧ (q ∨ s ∨ ¬p)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_OR , boolTheory.COND_RAND , boolTheory.EQ_CLAUSES , boolTheory.MONO_COND]
minimized proof:
  metis_tac []
∀s x. x ∈ s ⇔ ∃t. s = x INSERT t ∧ x ∉ t
proof failed.
Failed theorem:
∀s x. x ∈ s ⇔ ∃t. s = x INSERT t ∧ x ∉ t
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_REDUNDANT v (r::rs) 0 ⇔ r v = NONE
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT v (r::rs) 0 ⇔ r v = NONE
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t. DISJOINT t (s DIFF t) ∧ DISJOINT (s DIFF t) t
proof failed.
Failed theorem:
∀s t. DISJOINT t (s DIFF t) ∧ DISJOINT (s DIFF t) t
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f s y. y ∈ BIGUNION (IMAGE f s) ⇔ ∃x. x ∈ s ∧ y ∈ f x
proof failed.
Failed theorem:
∀f s y. y ∈ BIGUNION (IMAGE f s) ⇔ ∃x. x ∈ s ∧ y ∈ f x
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀e. LIST_ELEM_COUNT e [] = 0) ∧
(∀e l1 l2.
     LIST_ELEM_COUNT e (l1 ⧺ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧
(∀e h l. h = e ⇒ LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ∧
∀e h l. h ≠ e ⇒ LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
proof failed.
Failed theorem:
(∀e. LIST_ELEM_COUNT e [] = 0) ∧
(∀e l1 l2.
     LIST_ELEM_COUNT e (l1 ⧺ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧
(∀e h l. h = e ⇒ LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ∧
∀e h l. h ≠ e ⇒ LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t x. (s ∩ t) x ⇔ x ∈ s ∧ x ∈ t
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.IN_INTER]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_INTER]
∀P l1 l2. EXISTS P (l1 ⧺ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_INTER]
proof failed.
Failed theorem:
∀P l1 l2. EXISTS P (l1 ⧺ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls
proof failed.
Failed theorem:
∀ls f. MAP f (ZIP (ls,ls)) = MAP (λx. f (x,x)) ls
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP f l = h::t ⇔ ∃x0 t0. l = x0::t0 ∧ h = f x0 ∧ t = MAP f t0
proof failed.
Failed theorem:
MAP f l = h::t ⇔ ∃x0 t0. l = x0::t0 ∧ h = f x0 ∧ t = MAP f t0
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R. symmetric R ⇒ SC R = R
proof failed.
Failed theorem:
∀R. symmetric R ⇒ SC R = R
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l1 l2. SHORTLEX R l1 l2 ⇒ LENGTH l1 ≤ LENGTH l2
proof failed.
Failed theorem:
∀l1 l2. SHORTLEX R l1 l2 ⇒ LENGTH l1 ≤ LENGTH l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
proof failed.
Failed theorem:
∀f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P.
    P ∅ ∧ (∀s. FINITE s ∧ P s ⇒ ∀e. e ∉ s ⇒ P (e INSERT s)) ⇒
    ∀s. FINITE s ⇒ P s
proof failed.
Failed theorem:
∀P.
    P ∅ ∧ (∀s. FINITE s ∧ P s ⇒ ∀e. e ∉ s ⇒ P (e INSERT s)) ⇒
    ∀s. FINITE s ⇒ P s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. FINITE s ⇒ FINITE (REST s)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_DELETE , pred_setTheory.REST_DEF]
minimized proof:
  metis_tac [pred_setTheory.FINITE_DELETE, pred_setTheory.REST_DEF]
∀s. FINITE s ⇒ ∃f b. BIJ f (count b) s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_BIJ_COUNT_EQ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_BIJ_COUNT_EQ]
∀P l1 l2. EVERY P l1 ⇒ dropWhile P (l1 ⧺ l2) = dropWhile P l2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.FINITE_BIJ_COUNT_EQ]
proof failed.
Failed theorem:
∀P l1 l2. EVERY P l1 ⇒ dropWhile P (l1 ⧺ l2) = dropWhile P l2
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(OPTION_IGNORE_BIND m1 m2 = NONE ⇔ m1 = NONE ∨ m2 = NONE) ∧
(OPTION_IGNORE_BIND m1 m2 = SOME y ⇔ ∃x. m1 = SOME x ∧ m2 = SOME y)
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EXISTS_REFL , optionTheory.NOT_NONE_SOME , optionTheory.OPTION_BIND_EQUALS_OPTION , optionTheory.OPTION_IGNORE_BIND_def , optionTheory.OPTION_IGNORE_BIND_thm , optionTheory.option_nchotomy]
minimized proof:
  metis_tac [optionTheory.OPTION_IGNORE_BIND_thm, optionTheory.option_nchotomy]
∀P l. EVERY P l ⇔ ¬EXISTS (λx. ¬P x) l
proof failed.
Failed theorem:
∀P l. EVERY P l ⇔ ¬EXISTS (λx. ¬P x) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. s = 𝕌(:α) ⇒ ∀v. v ∈ s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.EQ_UNIV , pred_setTheory.SPECIFICATION]
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
∀n. SUC m = n ⇒ m < n
proof found by eprover:
  metisTools.METIS_TAC [prim_recTheory.LESS_SUC_REFL]
minimized proof:
  metis_tac [prim_recTheory.LESS_SUC_REFL]
((if P then SOME x else NONE) = NONE ⇔ ¬P) ∧
((if P then NONE else SOME x) = NONE ⇔ P) ∧
((if P then SOME x else NONE) = SOME y ⇔ P ∧ x = y) ∧
((if P then NONE else SOME x) = SOME y ⇔ ¬P ∧ x = y)
proof failed.
Failed theorem:
((if P then SOME x else NONE) = NONE ⇔ ¬P) ∧
((if P then NONE else SOME x) = NONE ⇔ P) ∧
((if P then SOME x else NONE) = SOME y ⇔ P ∧ x = y) ∧
((if P then NONE else SOME x) = SOME y ⇔ ¬P ∧ x = y)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some x. x) = SOME T
proof failed.
Failed theorem:
(some x. x) = SOME T
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REDUNDANT_ROWS_INFOS_CONJ [] [] = [] ∧
REDUNDANT_ROWS_INFOS_CONJ (i1::is1) (i2::is2) =
(i1 ∧ i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
proof failed.
Failed theorem:
REDUNDANT_ROWS_INFOS_CONJ [] [] = [] ∧
REDUNDANT_ROWS_INFOS_CONJ (i1::is1) (i2::is2) =
(i1 ∧ i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. SUM (FLAT l) = SUM (MAP SUM l)
proof failed.
Failed theorem:
∀l. SUM (FLAT l) = SUM (MAP SUM l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x y. dest_rec x = dest_rec y ⇔ x = y
proof found by vampire:
  metisTools.METIS_TAC [ind_typeTheory.recspace_repfns]
minimized proof:
  metis_tac [ind_typeTheory.recspace_repfns]
(R1 LEX R2) (a,b) (c,d) ⇔ R1 a c ∨ a = c ∧ R2 b d
proof failed.
Failed theorem:
(R1 LEX R2) (a,b) (c,d) ⇔ R1 a c ∨ a = c ∧ R2 b d
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀l. [] ≼ l ⇔ T) ∧ (∀x l. x::l ≼ [] ⇔ F) ∧
∀x1 l1 x2 l2. x2::l2 ≼ x1::l1 ⇔ x1 = x2 ∧ l2 ≼ l1
proof found by eprover:
  metisTools.METIS_TAC [listTheory.isPREFIX_THM]
minimized proof:
  metis_tac [listTheory.isPREFIX_THM]
∀n l. n ≤ LENGTH l ⇒ DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
proof found by z3:
  metisTools.METIS_TAC [listTheory.REVERSE_REVERSE , rich_listTheory.BUTLASTN_def]
minimized proof:
  metis_tac [listTheory.REVERSE_REVERSE, rich_listTheory.BUTLASTN_def]
∀l f x. MEM x (MAP f l) ⇔ ∃y. x = f y ∧ MEM y l
proof found by vampire:
  metisTools.METIS_TAC [listTheory.REVERSE_REVERSE , rich_listTheory.BUTLASTN_def]
proof failed.
Failed theorem:
∀l f x. MEM x (MAP f l) ⇔ ∃y. x = f y ∧ MEM y l
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f s t. s ⊆ t ⇒ PREIMAGE f s ⊆ PREIMAGE f t
proof failed.
Failed theorem:
∀f s t. s ⊆ t ⇒ PREIMAGE f s ⊆ PREIMAGE f t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_ALL P Q (x,y) ⇔ P x ∧ Q y
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pairTheory.FST , pairTheory.PROD_ALL_def , pairTheory.SND]
minimized proof:
  metis_tac [pairTheory.FST, pairTheory.PROD_ALL_def, pairTheory.SND]
∀R x y. R⁺ x y ⇒ R꙳ x y
proof failed.
Failed theorem:
∀R x y. R⁺ x y ⇒ R꙳ x y
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l2 l1. BUTLASTN (LENGTH l2) (l1 ⧺ l2) = l1
proof failed.
Failed theorem:
∀l2 l1. BUTLASTN (LENGTH l2) (l1 ⧺ l2) = l1
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. LENGTH l = FOLDR (λx l'. SUC l') 0 l
proof failed.
Failed theorem:
∀l. LENGTH l = FOLDR (λx l'. SUC l') 0 l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n l. n ≤ LENGTH l ⇒ LASTN n l = DROP (LENGTH l − n) l
proof failed.
Failed theorem:
∀n l. n ≤ LENGTH l ⇒ LASTN n l = DROP (LENGTH l − n) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀t. F ∨ t ⇔ t
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f s. IMAGE f (PREIMAGE f s) ⊆ s
proof failed.
Failed theorem:
∀f s. IMAGE f (PREIMAGE f s) ⊆ s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t. s ⊂ t ⇔ s ⊆ t ∧ ∃y. y ∈ t ∧ y ∉ s
proof failed.
Failed theorem:
∀s t. s ⊂ t ⇔ s ⊆ t ∧ ∃y. y ∈ t ∧ y ∉ s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
R⁺ x z ⇔ R x z ∨ ∃y. R x y ∧ R⁺ y z
proof failed.
Failed theorem:
R⁺ x z ⇔ R x z ∨ ∃y. R x y ∧ R⁺ y z
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀m n l.
    m ≤ n ∧ n ≤ LENGTH l ⇒
    BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l)
proof failed.
Failed theorem:
∀m n l.
    m ≤ n ∧ n ≤ LENGTH l ⇒
    BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f P Q. f ∈ DFUNSET P Q ⇔ ∀x. x ∈ P ⇒ f x ∈ Q x
proof failed.
Failed theorem:
∀f P Q. f ∈ DFUNSET P Q ⇔ ∀x. x ∈ P ⇒ f x ∈ Q x
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ x = h ∨ MEM x t
proof failed.
Failed theorem:
(∀x. MEM x [] ⇔ F) ∧ ∀x h t. MEM x (h::t) ⇔ x = h ∨ MEM x t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x s. x ∉ s ⇔ s DELETE x = s
proof failed.
Failed theorem:
∀x s. x ∉ s ⇔ s DELETE x = s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(INL a ∈ A ⊔ B ⇔ a ∈ A) ∧ (INR b ∈ A ⊔ B ⇔ b ∈ B)
proof failed.
Failed theorem:
(INL a ∈ A ⊔ B ⇔ a ∈ A) ∧ (INR b ∈ A ⊔ B ⇔ b ∈ B)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
WF (λx y. y = SUC x)
proof failed.
Failed theorem:
WF (λx y. y = SUC x)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀L n. SUM_ACC L n = SUM L + n
proof failed.
Failed theorem:
∀L n. SUM_ACC L n = SUM L + n
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INFINITE 𝕌(:α) ⇔ ∀s. FINITE s ⇒ s ⊂ 𝕌(:α)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.FINITE_PSUBSET_INFINITE , pred_setTheory.NOT_UNIV_PSUBSET , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.FINITE_PSUBSET_INFINITE, pred_setTheory.SUBSET_UNIV]
∀f. (∀s. INJ f ∅ s) ∧ ∀s. INJ f s ∅ ⇔ s = ∅
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.EQ_UNIV , pred_setTheory.FINITE_PSUBSET_INFINITE , pred_setTheory.PSUBSET_UNIV , pred_setTheory.SPECIFICATION]
proof failed.
Failed theorem:
∀f. (∀s. INJ f ∅ s) ∧ ∀s. INJ f s ∅ ⇔ s = ∅
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l f. (MAP f l = [] ⇔ l = []) ∧ ([] = MAP f l ⇔ l = [])
proof found by eprover:
  metisTools.METIS_TAC [listTheory.MAP , listTheory.NOT_CONS_NIL , listTheory.list_CASES]
minimized proof:
  metis_tac [listTheory.MAP, listTheory.NOT_CONS_NIL, listTheory.list_CASES]
∀l. SUM l = FOLDR $+ 0 l
proof failed.
Failed theorem:
∀l. SUM l = FOLDR $+ 0 l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R l1 l2 n. LIST_REL R l1 l2 ⇒ LIST_REL R (DROP n l1) (DROP n l2)
proof failed.
Failed theorem:
∀R l1 l2 n. LIST_REL R l1 l2 ⇒ LIST_REL R (DROP n l1) (DROP n l2)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some x. F) = NONE
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_NONE_DEF , optionTheory.IS_NONE_EQ_NONE , optionTheory.some_intro]
proof failed.
Failed theorem:
(some x. F) = NONE
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f l1 l2. MAP f (l1 ⧺ l2) = MAP f l1 ⧺ MAP f l2
proof failed.
Failed theorem:
∀f l1 l2. MAP f (l1 ⧺ l2) = MAP f l1 ⧺ MAP f l2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀g f.
    FCOMM g f ⇒
    ∀e.
        LEFT_ID g e ⇒
        ∀l1 l2. FOLDR f e (l1 ⧺ l2) = g (FOLDR f e l1) (FOLDR f e l2)
proof failed.
Failed theorem:
∀g f.
    FCOMM g f ⇒
    ∀e.
        LEFT_ID g e ⇒
        ∀l1 l2. FOLDR f e (l1 ⧺ l2) = g (FOLDR f e l1) (FOLDR f e l2)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∅ x ⇔ F
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.EMPTY_DEF]
minimized proof:
  metis_tac [pred_setTheory.EMPTY_DEF]
∀R. WeakLinearOrder R ⇔ WeakOrder R ∧ ∀a b. R a b ∨ R b a
proof failed.
Failed theorem:
∀R. WeakLinearOrder R ⇔ WeakOrder R ∧ ∀a b. R a b ∨ R b a
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀R R'. (R ∘ᵣ R')ᵀ = R'ᵀ ∘ᵣ Rᵀ
proof failed.
Failed theorem:
∀R R'. (R ∘ᵣ R')ᵀ = R'ᵀ ∘ᵣ Rᵀ
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x l. x::l = [x] ⧺ l
proof found by eprover:
  metisTools.METIS_TAC [listTheory.APPEND]
minimized proof:
  metis_tac [listTheory.APPEND]
∀f l. MAP f l = FOLDR (λx l'. f x::l') [] l
proof failed.
Failed theorem:
∀f l. MAP f l = FOLDR (λx l'. f x::l') [] l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x. x ∈ 𝕌(:α)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
𝕌(:α + β) = 𝕌(:α) ⊔ 𝕌(:β)
proof failed.
Failed theorem:
𝕌(:α + β) = 𝕌(:α) ⊔ 𝕌(:β)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s t g. (s DIFF t) ∩ g = s ∩ g DIFF t
proof failed.
Failed theorem:
∀s t g. (s DIFF t) ∩ g = s ∩ g DIFF t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀Q P. (∃n. P n) ∧ (∀n. (∀m. m < n ⇒ ¬P m) ∧ P n ⇒ Q n) ⇒ Q ($LEAST P)
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , whileTheory.LEAST_INTRO , whileTheory.LESS_LEAST]
minimized proof:
  metis_tac [whileTheory.LEAST_INTRO, whileTheory.LESS_LEAST]
∀xs. FILTER (λx. F) xs = []
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.F_DEF , listTheory.FILTER_NEQ_NIL]
proof failed.
Failed theorem:
∀xs. FILTER (λx. F) xs = []
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_NIL]
proof failed.
Failed theorem:
∀f x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l1 l2. TAKE (LENGTH l1) (l1 ⧺ l2) = l1
proof failed.
Failed theorem:
∀l1 l2. TAKE (LENGTH l1) (l1 ⧺ l2) = l1
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. FLAT l = FOLDR $++ [] l
proof failed.
Failed theorem:
∀l. FLAT l = FOLDR $++ [] l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(¬LLEX R [] [] ∧ ¬LLEX R (h1::t1) []) ∧ LLEX R [] (h2::t2) ∧
(LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ h1 = h2 ∧ LLEX R t1 t2)
proof failed.
Failed theorem:
(¬LLEX R [] [] ∧ ¬LLEX R (h1::t1) []) ∧ LLEX R [] (h2::t2) ∧
(LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ h1 = h2 ∧ LLEX R t1 t2)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l. l ⧺ [] = l
proof failed.
Failed theorem:
∀l. l ⧺ [] = l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s f. f ∈ FUNSET s ∅ ⇔ s = ∅
proof failed.
Failed theorem:
∀s f. f ∈ FUNSET s ∅ ⇔ s = ∅
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀b. b ⇒ (b ⇔ T)
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l x. ELL 0 (SNOC x l) = x
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LAST_SNOC , rich_listTheory.ELL]
minimized proof:
  metis_tac [listTheory.LAST_SNOC, rich_listTheory.ELL]
∀ls. ls ≠ [] ⇒ MAP f (FRONT ls) = FRONT (MAP f ls)
proof failed.
Failed theorem:
∀ls. ls ≠ [] ⇒ MAP f (FRONT ls) = FRONT (MAP f ls)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀n. 0 < SUC n
proof failed.
Failed theorem:
∀n. 0 < SUC n
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
IMAGE f s = {z} ⇔ s ≠ ∅ ∧ ∀x. x ∈ s ⇒ f x = z
proof failed.
Failed theorem:
IMAGE f s = {z} ⇔ s ≠ ∅ ∧ ∀x. x ∈ s ⇒ f x = z
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀f e l. FOLDR f e l = FOLDL (λx y. f y x) e (REVERSE l)
proof failed.
Failed theorem:
∀f e l. FOLDR f e l = FOLDL (λx y. f y x) e (REVERSE l)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀l1 l2 a. IS_SUFFIX l1 l2 ⇒ IS_SUFFIX (a::l1) l2
proof failed.
Failed theorem:
∀l1 l2 a. IS_SUFFIX l1 l2 ⇒ IS_SUFFIX (a::l1) l2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀x P. x ∈ P ⇔ P x
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
minimized proof:
  metis_tac [IN_DEF]
∀R. StrongOrder R ⇒ Order R
proof found by z3:
  metisTools.METIS_TAC [relationTheory.Order , relationTheory.StrongOrder , relationTheory.irrefl_trans_implies_antisym]
minimized proof:
  metis_tac [relationTheory.Order, relationTheory.StrongOrder, relationTheory.irrefl_trans_implies_antisym]
∀n l. n < LENGTH l ⇒ MEM (EL n l) l
proof found by z3:
  metisTools.METIS_TAC [listTheory.MEM_EL]
minimized proof:
  metis_tac [listTheory.MEM_EL]
∀x y P. x ∈ y INSERT P ⇔ x = y ∨ x ≠ y ∧ x ∈ P
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.INSERT_applied , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
OWHILE G f s = SOME s' ⇒ ¬G s'
proof failed.
Failed theorem:
OWHILE G f s = SOME s' ⇒ ¬G s'
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
symmetric R1 ∧ symmetric R2 ⇒ symmetric (R1 LEX R2)
proof failed.
Failed theorem:
symmetric R1 ∧ symmetric R2 ⇒ symmetric (R1 LEX R2)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀P l. PREFIX P l ≼ l
proof failed.
Failed theorem:
∀P l. PREFIX P l ≼ l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s f. (∃t. INJ f s t) ⇒ BIJ f s (IMAGE f s)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.BIJ_DEF , pred_setTheory.IMAGE_SURJ , pred_setTheory.INJ_IMAGE]
proof failed.
Failed theorem:
∀s f. (∃t. INJ f s t) ⇒ BIJ f s (IMAGE f s)
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀s. s DIFF 𝕌(:α) = ∅
proof failed.
Failed theorem:
∀s. s DIFF 𝕌(:α) = ∅
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀t. t ∧ t ⇔ t
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∃x. x ∈ s) ∧ (∀x. x ∈ s ⇒ P x) ⇒ P (CHOICE s)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.CHOICE_DEF , pred_setTheory.MEMBER_NOT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.CHOICE_DEF, pred_setTheory.MEMBER_NOT_EMPTY]
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
val it = fn: tactic
>
