
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Mon May 17 01:15:23 2021)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
> > > > Loading holyHammer
> > > > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > > > > > > > signature JSON =
  sig
    datatype json =
        ARRAY of json list
      | BOOL of bool
      | NULL
      | NUMBER of real
      | OBJECT of (string * json) list
      | STRING of string
    val parse: string -> json result
    datatype 'a result = ERROR of string | OK of 'a
    val serialise: json -> string
    val serialiseIndented: json -> string
  end
structure Json: JSON
val it = (): unit
val it = (): unit
val infile = "test_dep_dict.json": string
val readjson = fn: string -> Json.json Json.result
val readfirstkey = fn: string -> string
val allterms = fn: string -> term list
val json_string_to_string = fn: Json.json -> string
val string_to_term = fn: string -> term
val value_to_input = fn: string * Json.json -> term * string list
val value_to_term = fn: string * Json.json -> term
val firstpair = fn: string -> (term * string list) list
val construct_hh_input = fn: term * string list -> tactic
val gen_data = fn: string -> (term * string list) list
val gen_premises = fn: goal -> int -> string list -> string list
val gen_premises_better = fn:
   goal -> int -> string list -> int -> string list
val premise_filter = fn: ''a list -> ''a list -> ''a list
val premise_filter_better = fn: ''a list -> ''a list -> int -> ''a list
val premise_selection = fn: goal -> int -> string list
val it = (): unit
val run_hh_pb = fn: (term * string list) list -> prover list -> int -> tactic
val run_hh_pb_better = fn:
   (term * string list) list -> prover list -> int -> int -> tactic
val it = (): unit
>
*** Emacs/HOL command completed ***

> val data = gen_data infile;
val data =
   [(‚Äú‚àÄs t. t ‚äÜ s ‚áí s DIFF (s DIFF t) = t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", "boolTheory.LEFT_EXISTS_IMP_THM",
      ...]),
    (‚Äú‚àÄset e. e ‚àà POW set ‚áî e ‚äÜ set‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", ...]),
    (‚ÄúFINITE ùïå(:Œ± # Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM", ...]),
    (‚Äú‚àÄf s t. FINITE s ‚àß BIJ f s t ‚áí CARD s = CARD t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", ...]),
    (‚Äú{x | T} = ùïå(:Œ±)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", ...]),
    (‚ÄúCOMPL ‚àÖ = ùïå(:Œ±)‚Äù,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", "pred_setTheory.SUBSET_DEF",
      "pred_setTheory.SING_DEF", "pred_setTheory.schroeder_close_def",
      "pred_setTheory.RINV_LO", "pred_setTheory.REST_DEF",
      "pred_setTheory.REL_RESTRICT_DEF", "pred_setTheory.PSUBSET_DEF",
      "pred_setTheory.LINV_OPT_def", "pred_setTheory.LINV_LO",
      "pred_setTheory.INTER_DEF", "pred_setTheory.INSERT_DEF",
      "pred_setTheory.INJ_DEF", "pred_setTheory.IMAGE_DEF",
      "pred_setTheory.HAS_SIZE", "pred_setTheory.GSPECIFICATION",
      "pred_setTheory.FUNSET", "pred_setTheory.FINITE_DEF",
      "pred_setTheory.EMPTY_DEF", "pred_setTheory.disjUNION_def",
      "pred_setTheory.DISJOINT_DEF", "pred_setTheory.DIFF_DEF",
      "pred_setTheory.DFUNSET", "pred_setTheory.DELETE_DEF",
      "pred_setTheory.CROSS_DEF", "pred_setTheory.count_def",
      "pred_setTheory.COMPL_DEF", "pred_setTheory.CHOICE_DEF",
      "pred_setTheory.CARD_DEF", "pred_setTheory.BIJ_DEF",
      "pred_setTheory.BIGUNION", "pred_setTheory.BIGINTER",
      "pred_setTheory.UNIV_SUBSET", "pred_setTheory.UNIV_NOT_EMPTY",
      "pred_setTheory.UNIV_FUNSET_UNIV", "pred_setTheory.UNIV_BOOL",
      "pred_setTheory.UNIV_applied", "pred_setTheory.UNION_UNIV",
      "pred_setTheory.UNION_SUBSET", "pred_setTheory.UNION_OVER_INTER",
      "pred_setTheory.UNION_IDEMPOT", "pred_setTheory.UNION_EMPTY",
      "pred_setTheory.UNION_DIFF_EQ", "pred_setTheory.UNION_DIFF",
      "pred_setTheory.UNION_COMM", "pred_setTheory.UNION_ASSOC",
      "pred_setTheory.UNION_applied", "pred_setTheory.transitive_PSUBSET",
      "pred_setTheory.TC_SUBSET_THM", "pred_setTheory.TC_PSUBSET",
      "pred_setTheory.SURJ_INJ_INV", "pred_setTheory.SURJ_IMP_INJ",
      "pred_setTheory.SURJ_IMAGE", "pred_setTheory.SURJ_ID",
      "pred_setTheory.SURJ_EMPTY", "pred_setTheory.SURJ_COMPOSE",
      "pred_setTheory.SURJ_CARD", "pred_setTheory.SUM_UNIV",
      "pred_setTheory.SUBSET_UNIV", "pred_setTheory.SUBSET_UNION_ABSORPTION",
      "pred_setTheory.SUBSET_UNION", "pred_setTheory.SUBSET_transitive",
      "pred_setTheory.SUBSET_TRANS", "pred_setTheory.SUBSET_THM",
      "pred_setTheory.SUBSET_reflexive", "pred_setTheory.SUBSET_REFL",
      "pred_setTheory.SUBSET_OF_INSERT", "pred_setTheory.SUBSET_K",
      "pred_setTheory.SUBSET_INTER_ABSORPTION",
      "pred_setTheory.SUBSET_INTER2", "pred_setTheory.SUBSET_INTER1",
      "pred_setTheory.SUBSET_INTER", "pred_setTheory.SUBSET_INSERT_DELETE",
      "pred_setTheory.SUBSET_INSERT", "pred_setTheory.SUBSET_IMAGE",
      "pred_setTheory.SUBSET_FINITE_I", "pred_setTheory.SUBSET_FINITE",
      "pred_setTheory.SUBSET_EQ_CARD", "pred_setTheory.SUBSET_EMPTY",
      "pred_setTheory.SUBSET_DISJOINT", "pred_setTheory.SUBSET_DELETE",
      "pred_setTheory.SUBSET_CROSS", "pred_setTheory.SUBSET_BIGUNION_I",
      "pred_setTheory.SUBSET_BIGUNION", "pred_setTheory.SUBSET_BIGINTER",
      "pred_setTheory.SUBSET_applied", "pred_setTheory.SUBSET_ANTISYM_EQ",
      "pred_setTheory.SUBSET_ANTISYM", "pred_setTheory.SUBSET_ADD",
      "pred_setTheory.SPECIFICATION", "pred_setTheory.SING_UNION",
      "pred_setTheory.SING_INSERT", ...]),
    (‚Äú‚àÄs t. s = t ‚áî ‚àÄx. x ‚àà s ‚áî x ‚àà t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      ...]),
    (‚Äú‚àÄs. (‚àÉf. BIJ f ùïå(:num) s) ‚áí countable s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", ...]),
    (‚Äú‚àÄa0 a1 a0' a1'. a0::a1 = a0'::a1' ‚áî a0 = a0' ‚àß a1 = a1'‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", ...]),
    (‚Äú‚àÄs1 s2. BIGINTER (s1 ‚à™ s2) = BIGINTER s1 ‚à© BIGINTER s2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM", ...]),
    (‚Äú‚àÄf s t. s √ó BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Œªn. s √ó f n) t)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", ...]),
    (‚ÄúPMATCH_EQUIV_ROWS v rows1 rows2 ‚áí PMATCH v rows1 = PMATCH v rows2‚Äù,
     ["patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE"]),
    (‚Äú‚àÄl x. SEG 1 (LENGTH l) (SNOC x l) = [x]‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (‚Äú‚àÄs. FINITE s ‚áí countable s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (‚Äú‚àÄl. FINITE (set l)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      ...]),
    (‚Äú‚àÄf x ls. MEM x ls ‚áí f x ‚â§ SUM (MAP f ls)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (‚Äú‚àÄx s. x ‚àà x INSERT s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (‚Äú‚àÄn l. n < LENGTH l ‚áí BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      ...]),
    (‚Äú‚àÄv p g p' g' RES.
          PMATCH_ROW_COND_EX v p g ‚áí
          (‚àÄx. g x ‚áí ((‚àÉx'. p' x' = p x ‚àß g' x') ‚áî RES)) ‚áí
          (PMATCH_ROW_COND_EX v p' g' ‚áî RES)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_AUX_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_def",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_OK",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_REWRITE",
      "patternMatchesTheory.REDUNDANT_ROWS_INFO_TO_PMATCH_EQ",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_ROWS_INFO_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_SUC",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_NIL",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_LT",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_GE",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_0",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_WEAKEN",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FULL_DEF",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FALSE",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_REWRITES",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC_PMATCH_ROW",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_NIL",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_EXTRACT_IS_EXHAUSTIVE",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_CONS",
      "patternMatchesTheory.FST_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.EL2_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL1_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_THMS",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", ...]),
    (‚Äú‚àÄx. ‚àÖ DELETE x = ‚àÖ‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", ...]),
    (‚Äú‚àÄs t. s DIFF t ‚à© s = s DIFF t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", ...]),
    (‚Äú‚àÄn l1 l2. TAKE n (l1 ‚ß∫ l2) = TAKE n l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (‚Äú‚àÄs t u. s ‚à© (t ‚à© u) = s ‚à© t ‚à© u‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (‚Äú‚àÄP. (‚àÄl. LENGTH l = 0 ‚áí P l) ‚áî P []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES", ...]),
    (‚ÄúASSOC $++‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L",
      "combinTheory.MONOID_DISJ_F", "combinTheory.MONOID_CONJ_T",
      "combinTheory.literal_case_FORALL_ELIM",
      "combinTheory.LET_FORALL_ELIM", "combinTheory.K_THM",
      "combinTheory.K_o_THM", "combinTheory.I_THM", "combinTheory.I_o_ID",
      "combinTheory.GEN_literal_case_RATOR",
      "combinTheory.GEN_literal_case_RAND", "combinTheory.GEN_LET_RATOR",
      "combinTheory.GEN_LET_RAND", "combinTheory.FCOMM_ASSOC",
      "combinTheory.FAIL_THM", "combinTheory.C_THM", "combinTheory.C_ABS_L",
      "combinTheory.ASSOC_SYM", "combinTheory.ASSOC_DISJ",
      "combinTheory.ASSOC_CONJ", "combinTheory.APPLY_UPDATE_THM",
      "combinTheory.APPLY_UPDATE_ID", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.UNIQUE_DEF",
      "listTheory.TL_DEF", "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF",
      "listTheory.SUM", "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.OPT_MMAP_def", "listTheory.oHD_def",
      "listTheory.oEL_def", ...]),
    (‚ÄúPMATCH_ROW_REDUNDANT v [] i ‚áî F‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (‚Äú‚àÄZRECSPACE'.
          ZRECSPACE' ind_type$ZBOT ‚àß
          (‚àÄc i r.
               (‚àÄn. ZRECSPACE' (r n)) ‚áí ZRECSPACE' (ind_type$ZCONSTR c i r)) ‚áí
          ‚àÄa0. ZRECSPACE a0 ‚áí ZRECSPACE' a0‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "ind_typeTheory.ZRECSPACE_def", "ind_typeTheory.ZCONSTR",
      "ind_typeTheory.ZBOT", "ind_typeTheory.NUMSUM_DEST",
      "ind_typeTheory.NUMSUM", "ind_typeTheory.NUMPAIR_DEST",
      "ind_typeTheory.NUMPAIR", "ind_typeTheory.INJP", "ind_typeTheory.INJN",
      "ind_typeTheory.INJF", "ind_typeTheory.INJA",
      "ind_typeTheory.ZRECSPACE_rules", "ind_typeTheory.ZCONSTR_ZBOT",
      "ind_typeTheory.NUMSUM_INJ", "ind_typeTheory.NUMPAIR_INJ_LEMMA",
      "ind_typeTheory.NUMPAIR_INJ", "ind_typeTheory.INJP_INJ",
      "ind_typeTheory.INJN_INJ", "ind_typeTheory.INJF_INJ",
      "ind_typeTheory.INJA_INJ", "ind_typeTheory.INJ_INVERSE2",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (‚Äú‚àÄl1 l2.
          LENGTH l1 = LENGTH l2 ‚áí
          ‚àÄx1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "pairTheory.UNCURRY_VAR",
      "pairTheory.SWAP_def", "pairTheory.RPROD_DEF",
      "pairTheory.prod_TY_DEF", "pairTheory.PROD_ALL_def",
      "pairTheory.PAIR_MAP", "pairTheory.pair_CASE_def", "pairTheory.PAIR",
      "pairTheory.LEX_DEF", "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (‚Äú¬¨SHORTLEX R l []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", ...]),
    (‚Äú‚àÄe. ‚àÉfn. fn () = e‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "oneTheory.one_TY_DEF", "oneTheory.one_DEF", "oneTheory.one_Axiom",
      "oneTheory.one_axiom", "oneTheory.one", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", ...]),
    (‚Äú‚àÄl. l ‚â† [] ‚áí FRONT l ‚ß∫ [LAST l] = l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", ...]),
    (‚Äú‚àÄl n. n < LENGTH l ‚áí LAST (DROP n l) = LAST l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", ...]),
    (‚Äú‚àÄn l. n ‚â§ LENGTH l ‚áí ‚àÄx. BUTLASTN n (x::l) = x::BUTLASTN n l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (‚Äú‚àÄf s t. DISJOINT s t ‚áí DISJOINT (PREIMAGE f s) (PREIMAGE f t)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (‚Äú(‚àÉls. P ls) ‚áî ‚àÉn f. P (GENLIST f n)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1", ...]),
    (‚Äúnub [] = []‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.NULL_DEF", "listTheory.nub_def",
      "listTheory.MAP", "listTheory.LUPDATE_def", "listTheory.LRC_def",
      "listTheory.LLEX_def", "listTheory.list_TY_DEF",
      "listTheory.LIST_TO_SET_DEF", "listTheory.list_size_def",
      "listTheory.LIST_LIFT2_def", "listTheory.LIST_IGNORE_BIND_def",
      "listTheory.LIST_GUARD_def", "listTheory.list_case_def",
      "listTheory.LIST_BIND_def", "listTheory.LIST_APPLY_def",
      "listTheory.LENGTH", "listTheory.LEN_DEF", "listTheory.LAST_DEF",
      "listTheory.isPREFIX", "listTheory.INDEX_OF_def",
      "listTheory.INDEX_FIND_def", "listTheory.HD", "listTheory.GENLIST_AUX",
      "listTheory.GENLIST", "listTheory.FRONT_DEF", "listTheory.FOLDR",
      "listTheory.FOLDL", "listTheory.FLAT", "listTheory.FIND_def",
      "listTheory.FILTER", "listTheory.EXISTS_DEF", "listTheory.EVERYi_def",
      "listTheory.EVERY_DEF", "listTheory.EL", "listTheory.DROP_def",
      "listTheory.APPEND", "listTheory.ALL_DISTINCT", "listTheory.ZIP_UNZIP",
      "listTheory.ZIP_MAP", "listTheory.ZIP_GENLIST", "listTheory.ZIP",
      "listTheory.WF_SHORTLEX_same_lengths", "listTheory.WF_SHORTLEX",
      "listTheory.WF_LIST_PRED", "listTheory.UNZIP_ZIP",
      "listTheory.UNZIP_THM", "listTheory.UNZIP_MAP",
      "listTheory.UNION_APPEND", ...]),
    (‚ÄúWF R‚Å∫ ‚áî WF R‚Äù,
     ["relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.SC_DEF", "relationTheory.RTC_def",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.equivalence_def",
      "relationTheory.EQC_DEF", "relationTheory.EMPTY_REL_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.WF_TC",
      "relationTheory.WF_SUBSET", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_irreflexive", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_INDUCTION_THM", "relationTheory.WF_EMPTY_REL",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_EQC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_MONOTONE",
      "relationTheory.TC_lifts_transitive_relations",
      "relationTheory.TC_lifts_monotonicities",
      "relationTheory.TC_lifts_invariants",
      "relationTheory.TC_lifts_equalities",
      "relationTheory.TC_INDUCT_RIGHT1", "relationTheory.TC_INDUCT_LEFT1",
      "relationTheory.TC_INDUCT_ALT_RIGHT",
      "relationTheory.TC_INDUCT_ALT_LEFT", "relationTheory.TC_INDUCT",
      "relationTheory.TC_implies_one_step", "relationTheory.TC_IDEM",
      "relationTheory.TC_CASES2_E", "relationTheory.TC_CASES2",
      "relationTheory.TC_CASES1_E", "relationTheory.TC_CASES1",
      "relationTheory.symmetric_TC", "relationTheory.symmetric_SC_identity",
      "relationTheory.symmetric_RC", "relationTheory.symmetric_EQC",
      "relationTheory.STRONG_EQC_INDUCTION", "relationTheory.SC_SYMMETRIC",
      "relationTheory.SC_MONOTONE", "relationTheory.SC_lifts_monotonicities",
      "relationTheory.SC_lifts_equalities", "relationTheory.SC_IDEM",
      "relationTheory.RTC_TC_RC", "relationTheory.RTC_SINGLE",
      "relationTheory.RTC_strongind", ...]),
    (‚Äú‚àÄn. countable (count n)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE", ...]),
    (‚Äú{x | y = x} = {y}‚Äù,
     ["pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM", ...]),
    (‚Äú‚àÄx l. SNOC x l = l ‚ß∫ [x]‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (‚Äú‚àÄs t. DISJOINT s t ‚áî ‚àÄx. x ‚àà s ‚áí x ‚àâ t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (‚ÄúGENLIST f 0 = [] ‚àß GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (‚Äú‚àÄs x. x ‚äÇ {s} ‚áî x = ‚àÖ‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (‚Äú‚àÄR. symmetric R·µÄ ‚áî symmetric R‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_ON_WFREC",
      "relationTheory.TC_TRANSITIVE", "relationTheory.TC_SUBSET",
      "relationTheory.TC_STRONG_INDUCT_RIGHT1", ...]),
    (‚Äú‚àÄt1 t2. (if F then t1 else t2) = t2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", ...]),
    (‚Äú‚àÄl1 l2. set (l1 ‚ß∫ l2) = set l1 ‚à™ set l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", ...]),
    (‚Äú‚àÄl1 l2. l2 ‚âº l1 ‚áî ‚àÉl. l1 = l2 ‚ß∫ l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (‚Äú‚àÄR. irreflexive R·µÄ ‚áî irreflexive R‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC", ...]),
    (‚Äú‚àÄs. CHOICE s ‚àâ REST s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", ...]),
    (‚Äú‚àÄl1 l2. l1 ‚ß∫ l2 = FOLDL (Œªl' x. SNOC x l') l1 l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", ...]),
    (‚Äú‚àÄL n. LEN L n = LENGTH L + n‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (‚Äú‚àÄx x' y y'. (x ‚áí y' ‚áí y) ‚àß (¬¨y' ‚áí x ‚áí x') ‚áí (x' ‚áí y') ‚áí x ‚áí y‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (‚Äú‚àÄP l. EVERY P l ‚áî ‚àÄe. MEM e l ‚áí P e‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", ...]),
    (‚Äú‚àÄn1 n2. count n1 = count n2 ‚áî n1 = n2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      ...]),
    (‚Äú‚àÄn. 0 < n ‚áí ‚àÄx l. EL n (x::l) = EL (PRE n) l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM", ...]),
    (‚Äú‚àÄe l. LIST_ELEM_COUNT e l > 0 ‚áî MEM e l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (‚Äú‚àÄt. t ‚à® t ‚áî t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (‚Äú(‚àÄx y. f x = f y ‚áî x = y) ‚áí
      (DISJOINT (IMAGE f s1) (IMAGE f s2) ‚áî DISJOINT s1 s2)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM", ...]),
    (‚Äú‚àÄx x' y y'. (y ‚áí x' ‚áí x) ‚àß (x' ‚áí y' ‚áí y) ‚áí x' ‚àß y' ‚áí x ‚àß y‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", ...]),
    (‚Äú‚àÄn. DROP n [] = []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (‚Äú‚àÄs. s ‚äÇ ùïå(:Œ±) ‚áî ‚àÉx. x ‚àâ s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (‚ÄúQ ($some P) ‚áí (‚àÉx. P x ‚àß Q (SOME x)) ‚à® (‚àÄx. ¬¨P x) ‚àß Q NONE‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.NONE_DEF", "optionTheory.THE_DEF",
      "optionTheory.SOME_SOME_APPLY", "optionTheory.some_intro",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME",
      "optionTheory.OPTREL_refl", "optionTheory.OPTREL_O",
      "optionTheory.OPTREL_MONO", "optionTheory.OPTREL_eq",
      "optionTheory.option_nchotomy", "optionTheory.OPTION_MCOMP_ID",
      "optionTheory.OPTION_MCOMP_ASSOC", "optionTheory.OPTION_MAP_id",
      "optionTheory.OPTION_MAP_EQ_SOME",
      "optionTheory.OPTION_MAP_EQ_NONE_both_ways",
      "optionTheory.OPTION_MAP_EQ_NONE", "optionTheory.OPTION_MAP_CONG",
      "optionTheory.OPTION_MAP_COMPOSE", "optionTheory.OPTION_MAP_CASE", ...]),
    (‚Äútransitive $SUBSET‚Äù,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.WCR_def",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.the_fun_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.STRORD", "relationTheory.StrongOrder",
      "relationTheory.StrongLinearOrder", "relationTheory.SN_def",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", "relationTheory.RRESTRICT_DEF",
      "relationTheory.RRANGE", "relationTheory.RINTER",
      "relationTheory.RESTRICT_DEF", "relationTheory.reflexive_def",
      "relationTheory.RDOM_DELETE_DEF", "relationTheory.RDOM_DEF",
      "relationTheory.RCOMPL", "relationTheory.rcdiamond_def",
      "relationTheory.RC_DEF", "relationTheory.PreOrder",
      "relationTheory.Order", "relationTheory.O_DEF",
      "relationTheory.nf_def", "relationTheory.LinearOrder",
      "relationTheory.irreflexive_def", ...]),
    (‚Äú‚àÄf g s t u. INJ f s t ‚àß INJ g t u ‚áí INJ (g ‚àò f) s u‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L", ...]),
    (‚Äú‚àÄy s f. IMAGE f s y ‚áî ‚àÉx. y = f x ‚àß x ‚àà s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", ...]),
    (‚Äú‚àÄf g s t u. SURJ f s t ‚àß SURJ g t u ‚áí SURJ (g ‚àò f) s u‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC", ...]),
    (‚Äú‚àÄf. INVOL f ‚áí ‚àÄa b. f a = f b ‚áî a = b‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.INVOL_DEF",
      "relationTheory.inv_image_def", "relationTheory.inv_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", ...]),
    (‚Äú‚àÄl1 l2 l3. l1 ‚ß∫ (l2 ‚ß∫ l3) = l1 ‚ß∫ l2 ‚ß∫ l3‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (‚Äú$OLEAST P = NONE ‚áî ‚àÄn. ¬¨P n‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "whileTheory.WHILE",
      "whileTheory.OLEAST_def", "whileTheory.LEAST_DEF",
      "whileTheory.HOARE_SPEC_DEF", "whileTheory.WHILE_RULE",
      "whileTheory.WHILE_INDUCTION", "whileTheory.OLEAST_INTRO",
      "whileTheory.OLEAST_EQNS", "whileTheory.LESS_LEAST",
      "whileTheory.LEAST_T", "whileTheory.LEAST_LESS_EQ",
      "whileTheory.LEAST_INTRO", "whileTheory.LEAST_EXISTS_IMP",
      "whileTheory.LEAST_EXISTS", "whileTheory.LEAST_EQ",
      "whileTheory.LEAST_ELIM", "whileTheory.ITERATION",
      "whileTheory.FULL_LEAST_INTRO", "optionTheory.some_def",
      "optionTheory.SOME_DEF", "optionTheory.OPTREL_def",
      "optionTheory.option_TY_DEF", "optionTheory.option_REP_ABS_DEF",
      "optionTheory.OPTION_MCOMP_def", "optionTheory.OPTION_MAP_DEF",
      "optionTheory.OPTION_MAP2_DEF", "optionTheory.OPTION_IGNORE_BIND_def",
      "optionTheory.OPTION_GUARD_def", "optionTheory.OPTION_CHOICE_def", ...]),
    (‚Äú‚àÄn l1 l2. DROP n (l1 ‚ß∫ l2) = DROP n l1 ‚ß∫ DROP (n ‚àí LENGTH l1) l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", ...]),
    (‚Äú‚àÄls f. EVERY (Œªx. ‚àÉy. x = f y) ls ‚áí ‚àÉl. ls = MAP f l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1", ...]),
    (‚Äú‚àÄopt. (‚àÉx. opt = SOME x) ‚à® opt = NONE‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.OPTION_ALL_def", "optionTheory.NONE_DEF",
      "optionTheory.THE_DEF", "optionTheory.SOME_SOME_APPLY",
      "optionTheory.some_intro", "optionTheory.some_F",
      "optionTheory.some_EQ", "optionTheory.some_elim",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME", ...]),
    (‚ÄúSURJ f s t ‚áí ‚àÉg. INJ g t s ‚àß ‚àÄy. y ‚àà t ‚áí f (g y) = y‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", ...]),
    (‚Äú‚àÄR x y z. RÍô≥ x y ‚àß R y z ‚áí R‚Å∫ x z‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", "relationTheory.irreflexive_def",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.RTC_TRANSITIVE",
      "relationTheory.transitive_RC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_lifts_transitive_relations", ...]),
    (‚Äú‚àÄf s t. INJ f s t ‚àß INFINITE s ‚áí INFINITE t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", ...]),
    (‚Äú‚àÄx1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2 ‚áí LENGTH l1 = LENGTH l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", ...]),
    (‚Äú‚àÄx l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF", ...]),
    (‚Äú‚àÄP n.
          (‚àÄl. LENGTH l = SUC n ‚áí P l) ‚áî
          ‚àÄl. LENGTH l = n ‚áí (Œªl. ‚àÄx. P (x::l)) l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", ...]),
    (‚Äúx ‚àà RDOM (RRESTRICT R s) ‚áî x ‚àà RDOM R ‚àß x ‚àà s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.STRORD",
      "relationTheory.StrongOrder", "relationTheory.StrongLinearOrder",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", ...]),
    (‚Äú‚àÄx l. FRONT (SNOC x l) = l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", ...]),
    (‚Äú‚àÄl x. MEM x (REVERSE l) ‚áî MEM x l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF", ...]),
    (‚Äú‚àÄl. NULL l ‚áî FOLDL (Œªx l'. F) T l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", ...]),
    (‚Äú‚àÄl m x. MEM x (DROP m l) ‚áí MEM x l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF", ...]),
    (‚Äú‚àÄx. ISR x ‚áí INR (OUTR x) = x‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "sumTheory.sum_TY_DEF", "sumTheory.sum_ISO_DEF", "sumTheory.OUTR",
      "sumTheory.OUTL", "sumTheory.ISR", "sumTheory.ISL",
      "sumTheory.IS_SUM_REP", "sumTheory.INR_DEF", "sumTheory.INL_DEF",
      "sumTheory.sum_INDUCT", "sumTheory.sum_distinct1",
      "sumTheory.sum_distinct", "sumTheory.sum_CASES", "sumTheory.sum_Axiom",
      ...]),
    (‚Äú[f] <*> l = MAP f l‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SET_TO_LIST_primitive_def", "listTheory.REVERSE_DEF",
      "listTheory.REV_DEF", "listTheory.PAD_RIGHT", "listTheory.PAD_LEFT",
      ...]),
    (‚Äú‚àÄn x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", ...]),
    (‚Äú‚àÄs x y. x INSERT s = {y} ‚áî x = y ‚àß s ‚äÜ {y}‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      ...]),
    (‚Äú‚àÄn l1 l2. l1 ‚âº l2 ‚àß n < LENGTH l1 ‚àß n < LENGTH l2 ‚áí EL n l1 = EL n l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", ...]),
    (‚Äú‚àÄR. reflexive (RC R)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", ...]),
    (‚ÄúR1 ‚àò·µ£ R2 ‚àò·µ£ R3 = (R1 ‚àò·µ£ R2) ‚àò·µ£ R3‚Äù,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF", ...]),
    (‚Äú‚àÄn. 0 < n ‚áí ‚àÄx l. ELL n (SNOC x l) = ELL (PRE n) l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", ...]),
    (‚Äú‚àÄl1 l2.
          ALL_DISTINCT (l1 ‚ß∫ l2) ‚áî
          ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄe. MEM e l1 ‚áí ¬¨MEM e l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (‚Äú‚àÄl. l ‚â† [] ‚áí BUTLASTN 1 l = FRONT l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", ...]),
    (‚Äú‚àÄs t. BIGUNION {s; t} = s ‚à™ t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF", ...]),
    (‚Äú‚àÄl2 l1. ¬¨NULL l2 ‚áí EL (LENGTH l1) (l1 ‚ß∫ l2) = HD l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", ...]),
    (‚Äúreflexive (R1 LEX R2) ‚áî reflexive R1 ‚à® reflexive R2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def", ...]),
    (‚ÄúINJ f s (IMAGE f s) ‚áí (countable (IMAGE f s) ‚áî countable s)‚Äù,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", ...]),
    (‚ÄúMAP f (LIST_BIND l g) = LIST_BIND l (MAP f ‚àò g)‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF", ...]),
    (‚ÄúFUNSET ùïå(:Œ±) ùïå(:Œ≤) = ùïå(:Œ± -> Œ≤)‚Äù, ["pred_setTheory.UNIV_DEF", ...]),
    (‚Äú‚àÄA B C. A ‚àß B ‚áí C ‚áî A ‚áí B ‚áí C‚Äù, [...]), ...]: (term * string list) list
> run_hh_pb_better data [holyHammer.Eprover, holyHammer.Vampire, holyHammer.Z3] 256 128;
‚àÄs t. t ‚äÜ s ‚áí s DIFF (s DIFF t) = t
proof failed.
Failed theorem:
‚àÄs t. t ‚äÜ s ‚áí s DIFF (s DIFF t) = t
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄset e. e ‚àà POW set ‚áî e ‚äÜ set
proof failed.
Failed theorem:
‚àÄset e. e ‚àà POW set ‚áî e ‚äÜ set
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FINITE ùïå(:Œ± # Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.CROSS_UNIV , pred_setTheory.FINITE_CROSS_EQ , pred_setTheory.UNIV_NOT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.CROSS_UNIV, pred_setTheory.FINITE_CROSS_EQ, pred_setTheory.UNIV_NOT_EMPTY]
‚àÄf s t. FINITE s ‚àß BIJ f s t ‚áí CARD s = CARD t
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_BIJ]
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.FINITE_BIJ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_BIJ]
{x | T} = ùïå(:Œ±)
proof failed.
Failed theorem:
{x | T} = ùïå(:Œ±)
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
COMPL ‚àÖ = ùïå(:Œ±)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.COMPL_COMPL , pred_setTheory.COMPL_DEF , pred_setTheory.DIFF_UNIV]
minimized proof:
  metis_tac [pred_setTheory.COMPL_COMPL, pred_setTheory.COMPL_DEF, pred_setTheory.DIFF_UNIV]
‚àÄs t. s = t ‚áî ‚àÄx. x ‚àà s ‚áî x ‚àà t
proof found by z3:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
proof failed.
Failed theorem:
‚àÄs t. s = t ‚áî ‚àÄx. x ‚àà s ‚áî x ‚àà t
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. (‚àÉf. BIJ f ùïå(:num) s) ‚áí countable s
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.BIJ_DEF , pred_setTheory.countable_surj]
minimized proof:
  metis_tac [pred_setTheory.BIJ_DEF, pred_setTheory.countable_surj]
‚àÄa0 a1 a0' a1'. a0::a1 = a0'::a1' ‚áî a0 = a0' ‚àß a1 = a1'
proof found by vampire:
  metisTools.METIS_TAC [listTheory.HD , listTheory.TL]
minimized proof:
  metis_tac [listTheory.HD, listTheory.TL]
‚àÄs1 s2. BIGINTER (s1 ‚à™ s2) = BIGINTER s1 ‚à© BIGINTER s2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
proof failed.
Failed theorem:
‚àÄs1 s2. BIGINTER (s1 ‚à™ s2) = BIGINTER s1 ‚à© BIGINTER s2
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf s t. s √ó BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Œªn. s √ó f n) t)
proof failed.
Failed theorem:
‚àÄf s t. s √ó BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Œªn. s √ó f n) t)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_EQUIV_ROWS v rows1 rows2 ‚áí PMATCH v rows1 = PMATCH v rows2
proof found by eprover:
  metisTools.METIS_TAC [patternMatchesTheory.PMATCH_EQUIV_ROWS_def]
minimized proof:
  metis_tac [patternMatchesTheory.PMATCH_EQUIV_ROWS_def]
‚àÄl x. SEG 1 (LENGTH l) (SNOC x l) = [x]
proof found by eprover:
  metisTools.METIS_TAC [arithmeticTheory.LESS_EQ_MONO , arithmeticTheory.ONE , arithmeticTheory.SUB_0 , arithmeticTheory.SUB_EQUAL_0 , arithmeticTheory.SUB_LESS_EQ , arithmeticTheory.ZERO_LESS_EQ , listTheory.LENGTH , listTheory.SNOC_APPEND , rich_listTheory.SEG , rich_listTheory.SEG_APPEND2]
minimized proof:
  metis_tac [arithmeticTheory.ONE, arithmeticTheory.SUB_0, arithmeticTheory.SUB_EQUAL_0, arithmeticTheory.SUB_LESS_EQ, listTheory.LENGTH, listTheory.SNOC_APPEND, rich_listTheory.SEG, rich_listTheory.SEG_APPEND2]
‚àÄs. FINITE s ‚áí countable s
proof failed.
Failed theorem:
‚àÄs. FINITE s ‚áí countable s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. FINITE (set l)
proof failed.
Failed theorem:
‚àÄl. FINITE (set l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf x ls. MEM x ls ‚áí f x ‚â§ SUM (MAP f ls)
proof failed.
Failed theorem:
‚àÄf x ls. MEM x ls ‚áí f x ‚â§ SUM (MAP f ls)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx s. x ‚àà x INSERT s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
‚àÄn l. n < LENGTH l ‚áí BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.INSERT_applied]
proof failed.
Failed theorem:
‚àÄn l. n < LENGTH l ‚áí BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄv p g p' g' RES.
    PMATCH_ROW_COND_EX v p g ‚áí
    (‚àÄx. g x ‚áí ((‚àÉx'. p' x' = p x ‚àß g' x') ‚áî RES)) ‚áí
    (PMATCH_ROW_COND_EX v p' g' ‚áî RES)
proof failed.
Failed theorem:
‚àÄv p g p' g' RES.
    PMATCH_ROW_COND_EX v p g ‚áí
    (‚àÄx. g x ‚áí ((‚àÉx'. p' x' = p x ‚àß g' x') ‚áî RES)) ‚áí
    (PMATCH_ROW_COND_EX v p' g' ‚áî RES)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx. ‚àÖ DELETE x = ‚àÖ
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.DELETE_NON_ELEMENT , pred_setTheory.NOT_IN_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.DELETE_NON_ELEMENT, pred_setTheory.NOT_IN_EMPTY]
‚àÄs t. s DIFF t ‚à© s = s DIFF t
proof failed.
Failed theorem:
‚àÄs t. s DIFF t ‚à© s = s DIFF t
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l1 l2. TAKE n (l1 ‚ß∫ l2) = TAKE n l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2
proof failed.
Failed theorem:
‚àÄn l1 l2. TAKE n (l1 ‚ß∫ l2) = TAKE n l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t u. s ‚à© (t ‚à© u) = s ‚à© t ‚à© u
proof failed.
Failed theorem:
‚àÄs t u. s ‚à© (t ‚à© u) = s ‚à© t ‚à© u
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP. (‚àÄl. LENGTH l = 0 ‚áí P l) ‚áî P []
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH , listTheory.NULL_EQ , listTheory.NULL_LENGTH]
minimized proof:
  metis_tac [listTheory.NULL_EQ, listTheory.NULL_LENGTH]
ASSOC $++
proof found by eprover:
  metisTools.METIS_TAC [combinTheory.ASSOC_DEF , listTheory.APPEND_ASSOC]
minimized proof:
  metis_tac [combinTheory.ASSOC_DEF, listTheory.APPEND_ASSOC]
PMATCH_ROW_REDUNDANT v [] i ‚áî F
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT v [] i ‚áî F
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄZRECSPACE'.
    ZRECSPACE' ind_type$ZBOT ‚àß
    (‚àÄc i r. (‚àÄn. ZRECSPACE' (r n)) ‚áí ZRECSPACE' (ind_type$ZCONSTR c i r)) ‚áí
    ‚àÄa0. ZRECSPACE a0 ‚áí ZRECSPACE' a0
proof failed.
Failed theorem:
‚àÄZRECSPACE'.
    ZRECSPACE' ind_type$ZBOT ‚àß
    (‚àÄc i r. (‚àÄn. ZRECSPACE' (r n)) ‚áí ZRECSPACE' (ind_type$ZCONSTR c i r)) ‚áí
    ‚àÄa0. ZRECSPACE a0 ‚áí ZRECSPACE' a0
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl1 l2.
    LENGTH l1 = LENGTH l2 ‚áí
    ‚àÄx1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
proof failed.
Failed theorem:
‚àÄl1 l2.
    LENGTH l1 = LENGTH l2 ‚áí
    ‚àÄx1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
¬¨SHORTLEX R l []
proof failed.
Failed theorem:
¬¨SHORTLEX R l []
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄe. ‚àÉfn. fn () = e
proof found by eprover:
  metisTools.METIS_TAC []
proof failed.
Failed theorem:
‚àÄe. ‚àÉfn. fn () = e
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. l ‚â† [] ‚áí FRONT l ‚ß∫ [LAST l] = l
proof failed.
Failed theorem:
‚àÄl. l ‚â† [] ‚áí FRONT l ‚ß∫ [LAST l] = l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl n. n < LENGTH l ‚áí LAST (DROP n l) = LAST l
proof failed.
Failed theorem:
‚àÄl n. n < LENGTH l ‚áí LAST (DROP n l) = LAST l
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l. n ‚â§ LENGTH l ‚áí ‚àÄx. BUTLASTN n (x::l) = x::BUTLASTN n l
proof failed.
Failed theorem:
‚àÄn l. n ‚â§ LENGTH l ‚áí ‚àÄx. BUTLASTN n (x::l) = x::BUTLASTN n l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf s t. DISJOINT s t ‚áí DISJOINT (PREIMAGE f s) (PREIMAGE f t)
proof failed.
Failed theorem:
‚àÄf s t. DISJOINT s t ‚áí DISJOINT (PREIMAGE f s) (PREIMAGE f t)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÉls. P ls) ‚áî ‚àÉn f. P (GENLIST f n)
proof failed.
Failed theorem:
(‚àÉls. P ls) ‚áî ‚àÉn f. P (GENLIST f n)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
nub [] = []
proof found by eprover:
  metisTools.METIS_TAC [listTheory.nub_def]
minimized proof:
  metis_tac [listTheory.nub_def]
WF R‚Å∫ ‚áî WF R
proof failed.
Failed theorem:
WF R‚Å∫ ‚áî WF R
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn. countable (count n)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.FINITE_COUNT , pred_setTheory.finite_countable]
minimized proof:
  metis_tac [pred_setTheory.FINITE_COUNT, pred_setTheory.finite_countable]
{x | y = x} = {y}
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.COUNTABLE_ALT]
proof failed.
Failed theorem:
{x | y = x} = {y}
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx l. SNOC x l = l ‚ß∫ [x]
proof failed.
Failed theorem:
‚àÄx l. SNOC x l = l ‚ß∫ [x]
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t. DISJOINT s t ‚áî ‚àÄx. x ‚àà s ‚áí x ‚àâ t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EXISTS_REFL , boolTheory.IN_DEF , pred_setTheory.DISJOINT_SYM , pred_setTheory.IN_DISJOINT]
minimized proof:
  metis_tac [pred_setTheory.IN_DISJOINT]
GENLIST f 0 = [] ‚àß GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []
proof found by vampire:
  metisTools.METIS_TAC [listTheory.GENLIST , listTheory.GENLIST_GENLIST_AUX]
minimized proof:
  metis_tac [listTheory.GENLIST, listTheory.GENLIST_GENLIST_AUX]
‚àÄs x. x ‚äÇ {s} ‚áî x = ‚àÖ
proof failed.
Failed theorem:
‚àÄs x. x ‚äÇ {s} ‚áî x = ‚àÖ
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR. symmetric R·µÄ ‚áî symmetric R
proof found by eprover:
  metisTools.METIS_TAC [relationTheory.inv_SC , relationTheory.inv_inv , relationTheory.symmetric_SC_identity]
minimized proof:
  metis_tac [relationTheory.inv_SC, relationTheory.inv_inv, relationTheory.symmetric_SC_identity]
‚àÄt1 t2. (if F then t1 else t2) = t2
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.bool_case_thm]
minimized proof:
  metis_tac []
‚àÄl1 l2. set (l1 ‚ß∫ l2) = set l1 ‚à™ set l2
proof failed.
Failed theorem:
‚àÄl1 l2. set (l1 ‚ß∫ l2) = set l1 ‚à™ set l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl1 l2. l2 ‚âº l1 ‚áî ‚àÉl. l1 = l2 ‚ß∫ l
proof failed.
Failed theorem:
‚àÄl1 l2. l2 ‚âº l1 ‚áî ‚àÉl. l1 = l2 ‚ß∫ l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR. irreflexive R·µÄ ‚áî irreflexive R
proof failed.
Failed theorem:
‚àÄR. irreflexive R·µÄ ‚áî irreflexive R
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. CHOICE s ‚àâ REST s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.IN_REST]
minimized proof:
  metis_tac [pred_setTheory.IN_REST]
‚àÄl1 l2. l1 ‚ß∫ l2 = FOLDL (Œªl' x. SNOC x l') l1 l2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.REST_applied]
proof failed.
Failed theorem:
‚àÄl1 l2. l1 ‚ß∫ l2 = FOLDL (Œªl' x. SNOC x l') l1 l2
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄL n. LEN L n = LENGTH L + n
proof failed.
Failed theorem:
‚àÄL n. LEN L n = LENGTH L + n
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx x' y y'. (x ‚áí y' ‚áí y) ‚àß (¬¨y' ‚áí x ‚áí x') ‚áí (x' ‚áí y') ‚áí x ‚áí y
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP l. EVERY P l ‚áî ‚àÄe. MEM e l ‚áí P e
proof failed.
Failed theorem:
‚àÄP l. EVERY P l ‚áî ‚àÄe. MEM e l ‚áí P e
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn1 n2. count n1 = count n2 ‚áî n1 = n2
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.CARD_COUNT]
minimized proof:
  metis_tac [pred_setTheory.CARD_COUNT]
‚àÄn. 0 < n ‚áí ‚àÄx l. EL n (x::l) = EL (PRE n) l
proof failed.
Failed theorem:
‚àÄn. 0 < n ‚áí ‚àÄx l. EL n (x::l) = EL (PRE n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄe l. LIST_ELEM_COUNT e l > 0 ‚áî MEM e l
proof failed.
Failed theorem:
‚àÄe l. LIST_ELEM_COUNT e l > 0 ‚áî MEM e l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄt. t ‚à® t ‚áî t
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄx y. f x = f y ‚áî x = y) ‚áí
(DISJOINT (IMAGE f s1) (IMAGE f s2) ‚áî DISJOINT s1 s2)
proof failed.
Failed theorem:
(‚àÄx y. f x = f y ‚áî x = y) ‚áí
(DISJOINT (IMAGE f s1) (IMAGE f s2) ‚áî DISJOINT s1 s2)
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx x' y y'. (y ‚áí x' ‚áí x) ‚àß (x' ‚áí y' ‚áí y) ‚áí x' ‚àß y' ‚áí x ‚àß y
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn. DROP n [] = []
proof failed.
Failed theorem:
‚àÄn. DROP n [] = []
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. s ‚äÇ ùïå(:Œ±) ‚áî ‚àÉx. x ‚àâ s
proof failed.
Failed theorem:
‚àÄs. s ‚äÇ ùïå(:Œ±) ‚áî ‚àÉx. x ‚àâ s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
Q ($some P) ‚áí (‚àÉx. P x ‚àß Q (SOME x)) ‚à® (‚àÄx. ¬¨P x) ‚àß Q NONE
proof failed.
Failed theorem:
Q ($some P) ‚áí (‚àÉx. P x ‚àß Q (SOME x)) ‚à® (‚àÄx. ¬¨P x) ‚àß Q NONE
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
transitive $SUBSET
proof failed.
Failed theorem:
transitive $SUBSET
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf g s t u. INJ f s t ‚àß INJ g t u ‚áí INJ (g ‚àò f) s u
proof failed.
Failed theorem:
‚àÄf g s t u. INJ f s t ‚àß INJ g t u ‚áí INJ (g ‚àò f) s u
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄy s f. IMAGE f s y ‚áî ‚àÉx. y = f x ‚àß x ‚àà s
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_IMAGE]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_IMAGE]
‚àÄf g s t u. SURJ f s t ‚àß SURJ g t u ‚áí SURJ (g ‚àò f) s u
proof failed.
Failed theorem:
‚àÄf g s t u. SURJ f s t ‚àß SURJ g t u ‚áí SURJ (g ‚àò f) s u
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf. INVOL f ‚áí ‚àÄa b. f a = f b ‚áî a = b
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.INVOL]
minimized proof:
  metis_tac [relationTheory.INVOL]
‚àÄl1 l2 l3. l1 ‚ß∫ (l2 ‚ß∫ l3) = l1 ‚ß∫ l2 ‚ß∫ l3
proof failed.
Failed theorem:
‚àÄl1 l2 l3. l1 ‚ß∫ (l2 ‚ß∫ l3) = l1 ‚ß∫ l2 ‚ß∫ l3
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
$OLEAST P = NONE ‚áî ‚àÄn. ¬¨P n
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , optionTheory.IS_NONE_DEF , optionTheory.IS_NONE_EQ_NONE , optionTheory.IS_SOME_DEF , whileTheory.OLEAST_INTRO]
minimized proof:
  metis_tac [optionTheory.IS_NONE_EQ_NONE, optionTheory.IS_SOME_DEF, whileTheory.OLEAST_INTRO]
‚àÄn l1 l2. DROP n (l1 ‚ß∫ l2) = DROP n l1 ‚ß∫ DROP (n ‚àí LENGTH l1) l2
proof failed.
Failed theorem:
‚àÄn l1 l2. DROP n (l1 ‚ß∫ l2) = DROP n l1 ‚ß∫ DROP (n ‚àí LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄls f. EVERY (Œªx. ‚àÉy. x = f y) ls ‚áí ‚àÉl. ls = MAP f l
proof failed.
Failed theorem:
‚àÄls f. EVERY (Œªx. ‚àÉy. x = f y) ls ‚áí ‚àÉl. ls = MAP f l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄopt. (‚àÉx. opt = SOME x) ‚à® opt = NONE
proof found by eprover:
  metisTools.METIS_TAC [optionTheory.option_nchotomy]
minimized proof:
  metis_tac [optionTheory.option_nchotomy]
SURJ f s t ‚áí ‚àÉg. INJ g t s ‚àß ‚àÄy. y ‚àà t ‚áí f (g y) = y
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.option_nchotomy]
proof failed.
Failed theorem:
SURJ f s t ‚áí ‚àÉg. INJ g t s ‚àß ‚àÄy. y ‚àà t ‚áí f (g y) = y
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR x y z. RÍô≥ x y ‚àß R y z ‚áí R‚Å∫ x z
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.RC_DEF , relationTheory.RTC_RTC , relationTheory.RTC_TC_RC , relationTheory.TC_RTC , relationTheory.TC_RULES]
minimized proof:
  metis_tac [relationTheory.RC_DEF, relationTheory.RTC_TC_RC, relationTheory.TC_RULES]
‚àÄf s t. INJ f s t ‚àß INFINITE s ‚áí INFINITE t
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_INJ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_INJ]
‚àÄx1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2 ‚áí LENGTH l1 = LENGTH l2
proof found by z3:
  metisTools.METIS_TAC [listTheory.SNOC_11]
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FRONT_SNOC]
minimized proof:
  metis_tac [listTheory.FRONT_SNOC]
‚àÄx l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
proof failed.
Failed theorem:
‚àÄx l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP n. (‚àÄl. LENGTH l = SUC n ‚áí P l) ‚áî ‚àÄl. LENGTH l = n ‚áí (Œªl. ‚àÄx. P (x::l)) l
proof failed.
Failed theorem:
‚àÄP n. (‚àÄl. LENGTH l = SUC n ‚áí P l) ‚áî ‚àÄl. LENGTH l = n ‚áí (Œªl. ‚àÄx. P (x::l)) l
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
x ‚àà RDOM (RRESTRICT R s) ‚áî x ‚àà RDOM R ‚àß x ‚àà s
proof failed.
Failed theorem:
x ‚àà RDOM (RRESTRICT R s) ‚áî x ‚àà RDOM R ‚àß x ‚àà s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx l. FRONT (SNOC x l) = l
proof failed.
Failed theorem:
‚àÄx l. FRONT (SNOC x l) = l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl x. MEM x (REVERSE l) ‚áî MEM x l
proof failed.
Failed theorem:
‚àÄl x. MEM x (REVERSE l) ‚áî MEM x l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. NULL l ‚áî FOLDL (Œªx l'. F) T l
proof failed.
Failed theorem:
‚àÄl. NULL l ‚áî FOLDL (Œªx l'. F) T l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl m x. MEM x (DROP m l) ‚áí MEM x l
proof failed.
Failed theorem:
‚àÄl m x. MEM x (DROP m l) ‚áí MEM x l
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx. ISR x ‚áí INR (OUTR x) = x
proof failed.
Failed theorem:
‚àÄx. ISR x ‚áí INR (OUTR x) = x
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
[f] <*> l = MAP f l
proof failed.
Failed theorem:
[f] <*> l = MAP f l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
proof failed.
Failed theorem:
‚àÄn x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs x y. x INSERT s = {y} ‚áî x = y ‚àß s ‚äÜ {y}
proof failed.
Failed theorem:
‚àÄs x y. x INSERT s = {y} ‚áî x = y ‚àß s ‚äÜ {y}
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l1 l2. l1 ‚âº l2 ‚àß n < LENGTH l1 ‚àß n < LENGTH l2 ‚áí EL n l1 = EL n l2
proof failed.
Failed theorem:
‚àÄn l1 l2. l1 ‚âº l2 ‚àß n < LENGTH l1 ‚àß n < LENGTH l2 ‚áí EL n l1 = EL n l2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR. reflexive (RC R)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , relationTheory.RC_DEF , relationTheory.reflexive_def]
minimized proof:
  metis_tac [relationTheory.RC_DEF, relationTheory.reflexive_def]
R1 ‚àò·µ£ R2 ‚àò·µ£ R3 = (R1 ‚àò·µ£ R2) ‚àò·µ£ R3
proof failed.
Failed theorem:
R1 ‚àò·µ£ R2 ‚àò·µ£ R3 = (R1 ‚àò·µ£ R2) ‚àò·µ£ R3
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn. 0 < n ‚áí ‚àÄx l. ELL n (SNOC x l) = ELL (PRE n) l
proof failed.
Failed theorem:
‚àÄn. 0 < n ‚áí ‚àÄx l. ELL n (SNOC x l) = ELL (PRE n) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl1 l2.
    ALL_DISTINCT (l1 ‚ß∫ l2) ‚áî
    ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄe. MEM e l1 ‚áí ¬¨MEM e l2
proof failed.
Failed theorem:
‚àÄl1 l2.
    ALL_DISTINCT (l1 ‚ß∫ l2) ‚áî
    ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄe. MEM e l1 ‚áí ¬¨MEM e l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. l ‚â† [] ‚áí BUTLASTN 1 l = FRONT l
proof found by z3:
  metisTools.METIS_TAC [arithmeticTheory.ONE , listTheory.APPEND_FRONT_LAST , listTheory.LENGTH , listTheory.LENGTH_NIL , rich_listTheory.BUTLASTN_LENGTH_APPEND]
minimized proof:
  metis_tac [arithmeticTheory.ONE, listTheory.APPEND_FRONT_LAST, listTheory.LENGTH, rich_listTheory.BUTLASTN_LENGTH_APPEND]
‚àÄs t. BIGUNION {s; t} = s ‚à™ t
proof failed.
Failed theorem:
‚àÄs t. BIGUNION {s; t} = s ‚à™ t
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl2 l1. ¬¨NULL l2 ‚áí EL (LENGTH l1) (l1 ‚ß∫ l2) = HD l2
proof failed.
Failed theorem:
‚àÄl2 l1. ¬¨NULL l2 ‚áí EL (LENGTH l1) (l1 ‚ß∫ l2) = HD l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
reflexive (R1 LEX R2) ‚áî reflexive R1 ‚à® reflexive R2
proof failed.
Failed theorem:
reflexive (R1 LEX R2) ‚áî reflexive R1 ‚à® reflexive R2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INJ f s (IMAGE f s) ‚áí (countable (IMAGE f s) ‚áî countable s)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.NOT_IN_EMPTY , pred_setTheory.image_countable , pred_setTheory.inj_countable]
minimized proof:
  metis_tac [pred_setTheory.image_countable, pred_setTheory.inj_countable]
MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ‚àò g)
proof failed.
Failed theorem:
MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ‚àò g)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FUNSET ùïå(:Œ±) ùïå(:Œ≤) = ùïå(:Œ± -> Œ≤)
proof failed.
Failed theorem:
FUNSET ùïå(:Œ±) ùïå(:Œ≤) = ùïå(:Œ± -> Œ≤)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄA B C. A ‚àß B ‚áí C ‚áî A ‚áí B ‚áí C
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP SND (FILTER (Œª(x,y). y ‚â† z) ls) = FILTER (Œªy. z ‚â† y) (MAP SND ls)
proof failed.
Failed theorem:
MAP SND (FILTER (Œª(x,y). y ‚â† z) ls) = FILTER (Œªy. z ‚â† y) (MAP SND ls)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REPLICATE n a ‚ß∫ REPLICATE m a = REPLICATE (n + m) a
proof failed.
Failed theorem:
REPLICATE n a ‚ß∫ REPLICATE m a = REPLICATE (n + m) a
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄb. ¬¨b ‚áí (b ‚áî F)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
‚àÄx y a b. (x,y) = (a,b) ‚áî x = a ‚àß y = b
proof found by vampire:
  metisTools.METIS_TAC [pairTheory.PAIR_EQ]
minimized proof:
  metis_tac [pairTheory.PAIR_EQ]
‚àÄf n x. MAP f (REPLICATE n x) = REPLICATE n (f x)
proof failed.
Failed theorem:
‚àÄf n x. MAP f (REPLICATE n x) = REPLICATE n (f x)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l. n < LENGTH l ‚áí SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
proof failed.
Failed theorem:
‚àÄn l. n < LENGTH l ‚áí SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_COND_EX i p g ‚áí
PMATCH_ROW p g r i = SOME (r (@x. PMATCH_ROW_COND p g i x))
proof failed.
Failed theorem:
PMATCH_ROW_COND_EX i p g ‚áí
PMATCH_ROW p g r i = SOME (r (@x. PMATCH_ROW_COND p g i x))
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR1 R2 x y. (R1 ‚à©·µ£ R2)Íô≥ x y ‚áí (R1Íô≥ ‚à©·µ£ R2Íô≥) x y
proof failed.
Failed theorem:
‚àÄR1 R2 x y. (R1 ‚à©·µ£ R2)Íô≥ x y ‚áí (R1Íô≥ ‚à©·µ£ R2Íô≥) x y
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP a s. (‚àÉx. x ‚àà a INSERT s ‚àß P x) ‚áî P a ‚à® ‚àÉx. x ‚àà s ‚àß P x
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.COMPONENT , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
‚àÄf g z. SUM_MAP f g z = if ISL z then INL (f (OUTL z)) else INR (g (OUTR z))
proof failed.
Failed theorem:
‚àÄf g z. SUM_MAP f g z = if ISL z then INL (f (OUTL z)) else INR (g (OUTR z))
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
proof failed.
Failed theorem:
‚àÄl. REVERSE (FLAT l) = FLAT (REVERSE (MAP REVERSE l))
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf1 f2 l. MAP f1 l = MAP f2 l ‚áî ‚àÄe. MEM e l ‚áí f1 e = f2 e
proof failed.
Failed theorem:
‚àÄf1 f2 l. MAP f1 l = MAP f2 l ‚áî ‚àÄe. MEM e l ‚áí f1 e = f2 e
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
$= ·µÄ = $=
proof found by z3:
  metisTools.METIS_TAC [relationTheory.EqIsBothRSUBSET , relationTheory.inv_inv , relationTheory.reflexive_Id_RSUBSET , relationTheory.reflexive_inv , relationTheory.symmetric_inv , relationTheory.symmetric_inv_RSUBSET , relationTheory.symmetric_inv_identity]
minimized proof:
  metis_tac [relationTheory.EqIsBothRSUBSET, relationTheory.inv_inv, relationTheory.reflexive_Id_RSUBSET, relationTheory.reflexive_inv, relationTheory.symmetric_inv_RSUBSET, relationTheory.symmetric_inv_identity]
‚àÄn l. n < LENGTH l ‚áí ELL n (REVERSE l) = ELL (PRE (LENGTH l ‚àí n)) l
proof failed.
Failed theorem:
‚àÄn l. n < LENGTH l ‚áí ELL n (REVERSE l) = ELL (PRE (LENGTH l ‚àí n)) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx s. ‚àÖ ‚â† x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.NOT_INSERT_EMPTY]
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.NOT_INSERT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.NOT_INSERT_EMPTY]
(¬¨SHORTLEX R [] [] ‚àß ¬¨SHORTLEX R (h1::t1) []) ‚àß SHORTLEX R [] (h2::t2) ‚àß
(SHORTLEX R (h1::t1) (h2::t2) ‚áî
 LENGTH t1 < LENGTH t2 ‚à®
 LENGTH t1 = LENGTH t2 ‚àß (R h1 h2 ‚à® h1 = h2 ‚àß SHORTLEX R t1 t2))
proof failed.
Failed theorem:
(¬¨SHORTLEX R [] [] ‚àß ¬¨SHORTLEX R (h1::t1) []) ‚àß SHORTLEX R [] (h2::t2) ‚àß
(SHORTLEX R (h1::t1) (h2::t2) ‚áî
 LENGTH t1 < LENGTH t2 ‚à®
 LENGTH t1 = LENGTH t2 ‚àß (R h1 h2 ‚à® h1 = h2 ‚àß SHORTLEX R t1 t2))
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄv. PMATCH_IS_EXHAUSTIVE v [] ‚áî F) ‚àß
‚àÄv r rs.
    PMATCH_IS_EXHAUSTIVE v (r::rs) ‚áî r v ‚â† NONE ‚à® PMATCH_IS_EXHAUSTIVE v rs
proof failed.
Failed theorem:
(‚àÄv. PMATCH_IS_EXHAUSTIVE v [] ‚áî F) ‚àß
‚àÄv r rs.
    PMATCH_IS_EXHAUSTIVE v (r::rs) ‚áî r v ‚â† NONE ‚à® PMATCH_IS_EXHAUSTIVE v rs
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄs. ùïå(:Œ±) ‚à© s = s) ‚àß ‚àÄs. s ‚à© ùïå(:Œ±) = s
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_INTER2 , pred_setTheory.SUBSET_INTER_ABSORPTION , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_INTER2, pred_setTheory.SUBSET_INTER_ABSORPTION, pred_setTheory.SUBSET_UNIV]
‚àÄf s t. BIJ f s t ‚áî f ‚àà FUNSET s t ‚àß ‚àÄy. y ‚àà t ‚áí ‚àÉ!x. x ‚àà s ‚àß y = f x
proof failed.
Failed theorem:
‚àÄf s t. BIJ f s t ‚áî f ‚àà FUNSET s t ‚àß ‚àÄy. y ‚àà t ‚áí ‚àÉ!x. x ‚àà s ‚àß y = f x
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l. n ‚â§ LENGTH l ‚áí BUTLASTN n l = TAKE (LENGTH l ‚àí n) l
proof failed.
Failed theorem:
‚àÄn l. n ‚â§ LENGTH l ‚áí BUTLASTN n l = TAKE (LENGTH l ‚àí n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl2 l1. IS_SUFFIX (REVERSE l1) (REVERSE l2) ‚áî l2 ‚âº l1
proof found by z3:
  metisTools.METIS_TAC [listTheory.SWAP_REVERSE_SYM , rich_listTheory.IS_PREFIX_REVERSE]
minimized proof:
  metis_tac [listTheory.SWAP_REVERSE_SYM, rich_listTheory.IS_PREFIX_REVERSE]
‚àÄs x y. x ‚àà s DELETE y ‚áî x ‚àà s ‚àß x ‚â† y
proof failed.
Failed theorem:
‚àÄs x y. x ‚àà s DELETE y ‚áî x ‚àà s ‚àß x ‚â† y
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄls n.
    n ‚â§ LENGTH ls ‚áí REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls ‚àí n) ls)
proof found by z3:
  metisTools.METIS_TAC [listTheory.REVERSE_11 , rich_listTheory.DROP_LASTN]
minimized proof:
  metis_tac [rich_listTheory.DROP_LASTN]
‚àÄf. PREIMAGE f ‚àÖ = ‚àÖ
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , rich_listTheory.DROP_LASTN]
proof failed.
Failed theorem:
‚àÄf. PREIMAGE f ‚àÖ = ‚àÖ
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf l. MAP f (REVERSE l) = REVERSE (MAP f l)
proof failed.
Failed theorem:
‚àÄf l. MAP f (REVERSE l) = REVERSE (MAP f l)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t x. (s ‚à™ t) x ‚áî x ‚àà s ‚à® x ‚àà t
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_UNION]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_UNION]
‚àÄn. LENGTH (COUNT_LIST n) = n
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH_GENLIST , rich_listTheory.COUNT_LIST_GENLIST]
minimized proof:
  metis_tac [listTheory.LENGTH_GENLIST, rich_listTheory.COUNT_LIST_GENLIST]
(‚àÉp. P p) ‚áî ‚àÉp_1 p_2. P (p_1,p_2)
proof found by z3:
  metisTools.METIS_TAC [boolTheory.UNWIND_THM2 , pairTheory.ABS_PAIR_THM]
minimized proof:
  metis_tac [pairTheory.ABS_PAIR_THM]
‚àÄl1 l2. l1 ‚ß∫ l2 = FOLDR CONS l2 l1
proof failed.
Failed theorem:
‚àÄl1 l2. l1 ‚ß∫ l2 = FOLDR CONS l2 l1
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs x. COMPL (x INSERT s) = COMPL s DELETE x
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.COMPL_DEF , pred_setTheory.DELETE_INTER , pred_setTheory.DIFF_INSERT , pred_setTheory.DIFF_INTER_COMPL]
minimized proof:
  metis_tac [pred_setTheory.COMPL_DEF, pred_setTheory.DELETE_INTER, pred_setTheory.DIFF_INSERT, pred_setTheory.DIFF_INTER_COMPL]
‚àÄt. t ‚áí T ‚áî T
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
countable ‚àÖ
proof found by eprover:
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.FINITE_EMPTY , pred_setTheory.finite_countable]
  metisTools.METIS_TAC [pred_setTheory.FINITE_EMPTY , pred_setTheory.finite_countable]
minimized proof:
  metis_tac [pred_setTheory.FINITE_EMPTY, pred_setTheory.finite_countable]
‚àÄR. Order R ‚áî StrongOrder (STRORD R)
proof failed.
Failed theorem:
‚àÄR. Order R ‚áî StrongOrder (STRORD R)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx x' y y'. (x ‚áí y ‚áí y') ‚àß (¬¨y' ‚áí x' ‚áí x) ‚áí (x ‚áí y) ‚áí x' ‚áí y'
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
x ‚âº y::ys ‚áî x = [] ‚à® ‚àÉxs. x = y::xs ‚àß xs ‚âº ys
proof failed.
Failed theorem:
x ‚âº y::ys ‚áî x = [] ‚à® ‚àÉxs. x = y::xs ‚àß xs ‚âº ys
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP l m. EVERY P l ‚áí EVERY P (TAKE m l)
proof found by z3:
  metisTools.METIS_TAC [listTheory.EVERY_APPEND , listTheory.TAKE_DROP]
minimized proof:
  metis_tac [listTheory.EVERY_APPEND, listTheory.TAKE_DROP]
IS_SOME (OPTION_BIND x g) ‚áí IS_SOME x
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_SOME_DEF , optionTheory.NOT_IS_SOME_EQ_NONE , optionTheory.OPTION_BIND_def]
minimized proof:
  metis_tac [optionTheory.NOT_IS_SOME_EQ_NONE, optionTheory.OPTION_BIND_def]
(‚àÄx y. R x y ‚áí Q x y) ‚áí RÍô≥ x y ‚áí QÍô≥ x y
proof failed.
Failed theorem:
(‚àÄx y. R x y ‚áí Q x y) ‚áí RÍô≥ x y ‚áí QÍô≥ x y
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx. x ‚âº x
proof failed.
Failed theorem:
‚àÄx. x ‚âº x
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
count 0 = ‚àÖ
proof failed.
Failed theorem:
count 0 = ‚àÖ
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄx. P x ‚áí Q x) ‚áí EXISTS P l ‚áí EXISTS Q l
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.F_DEF , boolTheory.IN_DEF , listTheory.EXISTS_MEM]
minimized proof:
  metis_tac [listTheory.EXISTS_MEM]
‚àÄs t. s ‚äÜ t ‚áí s ‚à© t = s
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_INTER_ABSORPTION]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_INTER_ABSORPTION]
‚àÄR x y. R x y ‚áí R‚Å∫ x y
proof found by eprover:
  metisTools.METIS_TAC [relationTheory.TC_RULES]
minimized proof:
  metis_tac [relationTheory.TC_RULES]
‚àÄxs. FILTER (Œªx. T) xs = xs
proof found by eprover:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_ID]
proof failed.
Failed theorem:
‚àÄxs. FILTER (Œªx. T) xs = xs
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. (Œªx. x) PERMUTES s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.TC_DEF]
proof failed.
Failed theorem:
‚àÄs. (Œªx. x) PERMUTES s
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl1 n. LENGTH l1 ‚â§ n ‚áí ‚àÄl2. TAKE n (l1 ‚ß∫ l2) = l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2
proof found by eprover:
  metisTools.METIS_TAC [arithmeticTheory.EQ_LESS_EQ , arithmeticTheory.LESS_EQ_REFL , arithmeticTheory.NOT_LESS , arithmeticTheory.SUB_EQUAL_0 , boolTheory.EQ_CLAUSES , listTheory.APPEND_NIL , listTheory.TAKE_0 , listTheory.TAKE_APPEND1 , listTheory.TAKE_APPEND2 , listTheory.TAKE_LENGTH_TOO_LONG]
minimized proof:
  metis_tac [arithmeticTheory.EQ_LESS_EQ, arithmeticTheory.NOT_LESS, arithmeticTheory.SUB_EQUAL_0, listTheory.APPEND_NIL, listTheory.TAKE_0, listTheory.TAKE_APPEND1, listTheory.TAKE_APPEND2, listTheory.TAKE_LENGTH_TOO_LONG]
‚àÄs. INFINITE s ‚áí ‚àÄt. s ‚äÜ t ‚áí INFINITE t
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_FINITE]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_FINITE]
option_CASE NONE = (Œªv f. v) ‚àß option_CASE (SOME x) = (Œªv f. f x)
proof found by eprover:
  metisTools.METIS_TAC [optionTheory.option_case_def]
minimized proof:
  metis_tac [optionTheory.option_case_def]
‚àÄt. t ‚áí F ‚áî ¬¨t
proof found by z3:
  metisTools.METIS_TAC [boolTheory.IMP_CLAUSES]
minimized proof:
  metis_tac []
‚àÄf1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
proof failed.
Failed theorem:
‚àÄf1 f2 l. FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf P Q. FUNSET P Q f ‚áî ‚àÄx. x ‚àà P ‚áí f x ‚àà Q
proof failed.
Failed theorem:
‚àÄf P Q. FUNSET P Q f ‚áî ‚àÄx. x ‚àà P ‚áí f x ‚àà Q
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
ùïå(:Œ± + Œ≤) = IMAGE INL ùïå(:Œ±) ‚à™ IMAGE INR ùïå(:Œ≤)
proof failed.
Failed theorem:
ùïå(:Œ± + Œ≤) = IMAGE INL ùïå(:Œ±) ‚à™ IMAGE INR ùïå(:Œ≤)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx s. s ‚äÜ x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.DELETE_SUBSET , pred_setTheory.SUBSET_INSERT_DELETE]
minimized proof:
  metis_tac [pred_setTheory.DELETE_SUBSET, pred_setTheory.SUBSET_INSERT_DELETE]
‚àÄl x. l ‚â† x::l ‚àß x::l ‚â† l
proof failed.
Failed theorem:
‚àÄl x. l ‚â† x::l ‚àß x::l ‚â† l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_SET ‚àÖ = 1 ‚àß
‚àÄx s. FINITE s ‚áí PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
proof failed.
Failed theorem:
PROD_SET ‚àÖ = 1 ‚àß
‚àÄx s. FINITE s ‚áí PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf s x. PREIMAGE f s x ‚áî f x ‚àà s
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.IN_PREIMAGE , pred_setTheory.SPECIFICATION]
minimized proof:
  metis_tac [pred_setTheory.IN_PREIMAGE, pred_setTheory.SPECIFICATION]
‚àÄf e l1 l2. FOLDR f e (l1 ‚ß∫ l2) = FOLDR f (FOLDR f e l2) l1
proof failed.
Failed theorem:
‚àÄf e l1 l2. FOLDR f e (l1 ‚ß∫ l2) = FOLDR f (FOLDR f e l2) l1
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l. n ‚â§ LENGTH l ‚áí DROP n l = LASTN (LENGTH l ‚àí n) l
proof failed.
Failed theorem:
‚àÄn l. n ‚â§ LENGTH l ‚áí DROP n l = LASTN (LENGTH l ‚àí n) l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l. n ‚â§ LENGTH l ‚áí LENGTH (TAKE n l) = n
proof failed.
Failed theorem:
‚àÄn l. n ‚â§ LENGTH l ‚áí LENGTH (TAKE n l) = n
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
0 < n ‚áí DROP n (x::xs) = DROP (n ‚àí 1) xs
proof failed.
Failed theorem:
0 < n ‚áí DROP n (x::xs) = DROP (n ‚àí 1) xs
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. AND_EL l ‚áî FOLDL $/\ T l
proof failed.
Failed theorem:
‚àÄl. AND_EL l ‚áî FOLDL $/\ T l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP l. FILTER P l = [] ‚áî EVERY (Œªx. ¬¨P x) l
proof failed.
Failed theorem:
‚àÄP l. FILTER P l = [] ‚áî EVERY (Œªx. ¬¨P x) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄv rows p infos.
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ‚áî
    p ‚àß EVERY (Œªr. r v = NONE) rows
proof failed.
Failed theorem:
‚àÄv rows p infos.
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ‚áî
    p ‚àß EVERY (Œªr. r v = NONE) rows
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. s ‚à© s = s
proof failed.
Failed theorem:
‚àÄs. s ‚à© s = s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx y z. x DIFF y DIFF z = x DIFF z DIFF y
proof failed.
Failed theorem:
‚àÄx y z. x DIFF y DIFF z = x DIFF z DIFF y
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄc x x' y y'.
    (c ‚áí x' ‚áí x) ‚àß (¬¨c ‚áí y' ‚áí y) ‚áí
    (if c then x' else y') ‚áí
    if c then x else y
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_IMP , boolTheory.COND_EXPAND_OR , boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
‚àÄx. SING {x}
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.SING_DEF]
minimized proof:
  metis_tac [pred_setTheory.SING_DEF]
(a,b) ‚àà {(x,x) | P x} ‚áî P a ‚àß a = b
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SING_DEF]
proof failed.
Failed theorem:
(a,b) ‚àà {(x,x) | P x} ‚áî P a ‚àß a = b
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄM M' v f.
    M = M' ‚àß (M' = [] ‚áí v = v') ‚àß (‚àÄa0 a1. M' = a0::a1 ‚áí f a0 a1 = f' a0 a1) ‚áí
    list_CASE M v f = list_CASE M' v' f'
proof failed.
Failed theorem:
‚àÄM M' v f.
    M = M' ‚àß (M' = [] ‚áí v = v') ‚àß (‚àÄa0 a1. M' = a0::a1 ‚áí f a0 a1 = f' a0 a1) ‚áí
    list_CASE M v f = list_CASE M' v' f'
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx l. SNOC x l ‚â† []
proof found by eprover:
  metisTools.METIS_TAC [listTheory.NOT_CONS_NIL , listTheory.REVERSE_DEF , listTheory.REVERSE_SNOC]
minimized proof:
  metis_tac [listTheory.NOT_CONS_NIL, listTheory.REVERSE_DEF, listTheory.REVERSE_SNOC]
‚àÄg f.
    FCOMM g f ‚áí
    ‚àÄe. LEFT_ID g e ‚áí ‚àÄl. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
proof failed.
Failed theorem:
‚àÄg f.
    FCOMM g f ‚áí
    ‚àÄe. LEFT_ID g e ‚áí ‚àÄl. FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄm n. m < SUC n ‚áí m ‚â† n ‚áí m < n
proof found by eprover:
  metisTools.METIS_TAC [prim_recTheory.LESS_THM]
minimized proof:
  metis_tac [prim_recTheory.LESS_THM]
‚àÄs t u. s ‚äÇ t ‚àß t ‚äÇ u ‚áí s ‚äÇ u
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , prim_recTheory.LESS_THM]
proof failed.
Failed theorem:
‚àÄs t u. s ‚äÇ t ‚àß t ‚äÇ u ‚áí s ‚äÇ u
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t. FINITE s ‚àß FINITE t ‚áí CARD (s ‚à™ t) = CARD s + CARD t ‚àí CARD (s ‚à© t)
proof failed.
Failed theorem:
‚àÄs t. FINITE s ‚àß FINITE t ‚áí CARD (s ‚à™ t) = CARD s + CARD t ‚àí CARD (s ‚à© t)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. ùïå(:Œ±) ‚äÜ s ‚áî s = ùïå(:Œ±)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.SUBSET_ANTISYM , pred_setTheory.SUBSET_REFL , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_ANTISYM, pred_setTheory.SUBSET_UNIV]
‚àÄv rows p infos.
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_ANTISYM , pred_setTheory.SUBSET_UNIV]
proof failed.
Failed theorem:
‚àÄv rows p infos.
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
LIST_REL R xs (h::t) ‚áî ‚àÉh' t'. xs = h'::t' ‚àß R h' h ‚àß LIST_REL R t' t
proof failed.
Failed theorem:
LIST_REL R xs (h::t) ‚áî ‚àÉh' t'. xs = h'::t' ‚àß R h' h ‚àß LIST_REL R t' t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄx y. P x ‚àß R x y ‚áí P y) ‚áí ‚àÄx y. P x ‚àß RÍô≥ x y ‚áí P y
proof failed.
Failed theorem:
(‚àÄx y. P x ‚àß R x y ‚áí P y) ‚áí ‚àÄx y. P x ‚àß RÍô≥ x y ‚áí P y
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(p ‚áî if q then r else s) ‚áî
(p ‚à® q ‚à® ¬¨s) ‚àß (p ‚à® ¬¨r ‚à® ¬¨q) ‚àß (p ‚à® ¬¨r ‚à® ¬¨s) ‚àß (¬¨q ‚à® r ‚à® ¬¨p) ‚àß (q ‚à® s ‚à® ¬¨p)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_OR , boolTheory.COND_RAND , boolTheory.EQ_CLAUSES , boolTheory.MONO_COND]
minimized proof:
  metis_tac []
‚àÄs x. x ‚àà s ‚áî ‚àÉt. s = x INSERT t ‚àß x ‚àâ t
proof failed.
Failed theorem:
‚àÄs x. x ‚àà s ‚áî ‚àÉt. s = x INSERT t ‚àß x ‚àâ t
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_REDUNDANT v (r::rs) 0 ‚áî r v = NONE
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT v (r::rs) 0 ‚áî r v = NONE
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t. DISJOINT t (s DIFF t) ‚àß DISJOINT (s DIFF t) t
proof failed.
Failed theorem:
‚àÄs t. DISJOINT t (s DIFF t) ‚àß DISJOINT (s DIFF t) t
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf s y. y ‚àà BIGUNION (IMAGE f s) ‚áî ‚àÉx. x ‚àà s ‚àß y ‚àà f x
proof failed.
Failed theorem:
‚àÄf s y. y ‚àà BIGUNION (IMAGE f s) ‚áî ‚àÉx. x ‚àà s ‚àß y ‚àà f x
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄe. LIST_ELEM_COUNT e [] = 0) ‚àß
(‚àÄe l1 l2.
     LIST_ELEM_COUNT e (l1 ‚ß∫ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ‚àß
(‚àÄe h l. h = e ‚áí LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ‚àß
‚àÄe h l. h ‚â† e ‚áí LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
proof failed.
Failed theorem:
(‚àÄe. LIST_ELEM_COUNT e [] = 0) ‚àß
(‚àÄe l1 l2.
     LIST_ELEM_COUNT e (l1 ‚ß∫ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ‚àß
(‚àÄe h l. h = e ‚áí LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ‚àß
‚àÄe h l. h ‚â† e ‚áí LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t x. (s ‚à© t) x ‚áî x ‚àà s ‚àß x ‚àà t
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.IN_INTER]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_INTER]
‚àÄP l1 l2. EXISTS P (l1 ‚ß∫ l2) ‚áî EXISTS P l1 ‚à® EXISTS P l2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_INTER]
proof failed.
Failed theorem:
‚àÄP l1 l2. EXISTS P (l1 ‚ß∫ l2) ‚áî EXISTS P l1 ‚à® EXISTS P l2
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄls f. MAP f (ZIP (ls,ls)) = MAP (Œªx. f (x,x)) ls
proof failed.
Failed theorem:
‚àÄls f. MAP f (ZIP (ls,ls)) = MAP (Œªx. f (x,x)) ls
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP f l = h::t ‚áî ‚àÉx0 t0. l = x0::t0 ‚àß h = f x0 ‚àß t = MAP f t0
proof failed.
Failed theorem:
MAP f l = h::t ‚áî ‚àÉx0 t0. l = x0::t0 ‚àß h = f x0 ‚àß t = MAP f t0
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR. symmetric R ‚áí SC R = R
proof failed.
Failed theorem:
‚àÄR. symmetric R ‚áí SC R = R
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl1 l2. SHORTLEX R l1 l2 ‚áí LENGTH l1 ‚â§ LENGTH l2
proof failed.
Failed theorem:
‚àÄl1 l2. SHORTLEX R l1 l2 ‚áí LENGTH l1 ‚â§ LENGTH l2
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
proof failed.
Failed theorem:
‚àÄf e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP.
    P ‚àÖ ‚àß (‚àÄs. FINITE s ‚àß P s ‚áí ‚àÄe. e ‚àâ s ‚áí P (e INSERT s)) ‚áí
    ‚àÄs. FINITE s ‚áí P s
proof failed.
Failed theorem:
‚àÄP.
    P ‚àÖ ‚àß (‚àÄs. FINITE s ‚àß P s ‚áí ‚àÄe. e ‚àâ s ‚áí P (e INSERT s)) ‚áí
    ‚àÄs. FINITE s ‚áí P s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. FINITE s ‚áí FINITE (REST s)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_DELETE , pred_setTheory.REST_DEF]
minimized proof:
  metis_tac [pred_setTheory.FINITE_DELETE, pred_setTheory.REST_DEF]
‚àÄs. FINITE s ‚áí ‚àÉf b. BIJ f (count b) s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.FINITE_BIJ_COUNT_EQ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_BIJ_COUNT_EQ]
‚àÄP l1 l2. EVERY P l1 ‚áí dropWhile P (l1 ‚ß∫ l2) = dropWhile P l2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.FINITE_BIJ_COUNT_EQ]
proof failed.
Failed theorem:
‚àÄP l1 l2. EVERY P l1 ‚áí dropWhile P (l1 ‚ß∫ l2) = dropWhile P l2
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(OPTION_IGNORE_BIND m1 m2 = NONE ‚áî m1 = NONE ‚à® m2 = NONE) ‚àß
(OPTION_IGNORE_BIND m1 m2 = SOME y ‚áî ‚àÉx. m1 = SOME x ‚àß m2 = SOME y)
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EXISTS_REFL , optionTheory.NOT_NONE_SOME , optionTheory.OPTION_BIND_EQUALS_OPTION , optionTheory.OPTION_IGNORE_BIND_def , optionTheory.OPTION_IGNORE_BIND_thm , optionTheory.option_nchotomy]
minimized proof:
  metis_tac [optionTheory.OPTION_IGNORE_BIND_thm, optionTheory.option_nchotomy]
‚àÄP l. EVERY P l ‚áî ¬¨EXISTS (Œªx. ¬¨P x) l
proof failed.
Failed theorem:
‚àÄP l. EVERY P l ‚áî ¬¨EXISTS (Œªx. ¬¨P x) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. s = ùïå(:Œ±) ‚áí ‚àÄv. v ‚àà s
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.EQ_UNIV , pred_setTheory.SPECIFICATION]
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
‚àÄn. SUC m = n ‚áí m < n
proof found by eprover:
  metisTools.METIS_TAC [prim_recTheory.LESS_SUC_REFL]
minimized proof:
  metis_tac [prim_recTheory.LESS_SUC_REFL]
((if P then SOME x else NONE) = NONE ‚áî ¬¨P) ‚àß
((if P then NONE else SOME x) = NONE ‚áî P) ‚àß
((if P then SOME x else NONE) = SOME y ‚áî P ‚àß x = y) ‚àß
((if P then NONE else SOME x) = SOME y ‚áî ¬¨P ‚àß x = y)
proof failed.
Failed theorem:
((if P then SOME x else NONE) = NONE ‚áî ¬¨P) ‚àß
((if P then NONE else SOME x) = NONE ‚áî P) ‚àß
((if P then SOME x else NONE) = SOME y ‚áî P ‚àß x = y) ‚àß
((if P then NONE else SOME x) = SOME y ‚áî ¬¨P ‚àß x = y)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some x. x) = SOME T
proof failed.
Failed theorem:
(some x. x) = SOME T
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REDUNDANT_ROWS_INFOS_CONJ [] [] = [] ‚àß
REDUNDANT_ROWS_INFOS_CONJ (i1::is1) (i2::is2) =
(i1 ‚àß i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
proof failed.
Failed theorem:
REDUNDANT_ROWS_INFOS_CONJ [] [] = [] ‚àß
REDUNDANT_ROWS_INFOS_CONJ (i1::is1) (i2::is2) =
(i1 ‚àß i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. SUM (FLAT l) = SUM (MAP SUM l)
proof failed.
Failed theorem:
‚àÄl. SUM (FLAT l) = SUM (MAP SUM l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx y. dest_rec x = dest_rec y ‚áî x = y
proof found by vampire:
  metisTools.METIS_TAC [ind_typeTheory.recspace_repfns]
minimized proof:
  metis_tac [ind_typeTheory.recspace_repfns]
(R1 LEX R2) (a,b) (c,d) ‚áî R1 a c ‚à® a = c ‚àß R2 b d
proof failed.
Failed theorem:
(R1 LEX R2) (a,b) (c,d) ‚áî R1 a c ‚à® a = c ‚àß R2 b d
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄl. [] ‚âº l ‚áî T) ‚àß (‚àÄx l. x::l ‚âº [] ‚áî F) ‚àß
‚àÄx1 l1 x2 l2. x2::l2 ‚âº x1::l1 ‚áî x1 = x2 ‚àß l2 ‚âº l1
proof found by eprover:
  metisTools.METIS_TAC [listTheory.isPREFIX_THM]
minimized proof:
  metis_tac [listTheory.isPREFIX_THM]
‚àÄn l. n ‚â§ LENGTH l ‚áí DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
proof found by z3:
  metisTools.METIS_TAC [listTheory.REVERSE_REVERSE , rich_listTheory.BUTLASTN_def]
minimized proof:
  metis_tac [listTheory.REVERSE_REVERSE, rich_listTheory.BUTLASTN_def]
‚àÄl f x. MEM x (MAP f l) ‚áî ‚àÉy. x = f y ‚àß MEM y l
proof found by vampire:
  metisTools.METIS_TAC [listTheory.REVERSE_REVERSE , rich_listTheory.BUTLASTN_def]
proof failed.
Failed theorem:
‚àÄl f x. MEM x (MAP f l) ‚áî ‚àÉy. x = f y ‚àß MEM y l
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf s t. s ‚äÜ t ‚áí PREIMAGE f s ‚äÜ PREIMAGE f t
proof failed.
Failed theorem:
‚àÄf s t. s ‚äÜ t ‚áí PREIMAGE f s ‚äÜ PREIMAGE f t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_ALL P Q (x,y) ‚áî P x ‚àß Q y
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pairTheory.FST , pairTheory.PROD_ALL_def , pairTheory.SND]
minimized proof:
  metis_tac [pairTheory.FST, pairTheory.PROD_ALL_def, pairTheory.SND]
‚àÄR x y. R‚Å∫ x y ‚áí RÍô≥ x y
proof failed.
Failed theorem:
‚àÄR x y. R‚Å∫ x y ‚áí RÍô≥ x y
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl2 l1. BUTLASTN (LENGTH l2) (l1 ‚ß∫ l2) = l1
proof failed.
Failed theorem:
‚àÄl2 l1. BUTLASTN (LENGTH l2) (l1 ‚ß∫ l2) = l1
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. LENGTH l = FOLDR (Œªx l'. SUC l') 0 l
proof failed.
Failed theorem:
‚àÄl. LENGTH l = FOLDR (Œªx l'. SUC l') 0 l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn l. n ‚â§ LENGTH l ‚áí LASTN n l = DROP (LENGTH l ‚àí n) l
proof failed.
Failed theorem:
‚àÄn l. n ‚â§ LENGTH l ‚áí LASTN n l = DROP (LENGTH l ‚àí n) l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄt. F ‚à® t ‚áî t
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf s. IMAGE f (PREIMAGE f s) ‚äÜ s
proof failed.
Failed theorem:
‚àÄf s. IMAGE f (PREIMAGE f s) ‚äÜ s
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t. s ‚äÇ t ‚áî s ‚äÜ t ‚àß ‚àÉy. y ‚àà t ‚àß y ‚àâ s
proof failed.
Failed theorem:
‚àÄs t. s ‚äÇ t ‚áî s ‚äÜ t ‚àß ‚àÉy. y ‚àà t ‚àß y ‚àâ s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
R‚Å∫ x z ‚áî R x z ‚à® ‚àÉy. R x y ‚àß R‚Å∫ y z
proof failed.
Failed theorem:
R‚Å∫ x z ‚áî R x z ‚à® ‚àÉy. R x y ‚àß R‚Å∫ y z
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄm n l.
    m ‚â§ n ‚àß n ‚â§ LENGTH l ‚áí
    BUTLASTN m (LASTN n l) = LASTN (n ‚àí m) (BUTLASTN m l)
proof failed.
Failed theorem:
‚àÄm n l.
    m ‚â§ n ‚àß n ‚â§ LENGTH l ‚áí
    BUTLASTN m (LASTN n l) = LASTN (n ‚àí m) (BUTLASTN m l)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf P Q. f ‚àà DFUNSET P Q ‚áî ‚àÄx. x ‚àà P ‚áí f x ‚àà Q x
proof failed.
Failed theorem:
‚àÄf P Q. f ‚àà DFUNSET P Q ‚áî ‚àÄx. x ‚àà P ‚áí f x ‚àà Q x
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄx. MEM x [] ‚áî F) ‚àß ‚àÄx h t. MEM x (h::t) ‚áî x = h ‚à® MEM x t
proof failed.
Failed theorem:
(‚àÄx. MEM x [] ‚áî F) ‚àß ‚àÄx h t. MEM x (h::t) ‚áî x = h ‚à® MEM x t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx s. x ‚àâ s ‚áî s DELETE x = s
proof failed.
Failed theorem:
‚àÄx s. x ‚àâ s ‚áî s DELETE x = s
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(INL a ‚àà A ‚äî B ‚áî a ‚àà A) ‚àß (INR b ‚àà A ‚äî B ‚áî b ‚àà B)
proof failed.
Failed theorem:
(INL a ‚àà A ‚äî B ‚áî a ‚àà A) ‚àß (INR b ‚àà A ‚äî B ‚áî b ‚àà B)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
WF (Œªx y. y = SUC x)
proof failed.
Failed theorem:
WF (Œªx y. y = SUC x)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄL n. SUM_ACC L n = SUM L + n
proof failed.
Failed theorem:
‚àÄL n. SUM_ACC L n = SUM L + n
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INFINITE ùïå(:Œ±) ‚áî ‚àÄs. FINITE s ‚áí s ‚äÇ ùïå(:Œ±)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.FINITE_PSUBSET_INFINITE , pred_setTheory.NOT_UNIV_PSUBSET , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.FINITE_PSUBSET_INFINITE, pred_setTheory.SUBSET_UNIV]
‚àÄf. (‚àÄs. INJ f ‚àÖ s) ‚àß ‚àÄs. INJ f s ‚àÖ ‚áî s = ‚àÖ
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.EQ_UNIV , pred_setTheory.FINITE_PSUBSET_INFINITE , pred_setTheory.PSUBSET_UNIV , pred_setTheory.SPECIFICATION]
proof failed.
Failed theorem:
‚àÄf. (‚àÄs. INJ f ‚àÖ s) ‚àß ‚àÄs. INJ f s ‚àÖ ‚áî s = ‚àÖ
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl f. (MAP f l = [] ‚áî l = []) ‚àß ([] = MAP f l ‚áî l = [])
proof found by eprover:
  metisTools.METIS_TAC [listTheory.MAP , listTheory.NOT_CONS_NIL , listTheory.list_CASES]
minimized proof:
  metis_tac [listTheory.MAP, listTheory.NOT_CONS_NIL, listTheory.list_CASES]
‚àÄl. SUM l = FOLDR $+ 0 l
proof failed.
Failed theorem:
‚àÄl. SUM l = FOLDR $+ 0 l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR l1 l2 n. LIST_REL R l1 l2 ‚áí LIST_REL R (DROP n l1) (DROP n l2)
proof failed.
Failed theorem:
‚àÄR l1 l2 n. LIST_REL R l1 l2 ‚áí LIST_REL R (DROP n l1) (DROP n l2)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some x. F) = NONE
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_NONE_DEF , optionTheory.IS_NONE_EQ_NONE , optionTheory.some_intro]
proof failed.
Failed theorem:
(some x. F) = NONE
End printing
reconstruction failed
proof found by eprover:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf l1 l2. MAP f (l1 ‚ß∫ l2) = MAP f l1 ‚ß∫ MAP f l2
proof failed.
Failed theorem:
‚àÄf l1 l2. MAP f (l1 ‚ß∫ l2) = MAP f l1 ‚ß∫ MAP f l2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄg f.
    FCOMM g f ‚áí
    ‚àÄe.
        LEFT_ID g e ‚áí
        ‚àÄl1 l2. FOLDR f e (l1 ‚ß∫ l2) = g (FOLDR f e l1) (FOLDR f e l2)
proof failed.
Failed theorem:
‚àÄg f.
    FCOMM g f ‚áí
    ‚àÄe.
        LEFT_ID g e ‚áí
        ‚àÄl1 l2. FOLDR f e (l1 ‚ß∫ l2) = g (FOLDR f e l1) (FOLDR f e l2)
End printing
ATPs could not find a proof
proof found by eprover:
proof found by z3:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÖ x ‚áî F
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.EMPTY_DEF]
minimized proof:
  metis_tac [pred_setTheory.EMPTY_DEF]
‚àÄR. WeakLinearOrder R ‚áî WeakOrder R ‚àß ‚àÄa b. R a b ‚à® R b a
proof failed.
Failed theorem:
‚àÄR. WeakLinearOrder R ‚áî WeakOrder R ‚àß ‚àÄa b. R a b ‚à® R b a
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄR R'. (R ‚àò·µ£ R')·µÄ = R'·µÄ ‚àò·µ£ R·µÄ
proof failed.
Failed theorem:
‚àÄR R'. (R ‚àò·µ£ R')·µÄ = R'·µÄ ‚àò·µ£ R·µÄ
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx l. x::l = [x] ‚ß∫ l
proof found by eprover:
  metisTools.METIS_TAC [listTheory.APPEND]
minimized proof:
  metis_tac [listTheory.APPEND]
‚àÄf l. MAP f l = FOLDR (Œªx l'. f x::l') [] l
proof failed.
Failed theorem:
‚àÄf l. MAP f l = FOLDR (Œªx l'. f x::l') [] l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx. x ‚àà ùïå(:Œ±)
proof found by eprover:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
ùïå(:Œ± + Œ≤) = ùïå(:Œ±) ‚äî ùïå(:Œ≤)
proof failed.
Failed theorem:
ùïå(:Œ± + Œ≤) = ùïå(:Œ±) ‚äî ùïå(:Œ≤)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs t g. (s DIFF t) ‚à© g = s ‚à© g DIFF t
proof failed.
Failed theorem:
‚àÄs t g. (s DIFF t) ‚à© g = s ‚à© g DIFF t
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄQ P. (‚àÉn. P n) ‚àß (‚àÄn. (‚àÄm. m < n ‚áí ¬¨P m) ‚àß P n ‚áí Q n) ‚áí Q ($LEAST P)
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , whileTheory.LEAST_INTRO , whileTheory.LESS_LEAST]
minimized proof:
  metis_tac [whileTheory.LEAST_INTRO, whileTheory.LESS_LEAST]
‚àÄxs. FILTER (Œªx. F) xs = []
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.F_DEF , listTheory.FILTER_NEQ_NIL]
proof failed.
Failed theorem:
‚àÄxs. FILTER (Œªx. F) xs = []
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_NIL]
proof failed.
Failed theorem:
‚àÄf x s. IMAGE f (x INSERT s) = f x INSERT IMAGE f s
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl1 l2. TAKE (LENGTH l1) (l1 ‚ß∫ l2) = l1
proof failed.
Failed theorem:
‚àÄl1 l2. TAKE (LENGTH l1) (l1 ‚ß∫ l2) = l1
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. FLAT l = FOLDR $++ [] l
proof failed.
Failed theorem:
‚àÄl. FLAT l = FOLDR $++ [] l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(¬¨LLEX R [] [] ‚àß ¬¨LLEX R (h1::t1) []) ‚àß LLEX R [] (h2::t2) ‚àß
(LLEX R (h1::t1) (h2::t2) ‚áî R h1 h2 ‚à® h1 = h2 ‚àß LLEX R t1 t2)
proof failed.
Failed theorem:
(¬¨LLEX R [] [] ‚àß ¬¨LLEX R (h1::t1) []) ‚àß LLEX R [] (h2::t2) ‚àß
(LLEX R (h1::t1) (h2::t2) ‚áî R h1 h2 ‚à® h1 = h2 ‚àß LLEX R t1 t2)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl. l ‚ß∫ [] = l
proof failed.
Failed theorem:
‚àÄl. l ‚ß∫ [] = l
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs f. f ‚àà FUNSET s ‚àÖ ‚áî s = ‚àÖ
proof failed.
Failed theorem:
‚àÄs f. f ‚àà FUNSET s ‚àÖ ‚áî s = ‚àÖ
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by vampire:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄb. b ‚áí (b ‚áî T)
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl x. ELL 0 (SNOC x l) = x
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LAST_SNOC , rich_listTheory.ELL]
minimized proof:
  metis_tac [listTheory.LAST_SNOC, rich_listTheory.ELL]
‚àÄls. ls ‚â† [] ‚áí MAP f (FRONT ls) = FRONT (MAP f ls)
proof failed.
Failed theorem:
‚àÄls. ls ‚â† [] ‚áí MAP f (FRONT ls) = FRONT (MAP f ls)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄn. 0 < SUC n
proof failed.
Failed theorem:
‚àÄn. 0 < SUC n
End printing
ATPs could not find a proof
proof found by z3:
proof found by eprover:
  metisTools.METIS_TAC []
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
IMAGE f s = {z} ‚áî s ‚â† ‚àÖ ‚àß ‚àÄx. x ‚àà s ‚áí f x = z
proof failed.
Failed theorem:
IMAGE f s = {z} ‚áî s ‚â† ‚àÖ ‚àß ‚àÄx. x ‚àà s ‚áí f x = z
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄf e l. FOLDR f e l = FOLDL (Œªx y. f y x) e (REVERSE l)
proof failed.
Failed theorem:
‚àÄf e l. FOLDR f e l = FOLDL (Œªx y. f y x) e (REVERSE l)
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄl1 l2 a. IS_SUFFIX l1 l2 ‚áí IS_SUFFIX (a::l1) l2
proof failed.
Failed theorem:
‚àÄl1 l2 a. IS_SUFFIX l1 l2 ‚áí IS_SUFFIX (a::l1) l2
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄx P. x ‚àà P ‚áî P x
proof found by eprover:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
minimized proof:
  metis_tac [IN_DEF]
‚àÄR. StrongOrder R ‚áí Order R
proof found by z3:
  metisTools.METIS_TAC [relationTheory.Order , relationTheory.StrongOrder , relationTheory.irrefl_trans_implies_antisym]
minimized proof:
  metis_tac [relationTheory.Order, relationTheory.StrongOrder, relationTheory.irrefl_trans_implies_antisym]
‚àÄn l. n < LENGTH l ‚áí MEM (EL n l) l
proof found by z3:
  metisTools.METIS_TAC [listTheory.MEM_EL]
minimized proof:
  metis_tac [listTheory.MEM_EL]
‚àÄx y P. x ‚àà y INSERT P ‚áî x = y ‚à® x ‚â† y ‚àß x ‚àà P
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.INSERT_applied , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
OWHILE G f s = SOME s' ‚áí ¬¨G s'
proof failed.
Failed theorem:
OWHILE G f s = SOME s' ‚áí ¬¨G s'
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
symmetric R1 ‚àß symmetric R2 ‚áí symmetric (R1 LEX R2)
proof failed.
Failed theorem:
symmetric R1 ‚àß symmetric R2 ‚áí symmetric (R1 LEX R2)
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄP l. PREFIX P l ‚âº l
proof failed.
Failed theorem:
‚àÄP l. PREFIX P l ‚âº l
End printing
ATPs could not find a proof
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs f. (‚àÉt. INJ f s t) ‚áí BIJ f s (IMAGE f s)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.BIJ_DEF , pred_setTheory.IMAGE_SURJ , pred_setTheory.INJ_IMAGE]
proof failed.
Failed theorem:
‚àÄs f. (‚àÉt. INJ f s t) ‚áí BIJ f s (IMAGE f s)
End printing
reconstruction failed
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄs. s DIFF ùïå(:Œ±) = ‚àÖ
proof failed.
Failed theorem:
‚àÄs. s DIFF ùïå(:Œ±) = ‚àÖ
End printing
ATPs could not find a proof
proof found by eprover:
  metisTools.METIS_TAC []
proof found by z3:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄt. t ‚àß t ‚áî t
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÉx. x ‚àà s) ‚àß (‚àÄx. x ‚àà s ‚áí P x) ‚áí P (CHOICE s)
proof found by z3:
  metisTools.METIS_TAC [pred_setTheory.CHOICE_DEF , pred_setTheory.MEMBER_NOT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.CHOICE_DEF, pred_setTheory.MEMBER_NOT_EMPTY]
proof found by z3:
  metisTools.METIS_TAC []
proof found by eprover:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
val it = fn: tactic
>
