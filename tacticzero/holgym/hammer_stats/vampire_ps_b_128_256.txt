
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Mon May 17 01:15:23 2021)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
> > > > Loading holyHammer
> > > > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > > > > > > > signature JSON =
  sig
    datatype json =
        ARRAY of json list
      | BOOL of bool
      | NULL
      | NUMBER of real
      | OBJECT of (string * json) list
      | STRING of string
    val parse: string -> json result
    datatype 'a result = ERROR of string | OK of 'a
    val serialise: json -> string
    val serialiseIndented: json -> string
  end
structure Json: JSON
val it = (): unit
val it = (): unit
val infile = "test_dep_dict.json": string
val readjson = fn: string -> Json.json Json.result
val readfirstkey = fn: string -> string
val allterms = fn: string -> term list
val json_string_to_string = fn: Json.json -> string
val string_to_term = fn: string -> term
val value_to_input = fn: string * Json.json -> term * string list
val value_to_term = fn: string * Json.json -> term
val firstpair = fn: string -> (term * string list) list
val construct_hh_input = fn: term * string list -> tactic
val gen_data = fn: string -> (term * string list) list
val gen_premises = fn: goal -> int -> string list -> string list
val gen_premises_better = fn:
   goal -> int -> string list -> int -> string list
val premise_filter = fn: ''a list -> ''a list -> ''a list
val premise_filter_better = fn: ''a list -> ''a list -> int -> ''a list
val premise_selection = fn: goal -> int -> string list
val run_hh_pb = fn: (term * string list) list -> prover list -> tactic
val it = (): unit
val run_hh_pb_better = fn:
   (term * string list) list -> prover list -> int -> int -> tactic
val it = (): unit
>
*** Emacs/HOL command completed ***

> val data = gen_data infile;
val data =
   [(‚Äú‚àÄs t. t ‚äÜ s ‚áí s DIFF (s DIFF t) = t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", "boolTheory.LEFT_EXISTS_IMP_THM",
      ...]),
    (‚Äú‚àÄset e. e ‚àà POW set ‚áî e ‚äÜ set‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", ...]),
    (‚ÄúFINITE ùïå(:Œ± # Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM", ...]),
    (‚Äú‚àÄf s t. FINITE s ‚àß BIJ f s t ‚áí CARD s = CARD t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", ...]),
    (‚Äú{x | T} = ùïå(:Œ±)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", ...]),
    (‚ÄúCOMPL ‚àÖ = ùïå(:Œ±)‚Äù,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", "pred_setTheory.SUBSET_DEF",
      "pred_setTheory.SING_DEF", "pred_setTheory.schroeder_close_def",
      "pred_setTheory.RINV_LO", "pred_setTheory.REST_DEF",
      "pred_setTheory.REL_RESTRICT_DEF", "pred_setTheory.PSUBSET_DEF",
      "pred_setTheory.LINV_OPT_def", "pred_setTheory.LINV_LO",
      "pred_setTheory.INTER_DEF", "pred_setTheory.INSERT_DEF",
      "pred_setTheory.INJ_DEF", "pred_setTheory.IMAGE_DEF",
      "pred_setTheory.HAS_SIZE", "pred_setTheory.GSPECIFICATION",
      "pred_setTheory.FUNSET", "pred_setTheory.FINITE_DEF",
      "pred_setTheory.EMPTY_DEF", "pred_setTheory.disjUNION_def",
      "pred_setTheory.DISJOINT_DEF", "pred_setTheory.DIFF_DEF",
      "pred_setTheory.DFUNSET", "pred_setTheory.DELETE_DEF",
      "pred_setTheory.CROSS_DEF", "pred_setTheory.count_def",
      "pred_setTheory.COMPL_DEF", "pred_setTheory.CHOICE_DEF",
      "pred_setTheory.CARD_DEF", "pred_setTheory.BIJ_DEF",
      "pred_setTheory.BIGUNION", "pred_setTheory.BIGINTER",
      "pred_setTheory.UNIV_SUBSET", "pred_setTheory.UNIV_NOT_EMPTY",
      "pred_setTheory.UNIV_FUNSET_UNIV", "pred_setTheory.UNIV_BOOL",
      "pred_setTheory.UNIV_applied", "pred_setTheory.UNION_UNIV",
      "pred_setTheory.UNION_SUBSET", "pred_setTheory.UNION_OVER_INTER",
      "pred_setTheory.UNION_IDEMPOT", "pred_setTheory.UNION_EMPTY",
      "pred_setTheory.UNION_DIFF_EQ", "pred_setTheory.UNION_DIFF",
      "pred_setTheory.UNION_COMM", "pred_setTheory.UNION_ASSOC",
      "pred_setTheory.UNION_applied", "pred_setTheory.transitive_PSUBSET",
      "pred_setTheory.TC_SUBSET_THM", "pred_setTheory.TC_PSUBSET",
      "pred_setTheory.SURJ_INJ_INV", "pred_setTheory.SURJ_IMP_INJ",
      "pred_setTheory.SURJ_IMAGE", "pred_setTheory.SURJ_ID",
      "pred_setTheory.SURJ_EMPTY", "pred_setTheory.SURJ_COMPOSE",
      "pred_setTheory.SURJ_CARD", "pred_setTheory.SUM_UNIV",
      "pred_setTheory.SUBSET_UNIV", "pred_setTheory.SUBSET_UNION_ABSORPTION",
      "pred_setTheory.SUBSET_UNION", "pred_setTheory.SUBSET_transitive",
      "pred_setTheory.SUBSET_TRANS", "pred_setTheory.SUBSET_THM",
      "pred_setTheory.SUBSET_reflexive", "pred_setTheory.SUBSET_REFL",
      "pred_setTheory.SUBSET_OF_INSERT", "pred_setTheory.SUBSET_K",
      "pred_setTheory.SUBSET_INTER_ABSORPTION",
      "pred_setTheory.SUBSET_INTER2", "pred_setTheory.SUBSET_INTER1",
      "pred_setTheory.SUBSET_INTER", "pred_setTheory.SUBSET_INSERT_DELETE",
      "pred_setTheory.SUBSET_INSERT", "pred_setTheory.SUBSET_IMAGE",
      "pred_setTheory.SUBSET_FINITE_I", "pred_setTheory.SUBSET_FINITE",
      "pred_setTheory.SUBSET_EQ_CARD", "pred_setTheory.SUBSET_EMPTY",
      "pred_setTheory.SUBSET_DISJOINT", "pred_setTheory.SUBSET_DELETE",
      "pred_setTheory.SUBSET_CROSS", "pred_setTheory.SUBSET_BIGUNION_I",
      "pred_setTheory.SUBSET_BIGUNION", "pred_setTheory.SUBSET_BIGINTER",
      "pred_setTheory.SUBSET_applied", "pred_setTheory.SUBSET_ANTISYM_EQ",
      "pred_setTheory.SUBSET_ANTISYM", "pred_setTheory.SUBSET_ADD",
      "pred_setTheory.SPECIFICATION", "pred_setTheory.SING_UNION",
      "pred_setTheory.SING_INSERT", ...]),
    (‚Äú‚àÄs t. s = t ‚áî ‚àÄx. x ‚àà s ‚áî x ‚àà t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      ...]),
    (‚Äú‚àÄs. (‚àÉf. BIJ f ùïå(:num) s) ‚áí countable s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", ...]),
    (‚Äú‚àÄa0 a1 a0' a1'. a0::a1 = a0'::a1' ‚áî a0 = a0' ‚àß a1 = a1'‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", ...]),
    (‚Äú‚àÄs1 s2. BIGINTER (s1 ‚à™ s2) = BIGINTER s1 ‚à© BIGINTER s2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM", ...]),
    (‚Äú‚àÄf s t. s √ó BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Œªn. s √ó f n) t)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", ...]),
    (‚ÄúPMATCH_EQUIV_ROWS v rows1 rows2 ‚áí PMATCH v rows1 = PMATCH v rows2‚Äù,
     ["patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE"]),
    (‚Äú‚àÄl x. SEG 1 (LENGTH l) (SNOC x l) = [x]‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (‚Äú‚àÄs. FINITE s ‚áí countable s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (‚Äú‚àÄl. FINITE (set l)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      ...]),
    (‚Äú‚àÄf x ls. MEM x ls ‚áí f x ‚â§ SUM (MAP f ls)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (‚Äú‚àÄx s. x ‚àà x INSERT s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (‚Äú‚àÄn l. n < LENGTH l ‚áí BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      ...]),
    (‚Äú‚àÄv p g p' g' RES.
          PMATCH_ROW_COND_EX v p g ‚áí
          (‚àÄx. g x ‚áí ((‚àÉx'. p' x' = p x ‚àß g' x') ‚áî RES)) ‚áí
          (PMATCH_ROW_COND_EX v p' g' ‚áî RES)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_AUX_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_def",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_OK",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_REWRITE",
      "patternMatchesTheory.REDUNDANT_ROWS_INFO_TO_PMATCH_EQ",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_ROWS_INFO_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_SUC",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_NIL",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_LT",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_GE",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_0",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_WEAKEN",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FULL_DEF",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FALSE",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_REWRITES",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC_PMATCH_ROW",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_NIL",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_EXTRACT_IS_EXHAUSTIVE",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_CONS",
      "patternMatchesTheory.FST_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.EL2_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL1_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_THMS",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", ...]),
    (‚Äú‚àÄx. ‚àÖ DELETE x = ‚àÖ‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", ...]),
    (‚Äú‚àÄs t. s DIFF t ‚à© s = s DIFF t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", ...]),
    (‚Äú‚àÄn l1 l2. TAKE n (l1 ‚ß∫ l2) = TAKE n l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (‚Äú‚àÄs t u. s ‚à© (t ‚à© u) = s ‚à© t ‚à© u‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (‚Äú‚àÄP. (‚àÄl. LENGTH l = 0 ‚áí P l) ‚áî P []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES", ...]),
    (‚ÄúASSOC $++‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L",
      "combinTheory.MONOID_DISJ_F", "combinTheory.MONOID_CONJ_T",
      "combinTheory.literal_case_FORALL_ELIM",
      "combinTheory.LET_FORALL_ELIM", "combinTheory.K_THM",
      "combinTheory.K_o_THM", "combinTheory.I_THM", "combinTheory.I_o_ID",
      "combinTheory.GEN_literal_case_RATOR",
      "combinTheory.GEN_literal_case_RAND", "combinTheory.GEN_LET_RATOR",
      "combinTheory.GEN_LET_RAND", "combinTheory.FCOMM_ASSOC",
      "combinTheory.FAIL_THM", "combinTheory.C_THM", "combinTheory.C_ABS_L",
      "combinTheory.ASSOC_SYM", "combinTheory.ASSOC_DISJ",
      "combinTheory.ASSOC_CONJ", "combinTheory.APPLY_UPDATE_THM",
      "combinTheory.APPLY_UPDATE_ID", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.UNIQUE_DEF",
      "listTheory.TL_DEF", "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF",
      "listTheory.SUM", "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.OPT_MMAP_def", "listTheory.oHD_def",
      "listTheory.oEL_def", ...]),
    (‚ÄúPMATCH_ROW_REDUNDANT v [] i ‚áî F‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (‚Äú‚àÄZRECSPACE'.
          ZRECSPACE' ind_type$ZBOT ‚àß
          (‚àÄc i r.
               (‚àÄn. ZRECSPACE' (r n)) ‚áí ZRECSPACE' (ind_type$ZCONSTR c i r)) ‚áí
          ‚àÄa0. ZRECSPACE a0 ‚áí ZRECSPACE' a0‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "ind_typeTheory.ZRECSPACE_def", "ind_typeTheory.ZCONSTR",
      "ind_typeTheory.ZBOT", "ind_typeTheory.NUMSUM_DEST",
      "ind_typeTheory.NUMSUM", "ind_typeTheory.NUMPAIR_DEST",
      "ind_typeTheory.NUMPAIR", "ind_typeTheory.INJP", "ind_typeTheory.INJN",
      "ind_typeTheory.INJF", "ind_typeTheory.INJA",
      "ind_typeTheory.ZRECSPACE_rules", "ind_typeTheory.ZCONSTR_ZBOT",
      "ind_typeTheory.NUMSUM_INJ", "ind_typeTheory.NUMPAIR_INJ_LEMMA",
      "ind_typeTheory.NUMPAIR_INJ", "ind_typeTheory.INJP_INJ",
      "ind_typeTheory.INJN_INJ", "ind_typeTheory.INJF_INJ",
      "ind_typeTheory.INJA_INJ", "ind_typeTheory.INJ_INVERSE2",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (‚Äú‚àÄl1 l2.
          LENGTH l1 = LENGTH l2 ‚áí
          ‚àÄx1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "pairTheory.UNCURRY_VAR",
      "pairTheory.SWAP_def", "pairTheory.RPROD_DEF",
      "pairTheory.prod_TY_DEF", "pairTheory.PROD_ALL_def",
      "pairTheory.PAIR_MAP", "pairTheory.pair_CASE_def", "pairTheory.PAIR",
      "pairTheory.LEX_DEF", "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (‚Äú¬¨SHORTLEX R l []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", ...]),
    (‚Äú‚àÄe. ‚àÉfn. fn () = e‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "oneTheory.one_TY_DEF", "oneTheory.one_DEF", "oneTheory.one_Axiom",
      "oneTheory.one_axiom", "oneTheory.one", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", ...]),
    (‚Äú‚àÄl. l ‚â† [] ‚áí FRONT l ‚ß∫ [LAST l] = l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", ...]),
    (‚Äú‚àÄl n. n < LENGTH l ‚áí LAST (DROP n l) = LAST l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", ...]),
    (‚Äú‚àÄn l. n ‚â§ LENGTH l ‚áí ‚àÄx. BUTLASTN n (x::l) = x::BUTLASTN n l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (‚Äú‚àÄf s t. DISJOINT s t ‚áí DISJOINT (PREIMAGE f s) (PREIMAGE f t)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (‚Äú(‚àÉls. P ls) ‚áî ‚àÉn f. P (GENLIST f n)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1", ...]),
    (‚Äúnub [] = []‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.NULL_DEF", "listTheory.nub_def",
      "listTheory.MAP", "listTheory.LUPDATE_def", "listTheory.LRC_def",
      "listTheory.LLEX_def", "listTheory.list_TY_DEF",
      "listTheory.LIST_TO_SET_DEF", "listTheory.list_size_def",
      "listTheory.LIST_LIFT2_def", "listTheory.LIST_IGNORE_BIND_def",
      "listTheory.LIST_GUARD_def", "listTheory.list_case_def",
      "listTheory.LIST_BIND_def", "listTheory.LIST_APPLY_def",
      "listTheory.LENGTH", "listTheory.LEN_DEF", "listTheory.LAST_DEF",
      "listTheory.isPREFIX", "listTheory.INDEX_OF_def",
      "listTheory.INDEX_FIND_def", "listTheory.HD", "listTheory.GENLIST_AUX",
      "listTheory.GENLIST", "listTheory.FRONT_DEF", "listTheory.FOLDR",
      "listTheory.FOLDL", "listTheory.FLAT", "listTheory.FIND_def",
      "listTheory.FILTER", "listTheory.EXISTS_DEF", "listTheory.EVERYi_def",
      "listTheory.EVERY_DEF", "listTheory.EL", "listTheory.DROP_def",
      "listTheory.APPEND", "listTheory.ALL_DISTINCT", "listTheory.ZIP_UNZIP",
      "listTheory.ZIP_MAP", "listTheory.ZIP_GENLIST", "listTheory.ZIP",
      "listTheory.WF_SHORTLEX_same_lengths", "listTheory.WF_SHORTLEX",
      "listTheory.WF_LIST_PRED", "listTheory.UNZIP_ZIP",
      "listTheory.UNZIP_THM", "listTheory.UNZIP_MAP",
      "listTheory.UNION_APPEND", ...]),
    (‚ÄúWF R‚Å∫ ‚áî WF R‚Äù,
     ["relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.SC_DEF", "relationTheory.RTC_def",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.equivalence_def",
      "relationTheory.EQC_DEF", "relationTheory.EMPTY_REL_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.WF_TC",
      "relationTheory.WF_SUBSET", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_irreflexive", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_INDUCTION_THM", "relationTheory.WF_EMPTY_REL",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_EQC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_MONOTONE",
      "relationTheory.TC_lifts_transitive_relations",
      "relationTheory.TC_lifts_monotonicities",
      "relationTheory.TC_lifts_invariants",
      "relationTheory.TC_lifts_equalities",
      "relationTheory.TC_INDUCT_RIGHT1", "relationTheory.TC_INDUCT_LEFT1",
      "relationTheory.TC_INDUCT_ALT_RIGHT",
      "relationTheory.TC_INDUCT_ALT_LEFT", "relationTheory.TC_INDUCT",
      "relationTheory.TC_implies_one_step", "relationTheory.TC_IDEM",
      "relationTheory.TC_CASES2_E", "relationTheory.TC_CASES2",
      "relationTheory.TC_CASES1_E", "relationTheory.TC_CASES1",
      "relationTheory.symmetric_TC", "relationTheory.symmetric_SC_identity",
      "relationTheory.symmetric_RC", "relationTheory.symmetric_EQC",
      "relationTheory.STRONG_EQC_INDUCTION", "relationTheory.SC_SYMMETRIC",
      "relationTheory.SC_MONOTONE", "relationTheory.SC_lifts_monotonicities",
      "relationTheory.SC_lifts_equalities", "relationTheory.SC_IDEM",
      "relationTheory.RTC_TC_RC", "relationTheory.RTC_SINGLE",
      "relationTheory.RTC_strongind", ...]),
    (‚Äú‚àÄn. countable (count n)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE", ...]),
    (‚Äú{x | y = x} = {y}‚Äù,
     ["pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM", ...]),
    (‚Äú‚àÄx l. SNOC x l = l ‚ß∫ [x]‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (‚Äú‚àÄs t. DISJOINT s t ‚áî ‚àÄx. x ‚àà s ‚áí x ‚àâ t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (‚ÄúGENLIST f 0 = [] ‚àß GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (‚Äú‚àÄs x. x ‚äÇ {s} ‚áî x = ‚àÖ‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (‚Äú‚àÄR. symmetric R·µÄ ‚áî symmetric R‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_ON_WFREC",
      "relationTheory.TC_TRANSITIVE", "relationTheory.TC_SUBSET",
      "relationTheory.TC_STRONG_INDUCT_RIGHT1", ...]),
    (‚Äú‚àÄt1 t2. (if F then t1 else t2) = t2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", ...]),
    (‚Äú‚àÄl1 l2. set (l1 ‚ß∫ l2) = set l1 ‚à™ set l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", ...]),
    (‚Äú‚àÄl1 l2. l2 ‚âº l1 ‚áî ‚àÉl. l1 = l2 ‚ß∫ l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (‚Äú‚àÄR. irreflexive R·µÄ ‚áî irreflexive R‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC", ...]),
    (‚Äú‚àÄs. CHOICE s ‚àâ REST s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", ...]),
    (‚Äú‚àÄl1 l2. l1 ‚ß∫ l2 = FOLDL (Œªl' x. SNOC x l') l1 l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", ...]),
    (‚Äú‚àÄL n. LEN L n = LENGTH L + n‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (‚Äú‚àÄx x' y y'. (x ‚áí y' ‚áí y) ‚àß (¬¨y' ‚áí x ‚áí x') ‚áí (x' ‚áí y') ‚áí x ‚áí y‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (‚Äú‚àÄP l. EVERY P l ‚áî ‚àÄe. MEM e l ‚áí P e‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", ...]),
    (‚Äú‚àÄn1 n2. count n1 = count n2 ‚áî n1 = n2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      ...]),
    (‚Äú‚àÄn. 0 < n ‚áí ‚àÄx l. EL n (x::l) = EL (PRE n) l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM", ...]),
    (‚Äú‚àÄe l. LIST_ELEM_COUNT e l > 0 ‚áî MEM e l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (‚Äú‚àÄt. t ‚à® t ‚áî t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (‚Äú(‚àÄx y. f x = f y ‚áî x = y) ‚áí
      (DISJOINT (IMAGE f s1) (IMAGE f s2) ‚áî DISJOINT s1 s2)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM", ...]),
    (‚Äú‚àÄx x' y y'. (y ‚áí x' ‚áí x) ‚àß (x' ‚áí y' ‚áí y) ‚áí x' ‚àß y' ‚áí x ‚àß y‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", ...]),
    (‚Äú‚àÄn. DROP n [] = []‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (‚Äú‚àÄs. s ‚äÇ ùïå(:Œ±) ‚áî ‚àÉx. x ‚àâ s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (‚ÄúQ ($some P) ‚áí (‚àÉx. P x ‚àß Q (SOME x)) ‚à® (‚àÄx. ¬¨P x) ‚àß Q NONE‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.NONE_DEF", "optionTheory.THE_DEF",
      "optionTheory.SOME_SOME_APPLY", "optionTheory.some_intro",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME",
      "optionTheory.OPTREL_refl", "optionTheory.OPTREL_O",
      "optionTheory.OPTREL_MONO", "optionTheory.OPTREL_eq",
      "optionTheory.option_nchotomy", "optionTheory.OPTION_MCOMP_ID",
      "optionTheory.OPTION_MCOMP_ASSOC", "optionTheory.OPTION_MAP_id",
      "optionTheory.OPTION_MAP_EQ_SOME",
      "optionTheory.OPTION_MAP_EQ_NONE_both_ways",
      "optionTheory.OPTION_MAP_EQ_NONE", "optionTheory.OPTION_MAP_CONG",
      "optionTheory.OPTION_MAP_COMPOSE", "optionTheory.OPTION_MAP_CASE", ...]),
    (‚Äútransitive $SUBSET‚Äù,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.WCR_def",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.the_fun_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.STRORD", "relationTheory.StrongOrder",
      "relationTheory.StrongLinearOrder", "relationTheory.SN_def",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", "relationTheory.RRESTRICT_DEF",
      "relationTheory.RRANGE", "relationTheory.RINTER",
      "relationTheory.RESTRICT_DEF", "relationTheory.reflexive_def",
      "relationTheory.RDOM_DELETE_DEF", "relationTheory.RDOM_DEF",
      "relationTheory.RCOMPL", "relationTheory.rcdiamond_def",
      "relationTheory.RC_DEF", "relationTheory.PreOrder",
      "relationTheory.Order", "relationTheory.O_DEF",
      "relationTheory.nf_def", "relationTheory.LinearOrder",
      "relationTheory.irreflexive_def", ...]),
    (‚Äú‚àÄf g s t u. INJ f s t ‚àß INJ g t u ‚áí INJ (g ‚àò f) s u‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L", ...]),
    (‚Äú‚àÄy s f. IMAGE f s y ‚áî ‚àÉx. y = f x ‚àß x ‚àà s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", ...]),
    (‚Äú‚àÄf g s t u. SURJ f s t ‚àß SURJ g t u ‚áí SURJ (g ‚àò f) s u‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC", ...]),
    (‚Äú‚àÄf. INVOL f ‚áí ‚àÄa b. f a = f b ‚áî a = b‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.INVOL_DEF",
      "relationTheory.inv_image_def", "relationTheory.inv_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", ...]),
    (‚Äú‚àÄl1 l2 l3. l1 ‚ß∫ (l2 ‚ß∫ l3) = l1 ‚ß∫ l2 ‚ß∫ l3‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (‚Äú$OLEAST P = NONE ‚áî ‚àÄn. ¬¨P n‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "whileTheory.WHILE",
      "whileTheory.OLEAST_def", "whileTheory.LEAST_DEF",
      "whileTheory.HOARE_SPEC_DEF", "whileTheory.WHILE_RULE",
      "whileTheory.WHILE_INDUCTION", "whileTheory.OLEAST_INTRO",
      "whileTheory.OLEAST_EQNS", "whileTheory.LESS_LEAST",
      "whileTheory.LEAST_T", "whileTheory.LEAST_LESS_EQ",
      "whileTheory.LEAST_INTRO", "whileTheory.LEAST_EXISTS_IMP",
      "whileTheory.LEAST_EXISTS", "whileTheory.LEAST_EQ",
      "whileTheory.LEAST_ELIM", "whileTheory.ITERATION",
      "whileTheory.FULL_LEAST_INTRO", "optionTheory.some_def",
      "optionTheory.SOME_DEF", "optionTheory.OPTREL_def",
      "optionTheory.option_TY_DEF", "optionTheory.option_REP_ABS_DEF",
      "optionTheory.OPTION_MCOMP_def", "optionTheory.OPTION_MAP_DEF",
      "optionTheory.OPTION_MAP2_DEF", "optionTheory.OPTION_IGNORE_BIND_def",
      "optionTheory.OPTION_GUARD_def", "optionTheory.OPTION_CHOICE_def", ...]),
    (‚Äú‚àÄn l1 l2. DROP n (l1 ‚ß∫ l2) = DROP n l1 ‚ß∫ DROP (n ‚àí LENGTH l1) l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", ...]),
    (‚Äú‚àÄls f. EVERY (Œªx. ‚àÉy. x = f y) ls ‚áí ‚àÉl. ls = MAP f l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1", ...]),
    (‚Äú‚àÄopt. (‚àÉx. opt = SOME x) ‚à® opt = NONE‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.OPTION_ALL_def", "optionTheory.NONE_DEF",
      "optionTheory.THE_DEF", "optionTheory.SOME_SOME_APPLY",
      "optionTheory.some_intro", "optionTheory.some_F",
      "optionTheory.some_EQ", "optionTheory.some_elim",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME", ...]),
    (‚ÄúSURJ f s t ‚áí ‚àÉg. INJ g t s ‚àß ‚àÄy. y ‚àà t ‚áí f (g y) = y‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", ...]),
    (‚Äú‚àÄR x y z. RÍô≥ x y ‚àß R y z ‚áí R‚Å∫ x z‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", "relationTheory.irreflexive_def",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.RTC_TRANSITIVE",
      "relationTheory.transitive_RC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_lifts_transitive_relations", ...]),
    (‚Äú‚àÄf s t. INJ f s t ‚àß INFINITE s ‚áí INFINITE t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", ...]),
    (‚Äú‚àÄx1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2 ‚áí LENGTH l1 = LENGTH l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", ...]),
    (‚Äú‚àÄx l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF", ...]),
    (‚Äú‚àÄP n.
          (‚àÄl. LENGTH l = SUC n ‚áí P l) ‚áî
          ‚àÄl. LENGTH l = n ‚áí (Œªl. ‚àÄx. P (x::l)) l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", ...]),
    (‚Äúx ‚àà RDOM (RRESTRICT R s) ‚áî x ‚àà RDOM R ‚àß x ‚àà s‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.STRORD",
      "relationTheory.StrongOrder", "relationTheory.StrongLinearOrder",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", ...]),
    (‚Äú‚àÄx l. FRONT (SNOC x l) = l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", ...]),
    (‚Äú‚àÄl x. MEM x (REVERSE l) ‚áî MEM x l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF", ...]),
    (‚Äú‚àÄl. NULL l ‚áî FOLDL (Œªx l'. F) T l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", ...]),
    (‚Äú‚àÄl m x. MEM x (DROP m l) ‚áí MEM x l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF", ...]),
    (‚Äú‚àÄx. ISR x ‚áí INR (OUTR x) = x‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "sumTheory.sum_TY_DEF", "sumTheory.sum_ISO_DEF", "sumTheory.OUTR",
      "sumTheory.OUTL", "sumTheory.ISR", "sumTheory.ISL",
      "sumTheory.IS_SUM_REP", "sumTheory.INR_DEF", "sumTheory.INL_DEF",
      "sumTheory.sum_INDUCT", "sumTheory.sum_distinct1",
      "sumTheory.sum_distinct", "sumTheory.sum_CASES", "sumTheory.sum_Axiom",
      ...]),
    (‚Äú[f] <*> l = MAP f l‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SET_TO_LIST_primitive_def", "listTheory.REVERSE_DEF",
      "listTheory.REV_DEF", "listTheory.PAD_RIGHT", "listTheory.PAD_LEFT",
      ...]),
    (‚Äú‚àÄn x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", ...]),
    (‚Äú‚àÄs x y. x INSERT s = {y} ‚áî x = y ‚àß s ‚äÜ {y}‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      ...]),
    (‚Äú‚àÄn l1 l2. l1 ‚âº l2 ‚àß n < LENGTH l1 ‚àß n < LENGTH l2 ‚áí EL n l1 = EL n l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", ...]),
    (‚Äú‚àÄR. reflexive (RC R)‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", ...]),
    (‚ÄúR1 ‚àò·µ£ R2 ‚àò·µ£ R3 = (R1 ‚àò·µ£ R2) ‚àò·µ£ R3‚Äù,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF", ...]),
    (‚Äú‚àÄn. 0 < n ‚áí ‚àÄx l. ELL n (SNOC x l) = ELL (PRE n) l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", ...]),
    (‚Äú‚àÄl1 l2.
          ALL_DISTINCT (l1 ‚ß∫ l2) ‚áî
          ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄe. MEM e l1 ‚áí ¬¨MEM e l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (‚Äú‚àÄl. l ‚â† [] ‚áí BUTLASTN 1 l = FRONT l‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", ...]),
    (‚Äú‚àÄs t. BIGUNION {s; t} = s ‚à™ t‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF", ...]),
    (‚Äú‚àÄl2 l1. ¬¨NULL l2 ‚áí EL (LENGTH l1) (l1 ‚ß∫ l2) = HD l2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", ...]),
    (‚Äúreflexive (R1 LEX R2) ‚áî reflexive R1 ‚à® reflexive R2‚Äù,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def", ...]),
    (‚ÄúINJ f s (IMAGE f s) ‚áí (countable (IMAGE f s) ‚áî countable s)‚Äù,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", ...]),
    (‚ÄúMAP f (LIST_BIND l g) = LIST_BIND l (MAP f ‚àò g)‚Äù,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF", ...]),
    (‚ÄúFUNSET ùïå(:Œ±) ùïå(:Œ≤) = ùïå(:Œ± -> Œ≤)‚Äù, ["pred_setTheory.UNIV_DEF", ...]),
    (‚Äú‚àÄA B C. A ‚àß B ‚áí C ‚áî A ‚áí B ‚áí C‚Äù, [...]), ...]: (term * string list) list
> # # # # # # # # # ** types trace now on
> run_hh_pb_better [holyHammer.Vampire] 256 128;
poly: : error: Type error in function application.
   Function: run_hh_pb_better :
      (term * string list) list -> prover list -> int -> int -> tactic
   Argument: [holyHammer.Vampire] : prover list
   Reason: Can't unify prover to term * string list (Incompatible types)
Found near run_hh_pb_better [holyHammer.Vampire] 256 128
poly: : error: Type error in function application.
   Function: run_hh_pb_better [holyHammer.Vampire] :
      prover list -> int -> int -> tactic
   Argument: 256 : int
   Reason:
      Can't unify int (*In Basis*) with prover list (*In Basis*)
         (Different type constructors)
Found near run_hh_pb_better [holyHammer.Vampire] 256 128
Static Errors
> run_hh_pb_better data[holyHammer.Vampire] 256 128;
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). t ‚äÜ s ‚áí s DIFF (s DIFF t) = t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). t ‚äÜ s ‚áí s DIFF (s DIFF t) = t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(set :Œ± -> bool) (e :Œ± -> bool). e ‚àà POW set ‚áî e ‚äÜ set
proof failed.
Failed theorem:
‚àÄ(set :Œ± -> bool) (e :Œ± -> bool). e ‚àà POW set ‚áî e ‚äÜ set
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FINITE ùïå(:Œ± # Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)
proof failed.
Failed theorem:
FINITE ùïå(:Œ± # Œ≤) ‚áî FINITE ùïå(:Œ±) ‚àß FINITE ùïå(:Œ≤)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool).
    FINITE s ‚àß BIJ f s t ‚áí CARD s = CARD t
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool).
    FINITE s ‚àß BIJ f s t ‚áí CARD s = CARD t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
{x | T} = ùïå(:Œ±)
proof failed.
Failed theorem:
{x | T} = ùïå(:Œ±)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
COMPL (‚àÖ :Œ± -> bool) = ùïå(:Œ±)
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.COMPL_CLAUSES , pred_setTheory.COMPL_COMPL , pred_setTheory.INTER_UNIV]
minimized proof:
  metis_tac [pred_setTheory.COMPL_CLAUSES, pred_setTheory.COMPL_COMPL, pred_setTheory.INTER_UNIV]
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). s = t ‚áî ‚àÄ(x :Œ±). x ‚àà s ‚áî x ‚àà t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). s = t ‚áî ‚àÄ(x :Œ±). x ‚àà s ‚áî x ‚àà t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). (‚àÉ(f :num -> Œ±). BIJ f ùïå(:num) s) ‚áí countable s
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool). (‚àÉ(f :num -> Œ±). BIJ f ùïå(:num) s) ‚áí countable s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(a0 :Œ±) (a1 :Œ± list) (a0' :Œ±) (a1' :Œ± list).
    a0::a1 = a0'::a1' ‚áî a0 = a0' ‚àß a1 = a1'
proof found by vampire:
  metisTools.METIS_TAC [listTheory.HD , listTheory.TL]
minimized proof:
  metis_tac [listTheory.HD, listTheory.TL]
‚àÄ(s1 :(Œ± -> bool) -> bool) (s2 :(Œ± -> bool) -> bool).
    BIGINTER (s1 ‚à™ s2) = BIGINTER s1 ‚à© BIGINTER s2
proof failed.
Failed theorem:
‚àÄ(s1 :(Œ± -> bool) -> bool) (s2 :(Œ± -> bool) -> bool).
    BIGINTER (s1 ‚à™ s2) = BIGINTER s1 ‚à© BIGINTER s2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤ -> bool) (s :Œ≥ -> bool) (t :Œ± -> bool).
    s √ó BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Œª(n :Œ±). s √ó f n) t)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤ -> bool) (s :Œ≥ -> bool) (t :Œ± -> bool).
    s √ó BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Œª(n :Œ±). s √ó f n) t)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_EQUIV_ROWS (v :Œ±) (rows1 :(Œ± -> Œ≤ option) list)
  (rows2 :(Œ± -> Œ≤ option) list) ‚áí
PMATCH v rows1 = PMATCH v rows2
proof failed.
Failed theorem:
PMATCH_EQUIV_ROWS (v :Œ±) (rows1 :(Œ± -> Œ≤ option) list)
  (rows2 :(Œ± -> Œ≤ option) list) ‚áí
PMATCH v rows1 = PMATCH v rows2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list) (x :Œ±). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]
proof failed.
Failed theorem:
‚àÄ(l :Œ± list) (x :Œ±). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). FINITE s ‚áí countable s
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool). FINITE s ‚áí countable s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list). FINITE (set l)
proof failed.
Failed theorem:
‚àÄ(l :Œ± list). FINITE (set l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> num) (x :Œ±) (ls :Œ± list). MEM x ls ‚áí f x ‚â§ SUM (MAP f ls)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> num) (x :Œ±) (ls :Œ± list). MEM x ls ‚áí f x ‚â§ SUM (MAP f ls)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (s :Œ± -> bool). x ‚àà x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.INSERT_applied]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.INSERT_applied]
‚àÄ(n :num) (l :Œ± list).
    n < LENGTH l ‚áí BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list).
    n < LENGTH l ‚áí BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(v :Œ±) (p :Œ≤ -> Œ±) (g :Œ≤ -> bool) (p' :Œ≥ -> Œ±) (g' :Œ≥ -> bool) (RES :bool).
    PMATCH_ROW_COND_EX v p g ‚áí
    (‚àÄ(x :Œ≤). g x ‚áí ((‚àÉ(x' :Œ≥). p' x' = p x ‚àß g' x') ‚áî RES)) ‚áí
    (PMATCH_ROW_COND_EX v p' g' ‚áî RES)
proof failed.
Failed theorem:
‚àÄ(v :Œ±) (p :Œ≤ -> Œ±) (g :Œ≤ -> bool) (p' :Œ≥ -> Œ±) (g' :Œ≥ -> bool) (RES :bool).
    PMATCH_ROW_COND_EX v p g ‚áí
    (‚àÄ(x :Œ≤). g x ‚áí ((‚àÉ(x' :Œ≥). p' x' = p x ‚àß g' x') ‚áî RES)) ‚áí
    (PMATCH_ROW_COND_EX v p' g' ‚áî RES)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±). (‚àÖ :Œ± -> bool) DELETE x = (‚àÖ :Œ± -> bool)
proof failed.
Failed theorem:
‚àÄ(x :Œ±). (‚àÖ :Œ± -> bool) DELETE x = (‚àÖ :Œ± -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). s DIFF t ‚à© s = s DIFF t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). s DIFF t ‚à© s = s DIFF t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l1 :Œ± list) (l2 :Œ± list).
    TAKE n (l1 ‚ß∫ l2) = TAKE n l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2
proof failed.
Failed theorem:
‚àÄ(n :num) (l1 :Œ± list) (l2 :Œ± list).
    TAKE n (l1 ‚ß∫ l2) = TAKE n l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (u :Œ± -> bool). s ‚à© (t ‚à© u) = s ‚à© t ‚à© u
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (u :Œ± -> bool). s ‚à© (t ‚à© u) = s ‚à© t ‚à© u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± list -> bool).
    (‚àÄ(l :Œ± list). LENGTH l = (0 :num) ‚áí P l) ‚áî P ([] :Œ± list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH , listTheory.NULL_EQ , listTheory.NULL_LENGTH]
minimized proof:
  metis_tac [listTheory.NULL_EQ, listTheory.NULL_LENGTH]
ASSOC ($++ :Œ± list -> Œ± list -> Œ± list)
proof failed.
Failed theorem:
ASSOC ($++ :Œ± list -> Œ± list -> Œ± list)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_REDUNDANT (v :Œ±) ([] :(Œ± -> Œ≤ option) list) (i :num) ‚áî F
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT (v :Œ±) ([] :(Œ± -> Œ≤ option) list) (i :num) ‚áî F
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(ZRECSPACE' :(num -> Œ± -> bool) -> bool).
    ZRECSPACE' (ind_type$ZBOT :num -> Œ± -> bool) ‚àß
    (‚àÄ(c :num) (i :Œ±) (r :num -> num -> Œ± -> bool).
         (‚àÄ(n :num). ZRECSPACE' (r n)) ‚áí ZRECSPACE' (ind_type$ZCONSTR c i r)) ‚áí
    ‚àÄ(a0 :num -> Œ± -> bool). ZRECSPACE a0 ‚áí ZRECSPACE' a0
proof failed.
Failed theorem:
‚àÄ(ZRECSPACE' :(num -> Œ± -> bool) -> bool).
    ZRECSPACE' (ind_type$ZBOT :num -> Œ± -> bool) ‚àß
    (‚àÄ(c :num) (i :Œ±) (r :num -> num -> Œ± -> bool).
         (‚àÄ(n :num). ZRECSPACE' (r n)) ‚áí ZRECSPACE' (ind_type$ZCONSTR c i r)) ‚áí
    ‚àÄ(a0 :num -> Œ± -> bool). ZRECSPACE a0 ‚áí ZRECSPACE' a0
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ≤ list).
    LENGTH l1 = LENGTH l2 ‚áí
    ‚àÄ(x1 :Œ±) (x2 :Œ≤).
        ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ≤ list).
    LENGTH l1 = LENGTH l2 ‚áí
    ‚àÄ(x1 :Œ±) (x2 :Œ≤).
        ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
¬¨SHORTLEX (R :Œ± -> Œ± -> bool) (l :Œ± list) ([] :Œ± list)
proof failed.
Failed theorem:
¬¨SHORTLEX (R :Œ± -> Œ± -> bool) (l :Œ± list) ([] :Œ± list)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(e :Œ±). ‚àÉ(fn :unit -> Œ±). fn () = e
proof found by vampire:
  metisTools.METIS_TAC []
proof failed.
Failed theorem:
‚àÄ(e :Œ±). ‚àÉ(fn :unit -> Œ±). fn () = e
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list). l ‚â† ([] :Œ± list) ‚áí FRONT l ‚ß∫ [LAST l] = l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list). l ‚â† ([] :Œ± list) ‚áí FRONT l ‚ß∫ [LAST l] = l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list) (n :num). n < LENGTH l ‚áí LAST (DROP n l) = LAST l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list) (n :num). n < LENGTH l ‚áí LAST (DROP n l) = LAST l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list).
    n ‚â§ LENGTH l ‚áí ‚àÄ(x :Œ±). BUTLASTN n (x::l) = x::BUTLASTN n l
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list).
    n ‚â§ LENGTH l ‚áí ‚àÄ(x :Œ±). BUTLASTN n (x::l) = x::BUTLASTN n l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool) (t :Œ≤ -> bool).
    DISJOINT s t ‚áí DISJOINT (PREIMAGE f s) (PREIMAGE f t)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool) (t :Œ≤ -> bool).
    DISJOINT s t ‚áí DISJOINT (PREIMAGE f s) (PREIMAGE f t)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÉ(ls :Œ± list). (P :Œ± list -> bool) ls) ‚áî
‚àÉ(n :num) (f :num -> Œ±). P (GENLIST f n)
proof failed.
Failed theorem:
(‚àÉ(ls :Œ± list). (P :Œ± list -> bool) ls) ‚áî
‚àÉ(n :num) (f :num -> Œ±). P (GENLIST f n)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
nub ([] :Œ± list) = ([] :Œ± list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.nub_def]
minimized proof:
  metis_tac [listTheory.nub_def]
WF (R :Œ± -> Œ± -> bool)‚Å∫ ‚áî WF R
proof failed.
Failed theorem:
WF (R :Œ± -> Œ± -> bool)‚Å∫ ‚áî WF R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num). countable (count n)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.COUNTABLE_ALT]
proof failed.
Failed theorem:
‚àÄ(n :num). countable (count n)
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
{x | (y :Œ±) = x} = {y}
proof failed.
Failed theorem:
{x | (y :Œ±) = x} = {y}
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (l :Œ± list). SNOC x l = l ‚ß∫ [x]
proof failed.
Failed theorem:
‚àÄ(x :Œ±) (l :Œ± list). SNOC x l = l ‚ß∫ [x]
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). DISJOINT s t ‚áî ‚àÄ(x :Œ±). x ‚àà s ‚áí x ‚àâ t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). DISJOINT s t ‚áî ‚àÄ(x :Œ±). x ‚àà s ‚áí x ‚àâ t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
GENLIST (f :num -> Œ±) (0 :num) = ([] :Œ± list) ‚àß
GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :Œ± list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.GENLIST , listTheory.GENLIST_GENLIST_AUX]
minimized proof:
  metis_tac [listTheory.GENLIST, listTheory.GENLIST_GENLIST_AUX]
‚àÄ(s :Œ±) (x :Œ± -> bool). x ‚äÇ {s} ‚áî x = (‚àÖ :Œ± -> bool)
proof failed.
Failed theorem:
‚àÄ(s :Œ±) (x :Œ± -> bool). x ‚äÇ {s} ‚áî x = (‚àÖ :Œ± -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ± -> bool). symmetric R·µÄ ‚áî symmetric R
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool). symmetric R·µÄ ‚áî symmetric R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(t1 :Œ±) (t2 :Œ±). (if F then t1 else t2) = t2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.bool_case_thm]
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list). set (l1 ‚ß∫ l2) = set l1 ‚à™ set l2
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list). set (l1 ‚ß∫ l2) = set l1 ‚à™ set l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list). l2 ‚âº l1 ‚áî ‚àÉ(l :Œ± list). l1 = l2 ‚ß∫ l
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list). l2 ‚âº l1 ‚áî ‚àÉ(l :Œ± list). l1 = l2 ‚ß∫ l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ± -> bool). irreflexive R·µÄ ‚áî irreflexive R
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool). irreflexive R·µÄ ‚áî irreflexive R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). CHOICE s ‚àâ REST s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.REST_applied]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.REST_applied]
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    l1 ‚ß∫ l2 = FOLDL (Œª(l' :Œ± list) (x :Œ±). SNOC x l') l1 l2
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    l1 ‚ß∫ l2 = FOLDL (Œª(l' :Œ± list) (x :Œ±). SNOC x l') l1 l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(L :Œ± list) (n :num). LEN L n = LENGTH L + n
proof failed.
Failed theorem:
‚àÄ(L :Œ± list) (n :num). LEN L n = LENGTH L + n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :bool) (x' :bool) (y :bool) (y' :bool).
    (x ‚áí y' ‚áí y) ‚àß (¬¨y' ‚áí x ‚áí x') ‚áí (x' ‚áí y') ‚áí x ‚áí y
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± -> bool) (l :Œ± list). EVERY P l ‚áî ‚àÄ(e :Œ±). MEM e l ‚áí P e
proof failed.
Failed theorem:
‚àÄ(P :Œ± -> bool) (l :Œ± list). EVERY P l ‚áî ‚àÄ(e :Œ±). MEM e l ‚áí P e
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n1 :num) (n2 :num). count n1 = count n2 ‚áî n1 = n2
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.CARD_COUNT]
minimized proof:
  metis_tac [pred_setTheory.CARD_COUNT]
‚àÄ(n :num). (0 :num) < n ‚áí ‚àÄ(x :Œ±) (l :Œ± list). EL n (x::l) = EL (PRE n) l
proof failed.
Failed theorem:
‚àÄ(n :num). (0 :num) < n ‚áí ‚àÄ(x :Œ±) (l :Œ± list). EL n (x::l) = EL (PRE n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(e :Œ±) (l :Œ± list). LIST_ELEM_COUNT e l > (0 :num) ‚áî MEM e l
proof failed.
Failed theorem:
‚àÄ(e :Œ±) (l :Œ± list). LIST_ELEM_COUNT e l > (0 :num) ‚áî MEM e l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(t :bool). t ‚à® t ‚áî t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(x :Œ±) (y :Œ±). (f :Œ± -> Œ≤) x = f y ‚áî x = y) ‚áí
(DISJOINT (IMAGE f (s1 :Œ± -> bool)) (IMAGE f (s2 :Œ± -> bool)) ‚áî
 DISJOINT s1 s2)
proof failed.
Failed theorem:
(‚àÄ(x :Œ±) (y :Œ±). (f :Œ± -> Œ≤) x = f y ‚áî x = y) ‚áí
(DISJOINT (IMAGE f (s1 :Œ± -> bool)) (IMAGE f (s2 :Œ± -> bool)) ‚áî
 DISJOINT s1 s2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :bool) (x' :bool) (y :bool) (y' :bool).
    (y ‚áí x' ‚áí x) ‚àß (x' ‚áí y' ‚áí y) ‚áí x' ‚àß y' ‚áí x ‚àß y
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num). DROP n ([] :Œ± list) = ([] :Œ± list)
proof failed.
Failed theorem:
‚àÄ(n :num). DROP n ([] :Œ± list) = ([] :Œ± list)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). s ‚äÇ ùïå(:Œ±) ‚áî ‚àÉ(x :Œ±). x ‚àâ s
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool). s ‚äÇ ùïå(:Œ±) ‚áî ‚àÉ(x :Œ±). x ‚àâ s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(Q :Œ± option -> bool) ($some (P :Œ± -> bool)) ‚áí
(‚àÉ(x :Œ±). P x ‚àß Q (SOME x)) ‚à® (‚àÄ(x :Œ±). ¬¨P x) ‚àß Q (NONE :Œ± option)
proof failed.
Failed theorem:
(Q :Œ± option -> bool) ($some (P :Œ± -> bool)) ‚áí
(‚àÉ(x :Œ±). P x ‚àß Q (SOME x)) ‚à® (‚àÄ(x :Œ±). ¬¨P x) ‚àß Q (NONE :Œ± option)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
transitive ($SUBSET :(Œ± -> bool) -> (Œ± -> bool) -> bool)
proof failed.
Failed theorem:
transitive ($SUBSET :(Œ± -> bool) -> (Œ± -> bool) -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (g :Œ≤ -> Œ≥) (s :Œ± -> bool) (t :Œ≤ -> bool) (u :Œ≥ -> bool).
    INJ f s t ‚àß INJ g t u ‚áí INJ (g ‚àò f) s u
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (g :Œ≤ -> Œ≥) (s :Œ± -> bool) (t :Œ≤ -> bool) (u :Œ≥ -> bool).
    INJ f s t ‚àß INJ g t u ‚áí INJ (g ‚àò f) s u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(y :Œ≤) (s :Œ± -> bool) (f :Œ± -> Œ≤). IMAGE f s y ‚áî ‚àÉ(x :Œ±). y = f x ‚àß x ‚àà s
proof failed.
Failed theorem:
‚àÄ(y :Œ≤) (s :Œ± -> bool) (f :Œ± -> Œ≤). IMAGE f s y ‚áî ‚àÉ(x :Œ±). y = f x ‚àß x ‚àà s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (g :Œ≤ -> Œ≥) (s :Œ± -> bool) (t :Œ≤ -> bool) (u :Œ≥ -> bool).
    SURJ f s t ‚àß SURJ g t u ‚áí SURJ (g ‚àò f) s u
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (g :Œ≤ -> Œ≥) (s :Œ± -> bool) (t :Œ≤ -> bool) (u :Œ≥ -> bool).
    SURJ f s t ‚àß SURJ g t u ‚áí SURJ (g ‚àò f) s u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :'z -> 'z). INVOL f ‚áí ‚àÄ(a :'z) (b :'z). f a = f b ‚áî a = b
proof failed.
Failed theorem:
‚àÄ(f :'z -> 'z). INVOL f ‚áí ‚àÄ(a :'z) (b :'z). f a = f b ‚áî a = b
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list) (l3 :Œ± list). l1 ‚ß∫ (l2 ‚ß∫ l3) = l1 ‚ß∫ l2 ‚ß∫ l3
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list) (l3 :Œ± list). l1 ‚ß∫ (l2 ‚ß∫ l3) = l1 ‚ß∫ l2 ‚ß∫ l3
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
$OLEAST (P :num -> bool) = (NONE :num option) ‚áî ‚àÄ(n :num). ¬¨P n
proof failed.
Failed theorem:
$OLEAST (P :num -> bool) = (NONE :num option) ‚áî ‚àÄ(n :num). ¬¨P n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l1 :Œ± list) (l2 :Œ± list).
    DROP n (l1 ‚ß∫ l2) = DROP n l1 ‚ß∫ DROP (n ‚àí LENGTH l1) l2
proof failed.
Failed theorem:
‚àÄ(n :num) (l1 :Œ± list) (l2 :Œ± list).
    DROP n (l1 ‚ß∫ l2) = DROP n l1 ‚ß∫ DROP (n ‚àí LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(ls :Œ± list) (f :Œ≤ -> Œ±).
    EVERY (Œª(x :Œ±). ‚àÉ(y :Œ≤). x = f y) ls ‚áí ‚àÉ(l :Œ≤ list). ls = MAP f l
proof failed.
Failed theorem:
‚àÄ(ls :Œ± list) (f :Œ≤ -> Œ±).
    EVERY (Œª(x :Œ±). ‚àÉ(y :Œ≤). x = f y) ls ‚áí ‚àÉ(l :Œ≤ list). ls = MAP f l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(opt :Œ± option). (‚àÉ(x :Œ±). opt = SOME x) ‚à® opt = (NONE :Œ± option)
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.option_nchotomy]
minimized proof:
  metis_tac [optionTheory.option_nchotomy]
SURJ (f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool) ‚áí
‚àÉ(g :Œ≤ -> Œ±). INJ g t s ‚àß ‚àÄ(y :Œ≤). y ‚àà t ‚áí f (g y) = y
proof failed.
Failed theorem:
SURJ (f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool) ‚áí
‚àÉ(g :Œ≤ -> Œ±). INJ g t s ‚àß ‚àÄ(y :Œ≤). y ‚àà t ‚áí f (g y) = y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ± -> bool) (x :Œ±) (y :Œ±) (z :Œ±). RÍô≥ x y ‚àß R y z ‚áí R‚Å∫ x z
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool) (x :Œ±) (y :Œ±) (z :Œ±). RÍô≥ x y ‚àß R y z ‚áí R‚Å∫ x z
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool).
    INJ f s t ‚àß INFINITE s ‚áí INFINITE t
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool).
    INJ f s t ‚àß INFINITE s ‚áí INFINITE t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x1 :Œ±) (l1 :Œ± list) (x2 :Œ±) (l2 :Œ± list).
    SNOC x1 l1 = SNOC x2 l2 ‚áí LENGTH l1 = LENGTH l2
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FRONT_SNOC]
minimized proof:
  metis_tac [listTheory.FRONT_SNOC]
‚àÄ(x :Œ±) (l :Œ± list).
    TL (SNOC x l) = if NULL l then ([] :Œ± list) else SNOC x (TL l)
proof failed.
Failed theorem:
‚àÄ(x :Œ±) (l :Œ± list).
    TL (SNOC x l) = if NULL l then ([] :Œ± list) else SNOC x (TL l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± list -> bool) (n :num).
    (‚àÄ(l :Œ± list). LENGTH l = SUC n ‚áí P l) ‚áî
    ‚àÄ(l :Œ± list). LENGTH l = n ‚áí (Œª(l :Œ± list). ‚àÄ(x :Œ±). P (x::l)) l
proof failed.
Failed theorem:
‚àÄ(P :Œ± list -> bool) (n :num).
    (‚àÄ(l :Œ± list). LENGTH l = SUC n ‚áí P l) ‚áî
    ‚àÄ(l :Œ± list). LENGTH l = n ‚áí (Œª(l :Œ± list). ‚àÄ(x :Œ±). P (x::l)) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(x :Œ±) ‚àà RDOM (RRESTRICT (R :Œ± -> Œ≤ -> bool) (s :Œ± -> bool)) ‚áî
x ‚àà RDOM R ‚àß x ‚àà s
proof failed.
Failed theorem:
(x :Œ±) ‚àà RDOM (RRESTRICT (R :Œ± -> Œ≤ -> bool) (s :Œ± -> bool)) ‚áî
x ‚àà RDOM R ‚àß x ‚àà s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (l :Œ± list). FRONT (SNOC x l) = l
proof failed.
Failed theorem:
‚àÄ(x :Œ±) (l :Œ± list). FRONT (SNOC x l) = l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list) (x :Œ±). MEM x (REVERSE l) ‚áî MEM x l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list) (x :Œ±). MEM x (REVERSE l) ‚áî MEM x l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list). NULL l ‚áî FOLDL (Œª(x :bool) (l' :Œ±). F) T l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list). NULL l ‚áî FOLDL (Œª(x :bool) (l' :Œ±). F) T l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list) (m :num) (x :Œ±). MEM x (DROP m l) ‚áí MEM x l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list) (m :num) (x :Œ±). MEM x (DROP m l) ‚áí MEM x l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ± + Œ≤). ISR x ‚áí (INR (OUTR x) :Œ± + Œ≤) = x
proof failed.
Failed theorem:
‚àÄ(x :Œ± + Œ≤). ISR x ‚áí (INR (OUTR x) :Œ± + Œ≤) = x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(([(f :Œ≤ -> Œ±)] <*> (l :Œ≤ list)) :Œ± list) = MAP f l
proof failed.
Failed theorem:
(([(f :Œ≤ -> Œ±)] <*> (l :Œ≤ list)) :Œ± list) = MAP f l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (x :Œ±). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
proof failed.
Failed theorem:
‚àÄ(n :num) (x :Œ±). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (x :Œ±) (y :Œ±). x INSERT s = {y} ‚áî x = y ‚àß s ‚äÜ {y}
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (x :Œ±) (y :Œ±). x INSERT s = {y} ‚áî x = y ‚àß s ‚äÜ {y}
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l1 :Œ± list) (l2 :Œ± list).
    l1 ‚âº l2 ‚àß n < LENGTH l1 ‚àß n < LENGTH l2 ‚áí EL n l1 = EL n l2
proof failed.
Failed theorem:
‚àÄ(n :num) (l1 :Œ± list) (l2 :Œ± list).
    l1 ‚âº l2 ‚àß n < LENGTH l1 ‚àß n < LENGTH l2 ‚áí EL n l1 = EL n l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ± -> bool). reflexive (RC R)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , relationTheory.RC_DEF , relationTheory.reflexive_def]
minimized proof:
  metis_tac [relationTheory.RC_DEF, relationTheory.reflexive_def]
(R1 :Œ≥ -> Œ≤ -> bool) ‚àò·µ£ (R2 :Œ¥ -> Œ≥ -> bool) ‚àò·µ£ (R3 :Œ± -> Œ¥ -> bool) =
(R1 ‚àò·µ£ R2) ‚àò·µ£ R3
proof failed.
Failed theorem:
(R1 :Œ≥ -> Œ≤ -> bool) ‚àò·µ£ (R2 :Œ¥ -> Œ≥ -> bool) ‚àò·µ£ (R3 :Œ± -> Œ¥ -> bool) =
(R1 ‚àò·µ£ R2) ‚àò·µ£ R3
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num).
    (0 :num) < n ‚áí ‚àÄ(x :Œ±) (l :Œ± list). ELL n (SNOC x l) = ELL (PRE n) l
proof failed.
Failed theorem:
‚àÄ(n :num).
    (0 :num) < n ‚áí ‚àÄ(x :Œ±) (l :Œ± list). ELL n (SNOC x l) = ELL (PRE n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    ALL_DISTINCT (l1 ‚ß∫ l2) ‚áî
    ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄ(e :Œ±). MEM e l1 ‚áí ¬¨MEM e l2
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    ALL_DISTINCT (l1 ‚ß∫ l2) ‚áî
    ALL_DISTINCT l1 ‚àß ALL_DISTINCT l2 ‚àß ‚àÄ(e :Œ±). MEM e l1 ‚áí ¬¨MEM e l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list). l ‚â† ([] :Œ± list) ‚áí BUTLASTN (1 :num) l = FRONT l
proof found by vampire:
  metisTools.METIS_TAC [arithmeticTheory.ONE , listTheory.APPEND_FRONT_LAST , listTheory.LENGTH , rich_listTheory.BUTLASTN_LENGTH_APPEND]
minimized proof:
  metis_tac [arithmeticTheory.ONE, listTheory.APPEND_FRONT_LAST, listTheory.LENGTH, rich_listTheory.BUTLASTN_LENGTH_APPEND]
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). BIGUNION {s; t} = s ‚à™ t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). BIGUNION {s; t} = s ‚à™ t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l2 :Œ± list) (l1 :Œ± list). ¬¨NULL l2 ‚áí EL (LENGTH l1) (l1 ‚ß∫ l2) = HD l2
proof failed.
Failed theorem:
‚àÄ(l2 :Œ± list) (l1 :Œ± list). ¬¨NULL l2 ‚áí EL (LENGTH l1) (l1 ‚ß∫ l2) = HD l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
reflexive ((R1 :Œ± -> Œ± -> bool) LEX (R2 :Œ≤ -> Œ≤ -> bool)) ‚áî
reflexive R1 ‚à® reflexive R2
proof failed.
Failed theorem:
reflexive ((R1 :Œ± -> Œ± -> bool) LEX (R2 :Œ≤ -> Œ≤ -> bool)) ‚áî
reflexive R1 ‚à® reflexive R2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INJ (f :Œ± -> Œ≤) (s :Œ± -> bool) (IMAGE f s) ‚áí
(countable (IMAGE f s) ‚áî countable s)
proof failed.
Failed theorem:
INJ (f :Œ± -> Œ≤) (s :Œ± -> bool) (IMAGE f s) ‚áí
(countable (IMAGE f s) ‚áî countable s)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP (f :Œ≤ -> Œ±) (LIST_BIND (l :Œ≥ list) (g :Œ≥ -> Œ≤ list)) =
LIST_BIND l (MAP f ‚àò g)
proof failed.
Failed theorem:
MAP (f :Œ≤ -> Œ±) (LIST_BIND (l :Œ≥ list) (g :Œ≥ -> Œ≤ list)) =
LIST_BIND l (MAP f ‚àò g)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FUNSET ùïå(:Œ±) ùïå(:Œ≤) = ùïå(:Œ± -> Œ≤)
proof failed.
Failed theorem:
FUNSET ùïå(:Œ±) ùïå(:Œ≤) = ùïå(:Œ± -> Œ≤)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(A :bool) (B :bool) (C :bool). A ‚àß B ‚áí C ‚áî A ‚áí B ‚áí C
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP (SND :Œ≤ # Œ± -> Œ±)
  (FILTER (Œª((x :Œ≤),(y :Œ±)). y ‚â† (z :Œ±)) (ls :(Œ≤ # Œ±) list)) =
FILTER (Œª(y :Œ±). z ‚â† y) (MAP (SND :Œ≤ # Œ± -> Œ±) ls)
proof failed.
Failed theorem:
MAP (SND :Œ≤ # Œ± -> Œ±)
  (FILTER (Œª((x :Œ≤),(y :Œ±)). y ‚â† (z :Œ±)) (ls :(Œ≤ # Œ±) list)) =
FILTER (Œª(y :Œ±). z ‚â† y) (MAP (SND :Œ≤ # Œ± -> Œ±) ls)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REPLICATE (n :num) (a :Œ±) ‚ß∫ REPLICATE (m :num) a = REPLICATE (n + m) a
proof failed.
Failed theorem:
REPLICATE (n :num) (a :Œ±) ‚ß∫ REPLICATE (m :num) a = REPLICATE (n + m) a
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(b :bool). ¬¨b ‚áí (b ‚áî F)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (y :Œ≤) (a :Œ±) (b :Œ≤). (x,y) = (a,b) ‚áî x = a ‚àß y = b
proof found by vampire:
  metisTools.METIS_TAC [pairTheory.PAIR_EQ]
minimized proof:
  metis_tac [pairTheory.PAIR_EQ]
‚àÄ(f :Œ± -> Œ≤) (n :num) (x :Œ±). MAP f (REPLICATE n x) = REPLICATE n (f x)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (n :num) (x :Œ±). MAP f (REPLICATE n x) = REPLICATE n (f x)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list).
    n < LENGTH l ‚áí SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list).
    n < LENGTH l ‚áí SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_COND_EX (i :Œ±) (p :Œ≤ -> Œ±) (g :Œ≤ -> bool) ‚áí
PMATCH_ROW p g (r :Œ≤ -> Œ≥) i = SOME (r (@(x :Œ≤). PMATCH_ROW_COND p g i x))
proof failed.
Failed theorem:
PMATCH_ROW_COND_EX (i :Œ±) (p :Œ≤ -> Œ±) (g :Œ≤ -> bool) ‚áí
PMATCH_ROW p g (r :Œ≤ -> Œ≥) i = SOME (r (@(x :Œ≤). PMATCH_ROW_COND p g i x))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R1 :Œ± -> Œ± -> bool) (R2 :Œ± -> Œ± -> bool) (x :Œ±) (y :Œ±).
    (R1 ‚à©·µ£ R2)Íô≥ x y ‚áí (R1Íô≥ ‚à©·µ£ R2Íô≥) x y
proof failed.
Failed theorem:
‚àÄ(R1 :Œ± -> Œ± -> bool) (R2 :Œ± -> Œ± -> bool) (x :Œ±) (y :Œ±).
    (R1 ‚à©·µ£ R2)Íô≥ x y ‚áí (R1Íô≥ ‚à©·µ£ R2Íô≥) x y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± -> bool) (a :Œ±) (s :Œ± -> bool).
    (‚àÉ(x :Œ±). x ‚àà a INSERT s ‚àß P x) ‚áî P a ‚à® ‚àÉ(x :Œ±). x ‚àà s ‚àß P x
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.COMPONENT , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
‚àÄ(f :Œ± -> Œ≥) (g :Œ≤ -> Œ¥) (z :Œ± + Œ≤).
    SUM_MAP f g z =
    if ISL z then (INL (f (OUTL z)) :Œ≥ + Œ¥) else (INR (g (OUTR z)) :Œ≥ + Œ¥)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≥) (g :Œ≤ -> Œ¥) (z :Œ± + Œ≤).
    SUM_MAP f g z =
    if ISL z then (INL (f (OUTL z)) :Œ≥ + Œ¥) else (INR (g (OUTR z)) :Œ≥ + Œ¥)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list list).
    REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :Œ± list -> Œ± list) l))
proof failed.
Failed theorem:
‚àÄ(l :Œ± list list).
    REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :Œ± list -> Œ± list) l))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f1 :Œ± -> Œ≤) (f2 :Œ± -> Œ≤) (l :Œ± list).
    MAP f1 l = MAP f2 l ‚áî ‚àÄ(e :Œ±). MEM e l ‚áí f1 e = f2 e
proof failed.
Failed theorem:
‚àÄ(f1 :Œ± -> Œ≤) (f2 :Œ± -> Œ≤) (l :Œ± list).
    MAP f1 l = MAP f2 l ‚áî ‚àÄ(e :Œ±). MEM e l ‚áí f1 e = f2 e
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
($= :Œ± -> Œ± -> bool)·µÄ = ($= :Œ± -> Œ± -> bool)
proof failed.
Failed theorem:
($= :Œ± -> Œ± -> bool)·µÄ = ($= :Œ± -> Œ± -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list).
    n < LENGTH l ‚áí ELL n (REVERSE l) = ELL (PRE (LENGTH l ‚àí n)) l
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list).
    n < LENGTH l ‚áí ELL n (REVERSE l) = ELL (PRE (LENGTH l ‚àí n)) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (s :Œ± -> bool). (‚àÖ :Œ± -> bool) ‚â† x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.NOT_INSERT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.NOT_INSERT_EMPTY]
(¬¨SHORTLEX (R :Œ± -> Œ± -> bool) ([] :Œ± list) ([] :Œ± list) ‚àß
 ¬¨SHORTLEX R ((h1 :Œ±)::(t1 :Œ± list)) ([] :Œ± list)) ‚àß
SHORTLEX R ([] :Œ± list) ((h2 :Œ±)::(t2 :Œ± list)) ‚àß
(SHORTLEX R (h1::t1) (h2::t2) ‚áî
 LENGTH t1 < LENGTH t2 ‚à®
 LENGTH t1 = LENGTH t2 ‚àß (R h1 h2 ‚à® h1 = h2 ‚àß SHORTLEX R t1 t2))
proof failed.
Failed theorem:
(¬¨SHORTLEX (R :Œ± -> Œ± -> bool) ([] :Œ± list) ([] :Œ± list) ‚àß
 ¬¨SHORTLEX R ((h1 :Œ±)::(t1 :Œ± list)) ([] :Œ± list)) ‚àß
SHORTLEX R ([] :Œ± list) ((h2 :Œ±)::(t2 :Œ± list)) ‚àß
(SHORTLEX R (h1::t1) (h2::t2) ‚áî
 LENGTH t1 < LENGTH t2 ‚à®
 LENGTH t1 = LENGTH t2 ‚àß (R h1 h2 ‚à® h1 = h2 ‚àß SHORTLEX R t1 t2))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(v :Œ±). PMATCH_IS_EXHAUSTIVE v ([] :(Œ± -> Œ≤ option) list) ‚áî F) ‚àß
‚àÄ(v :Œ≥) (r :Œ≥ -> Œ¥ option) (rs :(Œ≥ -> Œ¥ option) list).
    PMATCH_IS_EXHAUSTIVE v (r::rs) ‚áî
    r v ‚â† (NONE :Œ¥ option) ‚à® PMATCH_IS_EXHAUSTIVE v rs
proof failed.
Failed theorem:
(‚àÄ(v :Œ±). PMATCH_IS_EXHAUSTIVE v ([] :(Œ± -> Œ≤ option) list) ‚áî F) ‚àß
‚àÄ(v :Œ≥) (r :Œ≥ -> Œ¥ option) (rs :(Œ≥ -> Œ¥ option) list).
    PMATCH_IS_EXHAUSTIVE v (r::rs) ‚áî
    r v ‚â† (NONE :Œ¥ option) ‚à® PMATCH_IS_EXHAUSTIVE v rs
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(s :Œ± -> bool). ùïå(:Œ±) ‚à© s = s) ‚àß ‚àÄ(s :Œ± -> bool). s ‚à© ùïå(:Œ±) = s
proof failed.
Failed theorem:
(‚àÄ(s :Œ± -> bool). ùïå(:Œ±) ‚à© s = s) ‚àß ‚àÄ(s :Œ± -> bool). s ‚à© ùïå(:Œ±) = s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool).
    BIJ f s t ‚áî f ‚àà FUNSET s t ‚àß ‚àÄ(y :Œ≤). y ‚àà t ‚áí ‚àÉ!(x :Œ±). x ‚àà s ‚àß y = f x
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (s :Œ± -> bool) (t :Œ≤ -> bool).
    BIJ f s t ‚áî f ‚àà FUNSET s t ‚àß ‚àÄ(y :Œ≤). y ‚àà t ‚áí ‚àÉ!(x :Œ±). x ‚àà s ‚àß y = f x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí BUTLASTN n l = TAKE (LENGTH l ‚àí n) l
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí BUTLASTN n l = TAKE (LENGTH l ‚àí n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l2 :Œ± list) (l1 :Œ± list). IS_SUFFIX (REVERSE l1) (REVERSE l2) ‚áî l2 ‚âº l1
proof failed.
Failed theorem:
‚àÄ(l2 :Œ± list) (l1 :Œ± list). IS_SUFFIX (REVERSE l1) (REVERSE l2) ‚áî l2 ‚âº l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (x :Œ±) (y :Œ±). x ‚àà s DELETE y ‚áî x ‚àà s ‚àß x ‚â† y
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (x :Œ±) (y :Œ±). x ‚àà s DELETE y ‚áî x ‚àà s ‚àß x ‚â† y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(ls :Œ± list) (n :num).
    n ‚â§ LENGTH ls ‚áí REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls ‚àí n) ls)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , rich_listTheory.DROP_LASTN]
minimized proof:
  metis_tac [rich_listTheory.DROP_LASTN]
‚àÄ(f :Œ± -> Œ≤). PREIMAGE f (‚àÖ :Œ≤ -> bool) = (‚àÖ :Œ± -> bool)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤). PREIMAGE f (‚àÖ :Œ≤ -> bool) = (‚àÖ :Œ± -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (l :Œ± list). MAP f (REVERSE l) = REVERSE (MAP f l)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (l :Œ± list). MAP f (REVERSE l) = REVERSE (MAP f l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (x :Œ±). (s ‚à™ t) x ‚áî x ‚àà s ‚à® x ‚àà t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_UNION]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_UNION]
‚àÄ(n :num). LENGTH (COUNT_LIST n) = n
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH_GENLIST , rich_listTheory.COUNT_LIST_GENLIST]
minimized proof:
  metis_tac [listTheory.LENGTH_GENLIST, rich_listTheory.COUNT_LIST_GENLIST]
(‚àÉ(p :Œ± # Œ≤). (P :Œ± # Œ≤ -> bool) p) ‚áî ‚àÉ(p_1 :Œ±) (p_2 :Œ≤). P (p_1,p_2)
proof failed.
Failed theorem:
(‚àÉ(p :Œ± # Œ≤). (P :Œ± # Œ≤ -> bool) p) ‚áî ‚àÉ(p_1 :Œ±) (p_2 :Œ≤). P (p_1,p_2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    l1 ‚ß∫ l2 = FOLDR (CONS :Œ± -> Œ± list -> Œ± list) l2 l1
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    l1 ‚ß∫ l2 = FOLDR (CONS :Œ± -> Œ± list -> Œ± list) l2 l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (x :Œ±). COMPL (x INSERT s) = COMPL s DELETE x
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.COMPL_DEF , pred_setTheory.DELETE_INTER , pred_setTheory.DIFF_INSERT , pred_setTheory.DIFF_INTER_COMPL]
minimized proof:
  metis_tac [pred_setTheory.COMPL_DEF, pred_setTheory.DELETE_INTER, pred_setTheory.DIFF_INSERT, pred_setTheory.DIFF_INTER_COMPL]
‚àÄ(t :bool). t ‚áí T ‚áî T
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
countable (‚àÖ :Œ± -> bool)
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.FINITE_EMPTY , pred_setTheory.finite_countable]
minimized proof:
  metis_tac [pred_setTheory.FINITE_EMPTY, pred_setTheory.finite_countable]
‚àÄ(R :Œ± -> Œ± -> bool). Order R ‚áî StrongOrder (STRORD R)
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool). Order R ‚áî StrongOrder (STRORD R)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :bool) (x' :bool) (y :bool) (y' :bool).
    (x ‚áí y ‚áí y') ‚àß (¬¨y' ‚áí x' ‚áí x) ‚áí (x ‚áí y) ‚áí x' ‚áí y'
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(x :Œ± list) ‚âº (y :Œ±)::(ys :Œ± list) ‚áî
x = ([] :Œ± list) ‚à® ‚àÉ(xs :Œ± list). x = y::xs ‚àß xs ‚âº ys
proof failed.
Failed theorem:
(x :Œ± list) ‚âº (y :Œ±)::(ys :Œ± list) ‚áî
x = ([] :Œ± list) ‚à® ‚àÉ(xs :Œ± list). x = y::xs ‚àß xs ‚âº ys
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± -> bool) (l :Œ± list) (m :num). EVERY P l ‚áí EVERY P (TAKE m l)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , listTheory.EVERY_APPEND , listTheory.TAKE_DROP]
minimized proof:
  metis_tac [listTheory.EVERY_APPEND, listTheory.TAKE_DROP]
IS_SOME (OPTION_BIND (x :Œ± option) (g :Œ± -> Œ≤ option)) ‚áí IS_SOME x
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_SOME_DEF , optionTheory.NOT_IS_SOME_EQ_NONE , optionTheory.OPTION_BIND_def]
minimized proof:
  metis_tac [optionTheory.NOT_IS_SOME_EQ_NONE, optionTheory.OPTION_BIND_def]
(‚àÄ(x :Œ±) (y :Œ±). (R :Œ± -> Œ± -> bool) x y ‚áí (Q :Œ± -> Œ± -> bool) x y) ‚áí
RÍô≥ (x :Œ±) (y :Œ±) ‚áí
QÍô≥ x y
proof failed.
Failed theorem:
(‚àÄ(x :Œ±) (y :Œ±). (R :Œ± -> Œ± -> bool) x y ‚áí (Q :Œ± -> Œ± -> bool) x y) ‚áí
RÍô≥ (x :Œ±) (y :Œ±) ‚áí
QÍô≥ x y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ± list). x ‚âº x
proof failed.
Failed theorem:
‚àÄ(x :Œ± list). x ‚âº x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
count (0 :num) = (‚àÖ :num -> bool)
proof failed.
Failed theorem:
count (0 :num) = (‚àÖ :num -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(x :Œ±). (P :Œ± -> bool) x ‚áí (Q :Œ± -> bool) x) ‚áí
EXISTS P (l :Œ± list) ‚áí
EXISTS Q l
proof failed.
Failed theorem:
(‚àÄ(x :Œ±). (P :Œ± -> bool) x ‚áí (Q :Œ± -> bool) x) ‚áí
EXISTS P (l :Œ± list) ‚áí
EXISTS Q l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). s ‚äÜ t ‚áí s ‚à© t = s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_INTER_ABSORPTION]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_INTER_ABSORPTION]
‚àÄ(R :Œ± -> Œ± -> bool) (x :Œ±) (y :Œ±). R x y ‚áí R‚Å∫ x y
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.TC_DEF]
minimized proof:
  metis_tac [relationTheory.TC_DEF]
‚àÄ(xs :Œ± list). FILTER (Œª(x :Œ±). T) xs = xs
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_ID]
proof failed.
Failed theorem:
‚àÄ(xs :Œ± list). FILTER (Œª(x :Œ±). T) xs = xs
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). (Œª(x :Œ±). x) PERMUTES s
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool). (Œª(x :Œ±). x) PERMUTES s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (n :num).
    LENGTH l1 ‚â§ n ‚áí
    ‚àÄ(l2 :Œ± list). TAKE n (l1 ‚ß∫ l2) = l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (n :num).
    LENGTH l1 ‚â§ n ‚áí
    ‚àÄ(l2 :Œ± list). TAKE n (l1 ‚ß∫ l2) = l1 ‚ß∫ TAKE (n ‚àí LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). INFINITE s ‚áí ‚àÄ(t :Œ± -> bool). s ‚äÜ t ‚áí INFINITE t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_FINITE]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_FINITE]
(option_CASE (NONE :Œ± option) :Œ≤ -> (Œ± -> Œ≤) -> Œ≤) = (Œª(v :Œ≤) (f :Œ± -> Œ≤). v) ‚àß
(option_CASE (SOME (x :Œ±)) :Œ≤ -> (Œ± -> Œ≤) -> Œ≤) = (Œª(v :Œ≤) (f :Œ± -> Œ≤). f x)
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.option_case_def]
minimized proof:
  metis_tac [optionTheory.option_case_def]
‚àÄ(t :bool). t ‚áí F ‚áî ¬¨t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f1 :Œ± -> bool) (f2 :Œ± -> bool) (l :Œ± list).
    FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
proof failed.
Failed theorem:
‚àÄ(f1 :Œ± -> bool) (f2 :Œ± -> bool) (l :Œ± list).
    FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (P :Œ± -> bool) (Q :Œ≤ -> bool).
    FUNSET P Q f ‚áî ‚àÄ(x :Œ±). x ‚àà P ‚áí f x ‚àà Q
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (P :Œ± -> bool) (Q :Œ≤ -> bool).
    FUNSET P Q f ‚áî ‚àÄ(x :Œ±). x ‚àà P ‚áí f x ‚àà Q
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
ùïå(:Œ± + Œ≤) = IMAGE (INL :Œ± -> Œ± + Œ≤) ùïå(:Œ±) ‚à™ IMAGE (INR :Œ≤ -> Œ± + Œ≤) ùïå(:Œ≤)
proof failed.
Failed theorem:
ùïå(:Œ± + Œ≤) = IMAGE (INL :Œ± -> Œ± + Œ≤) ùïå(:Œ±) ‚à™ IMAGE (INR :Œ≤ -> Œ± + Œ≤) ùïå(:Œ≤)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (s :Œ± -> bool). s ‚äÜ x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.DELETE_SUBSET , pred_setTheory.SUBSET_INSERT_DELETE]
minimized proof:
  metis_tac [pred_setTheory.DELETE_SUBSET, pred_setTheory.SUBSET_INSERT_DELETE]
‚àÄ(l :Œ± list) (x :Œ±). l ‚â† x::l ‚àß x::l ‚â† l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list) (x :Œ±). l ‚â† x::l ‚àß x::l ‚â† l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_SET (‚àÖ :num -> bool) = (1 :num) ‚àß
‚àÄ(x :num) (s :num -> bool).
    FINITE s ‚áí PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
proof failed.
Failed theorem:
PROD_SET (‚àÖ :num -> bool) = (1 :num) ‚àß
‚àÄ(x :num) (s :num -> bool).
    FINITE s ‚áí PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool) (x :Œ±). PREIMAGE f s x ‚áî f x ‚àà s
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool) (x :Œ±). PREIMAGE f s x ‚áî f x ‚àà s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤ -> Œ≤) (e :Œ≤) (l1 :Œ± list) (l2 :Œ± list).
    FOLDR f e (l1 ‚ß∫ l2) = FOLDR f (FOLDR f e l2) l1
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤ -> Œ≤) (e :Œ≤) (l1 :Œ± list) (l2 :Œ± list).
    FOLDR f e (l1 ‚ß∫ l2) = FOLDR f (FOLDR f e l2) l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí DROP n l = LASTN (LENGTH l ‚àí n) l
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí DROP n l = LASTN (LENGTH l ‚àí n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí LENGTH (TAKE n l) = n
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí LENGTH (TAKE n l) = n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(0 :num) < (n :num) ‚áí DROP n ((x :Œ±)::(xs :Œ± list)) = DROP (n ‚àí (1 :num)) xs
proof failed.
Failed theorem:
(0 :num) < (n :num) ‚áí DROP n ((x :Œ±)::(xs :Œ± list)) = DROP (n ‚àí (1 :num)) xs
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :bool list). AND_EL l ‚áî FOLDL $/\ T l
proof failed.
Failed theorem:
‚àÄ(l :bool list). AND_EL l ‚áî FOLDL $/\ T l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± -> bool) (l :Œ± list).
    FILTER P l = ([] :Œ± list) ‚áî EVERY (Œª(x :Œ±). ¬¨P x) l
proof failed.
Failed theorem:
‚àÄ(P :Œ± -> bool) (l :Œ± list).
    FILTER P l = ([] :Œ± list) ‚áî EVERY (Œª(x :Œ±). ¬¨P x) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(v :Œ±) (rows :(Œ± -> Œ≤ option) list) (p :bool) (infos :bool list).
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ‚áî
    p ‚àß EVERY (Œª(r :Œ± -> Œ≤ option). r v = (NONE :Œ≤ option)) rows
proof failed.
Failed theorem:
‚àÄ(v :Œ±) (rows :(Œ± -> Œ≤ option) list) (p :bool) (infos :bool list).
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ‚áî
    p ‚àß EVERY (Œª(r :Œ± -> Œ≤ option). r v = (NONE :Œ≤ option)) rows
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). s ‚à© s = s
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool). s ‚à© s = s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ± -> bool) (y :Œ± -> bool) (z :Œ± -> bool).
    x DIFF y DIFF z = x DIFF z DIFF y
proof failed.
Failed theorem:
‚àÄ(x :Œ± -> bool) (y :Œ± -> bool) (z :Œ± -> bool).
    x DIFF y DIFF z = x DIFF z DIFF y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool).
    (c ‚áí x' ‚áí x) ‚àß (¬¨c ‚áí y' ‚áí y) ‚áí
    (if c then x' else y') ‚áí
    if c then x else y
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_OR , boolTheory.COND_RAND , boolTheory.EQ_CLAUSES , boolTheory.OR_DEF]
minimized proof:
  metis_tac []
‚àÄ(x :Œ±). SING {x}
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.SING_DEF]
minimized proof:
  metis_tac [pred_setTheory.SING_DEF]
((a :Œ±),(b :Œ±)) ‚àà {(x,x) | (P :Œ± -> bool) x} ‚áî P a ‚àß a = b
proof failed.
Failed theorem:
((a :Œ±),(b :Œ±)) ‚àà {(x,x) | (P :Œ± -> bool) x} ‚áî P a ‚àß a = b
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(M :Œ± list) (M' :Œ± list) (v :Œ≤) (f :Œ± -> Œ± list -> Œ≤).
    M = M' ‚àß (M' = ([] :Œ± list) ‚áí v = (v' :Œ≤)) ‚àß
    (‚àÄ(a0 :Œ±) (a1 :Œ± list).
         M' = a0::a1 ‚áí f a0 a1 = (f' :Œ± -> Œ± list -> Œ≤) a0 a1) ‚áí
    (list_CASE M v f :Œ≤) = (list_CASE M' v' f' :Œ≤)
proof failed.
Failed theorem:
‚àÄ(M :Œ± list) (M' :Œ± list) (v :Œ≤) (f :Œ± -> Œ± list -> Œ≤).
    M = M' ‚àß (M' = ([] :Œ± list) ‚áí v = (v' :Œ≤)) ‚àß
    (‚àÄ(a0 :Œ±) (a1 :Œ± list).
         M' = a0::a1 ‚áí f a0 a1 = (f' :Œ± -> Œ± list -> Œ≤) a0 a1) ‚áí
    (list_CASE M v f :Œ≤) = (list_CASE M' v' f' :Œ≤)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (l :Œ± list). SNOC x l ‚â† ([] :Œ± list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.EVERY_DEF , listTheory.EVERY_SNOC , listTheory.EXISTS_DEF , listTheory.EXISTS_SNOC]
minimized proof:
  metis_tac [listTheory.EVERY_DEF, listTheory.EVERY_SNOC, listTheory.EXISTS_DEF, listTheory.EXISTS_SNOC]
‚àÄ(g :Œ± -> Œ± -> Œ±) (f :Œ≤ -> Œ± -> Œ±).
    FCOMM g f ‚áí
    ‚àÄ(e :Œ±).
        LEFT_ID g e ‚áí
        ‚àÄ(l :Œ≤ list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
proof failed.
Failed theorem:
‚àÄ(g :Œ± -> Œ± -> Œ±) (f :Œ≤ -> Œ± -> Œ±).
    FCOMM g f ‚áí
    ‚àÄ(e :Œ±).
        LEFT_ID g e ‚áí
        ‚àÄ(l :Œ≤ list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(m :num) (n :num). m < SUC n ‚áí m ‚â† n ‚áí m < n
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , prim_recTheory.LESS_THM]
minimized proof:
  metis_tac [prim_recTheory.LESS_THM]
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (u :Œ± -> bool). s ‚äÇ t ‚àß t ‚äÇ u ‚áí s ‚äÇ u
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (u :Œ± -> bool). s ‚äÇ t ‚àß t ‚äÇ u ‚áí s ‚äÇ u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool).
    FINITE s ‚àß FINITE t ‚áí CARD (s ‚à™ t) = CARD s + CARD t ‚àí CARD (s ‚à© t)
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool).
    FINITE s ‚àß FINITE t ‚áí CARD (s ‚à™ t) = CARD s + CARD t ‚àí CARD (s ‚à© t)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). ùïå(:Œ±) ‚äÜ s ‚áî s = ùïå(:Œ±)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_ANTISYM , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_ANTISYM, pred_setTheory.SUBSET_UNIV]
‚àÄ(v :Œ±) (rows :(Œ± -> Œ≤ option) list) (p :bool) (infos :bool list).
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
proof failed.
Failed theorem:
‚àÄ(v :Œ±) (rows :(Œ± -> Œ≤ option) list) (p :bool) (infos :bool list).
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
LIST_REL (R :Œ± -> Œ≤ -> bool) (xs :Œ± list) ((h :Œ≤)::(t :Œ≤ list)) ‚áî
‚àÉ(h' :Œ±) (t' :Œ± list). xs = h'::t' ‚àß R h' h ‚àß LIST_REL R t' t
proof failed.
Failed theorem:
LIST_REL (R :Œ± -> Œ≤ -> bool) (xs :Œ± list) ((h :Œ≤)::(t :Œ≤ list)) ‚áî
‚àÉ(h' :Œ±) (t' :Œ± list). xs = h'::t' ‚àß R h' h ‚àß LIST_REL R t' t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(x :Œ±) (y :Œ±). (P :Œ± -> bool) x ‚àß (R :Œ± -> Œ± -> bool) x y ‚áí P y) ‚áí
‚àÄ(x :Œ±) (y :Œ±). P x ‚àß RÍô≥ x y ‚áí P y
proof failed.
Failed theorem:
(‚àÄ(x :Œ±) (y :Œ±). (P :Œ± -> bool) x ‚àß (R :Œ± -> Œ± -> bool) x y ‚áí P y) ‚áí
‚àÄ(x :Œ±) (y :Œ±). P x ‚àß RÍô≥ x y ‚áí P y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
((p :bool) ‚áî if (q :bool) then (r :bool) else (s :bool)) ‚áî
(p ‚à® q ‚à® ¬¨s) ‚àß (p ‚à® ¬¨r ‚à® ¬¨q) ‚àß (p ‚à® ¬¨r ‚à® ¬¨s) ‚àß (¬¨q ‚à® r ‚à® ¬¨p) ‚àß (q ‚à® s ‚à® ¬¨p)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_OR , boolTheory.COND_RAND , boolTheory.EQ_CLAUSES , boolTheory.MONO_COND]
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (x :Œ±). x ‚àà s ‚áî ‚àÉ(t :Œ± -> bool). s = x INSERT t ‚àß x ‚àâ t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (x :Œ±). x ‚àà s ‚áî ‚àÉ(t :Œ± -> bool). s = x INSERT t ‚àß x ‚àâ t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_REDUNDANT (v :Œ±) ((r :Œ± -> Œ≤ option)::(rs :(Œ± -> Œ≤ option) list))
  (0 :num) ‚áî r v = (NONE :Œ≤ option)
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT (v :Œ±) ((r :Œ± -> Œ≤ option)::(rs :(Œ± -> Œ≤ option) list))
  (0 :num) ‚áî r v = (NONE :Œ≤ option)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). DISJOINT t (s DIFF t) ‚àß DISJOINT (s DIFF t) t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). DISJOINT t (s DIFF t) ‚àß DISJOINT (s DIFF t) t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤ -> bool) (s :Œ± -> bool) (y :Œ≤).
    y ‚àà BIGUNION (IMAGE f s) ‚áî ‚àÉ(x :Œ±). x ‚àà s ‚àß y ‚àà f x
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤ -> bool) (s :Œ± -> bool) (y :Œ≤).
    y ‚àà BIGUNION (IMAGE f s) ‚áî ‚àÉ(x :Œ±). x ‚àà s ‚àß y ‚àà f x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(e :Œ±). LIST_ELEM_COUNT e ([] :Œ± list) = (0 :num)) ‚àß
(‚àÄ(e :Œ≤) (l1 :Œ≤ list) (l2 :Œ≤ list).
     LIST_ELEM_COUNT e (l1 ‚ß∫ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ‚àß
(‚àÄ(e :Œ≥) (h :Œ≥) (l :Œ≥ list).
     h = e ‚áí LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ‚àß
‚àÄ(e :Œ¥) (h :Œ¥) (l :Œ¥ list).
    h ‚â† e ‚áí LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
proof failed.
Failed theorem:
(‚àÄ(e :Œ±). LIST_ELEM_COUNT e ([] :Œ± list) = (0 :num)) ‚àß
(‚àÄ(e :Œ≤) (l1 :Œ≤ list) (l2 :Œ≤ list).
     LIST_ELEM_COUNT e (l1 ‚ß∫ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ‚àß
(‚àÄ(e :Œ≥) (h :Œ≥) (l :Œ≥ list).
     h = e ‚áí LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ‚àß
‚àÄ(e :Œ¥) (h :Œ¥) (l :Œ¥ list).
    h ‚â† e ‚áí LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (x :Œ±). (s ‚à© t) x ‚áî x ‚àà s ‚àß x ‚àà t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_INTER]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_INTER]
‚àÄ(P :Œ± -> bool) (l1 :Œ± list) (l2 :Œ± list).
    EXISTS P (l1 ‚ß∫ l2) ‚áî EXISTS P l1 ‚à® EXISTS P l2
proof failed.
Failed theorem:
‚àÄ(P :Œ± -> bool) (l1 :Œ± list) (l2 :Œ± list).
    EXISTS P (l1 ‚ß∫ l2) ‚áî EXISTS P l1 ‚à® EXISTS P l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(ls :Œ± list) (f :Œ± # Œ± -> Œ≤).
    MAP f (ZIP (ls,ls)) = MAP (Œª(x :Œ±). f (x,x)) ls
proof failed.
Failed theorem:
‚àÄ(ls :Œ± list) (f :Œ± # Œ± -> Œ≤).
    MAP f (ZIP (ls,ls)) = MAP (Œª(x :Œ±). f (x,x)) ls
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP (f :Œ± -> Œ≤) (l :Œ± list) = (h :Œ≤)::(t :Œ≤ list) ‚áî
‚àÉ(x0 :Œ±) (t0 :Œ± list). l = x0::t0 ‚àß h = f x0 ‚àß t = MAP f t0
proof failed.
Failed theorem:
MAP (f :Œ± -> Œ≤) (l :Œ± list) = (h :Œ≤)::(t :Œ≤ list) ‚áî
‚àÉ(x0 :Œ±) (t0 :Œ± list). l = x0::t0 ‚àß h = f x0 ‚àß t = MAP f t0
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ± -> bool). symmetric R ‚áí SC R = R
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool). symmetric R ‚áí SC R = R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    SHORTLEX (R :Œ± -> Œ± -> bool) l1 l2 ‚áí LENGTH l1 ‚â§ LENGTH l2
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list).
    SHORTLEX (R :Œ± -> Œ± -> bool) l1 l2 ‚áí LENGTH l1 ‚â§ LENGTH l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ≤ -> Œ± -> Œ≤) (e :Œ≤) (x :Œ±) (l :Œ± list).
    FOLDL f e (SNOC x l) = f (FOLDL f e l) x
proof failed.
Failed theorem:
‚àÄ(f :Œ≤ -> Œ± -> Œ≤) (e :Œ≤) (x :Œ±) (l :Œ± list).
    FOLDL f e (SNOC x l) = f (FOLDL f e l) x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :(Œ± -> bool) -> bool).
    P (‚àÖ :Œ± -> bool) ‚àß
    (‚àÄ(s :Œ± -> bool). FINITE s ‚àß P s ‚áí ‚àÄ(e :Œ±). e ‚àâ s ‚áí P (e INSERT s)) ‚áí
    ‚àÄ(s :Œ± -> bool). FINITE s ‚áí P s
proof failed.
Failed theorem:
‚àÄ(P :(Œ± -> bool) -> bool).
    P (‚àÖ :Œ± -> bool) ‚àß
    (‚àÄ(s :Œ± -> bool). FINITE s ‚àß P s ‚áí ‚àÄ(e :Œ±). e ‚àâ s ‚áí P (e INSERT s)) ‚áí
    ‚àÄ(s :Œ± -> bool). FINITE s ‚áí P s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). FINITE s ‚áí FINITE (REST s)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.FINITE_DELETE , pred_setTheory.REST_DEF]
minimized proof:
  metis_tac [pred_setTheory.FINITE_DELETE, pred_setTheory.REST_DEF]
‚àÄ(s :Œ± -> bool). FINITE s ‚áí ‚àÉ(f :num -> Œ±) (b :num). BIJ f (count b) s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.FINITE_BIJ_COUNT_EQ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_BIJ_COUNT_EQ]
‚àÄ(P :Œ± -> bool) (l1 :Œ± list) (l2 :Œ± list).
    EVERY P l1 ‚áí dropWhile P (l1 ‚ß∫ l2) = dropWhile P l2
proof failed.
Failed theorem:
‚àÄ(P :Œ± -> bool) (l1 :Œ± list) (l2 :Œ± list).
    EVERY P l1 ‚áí dropWhile P (l1 ‚ß∫ l2) = dropWhile P l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(OPTION_IGNORE_BIND (m1 :Œ± option) (m2 :Œ≤ option) = (NONE :Œ≤ option) ‚áî
 m1 = (NONE :Œ± option) ‚à® m2 = (NONE :Œ≤ option)) ‚àß
(OPTION_IGNORE_BIND m1 m2 = SOME (y :Œ≤) ‚áî ‚àÉ(x :Œ±). m1 = SOME x ‚àß m2 = SOME y)
proof failed.
Failed theorem:
(OPTION_IGNORE_BIND (m1 :Œ± option) (m2 :Œ≤ option) = (NONE :Œ≤ option) ‚áî
 m1 = (NONE :Œ± option) ‚à® m2 = (NONE :Œ≤ option)) ‚àß
(OPTION_IGNORE_BIND m1 m2 = SOME (y :Œ≤) ‚áî ‚àÉ(x :Œ±). m1 = SOME x ‚àß m2 = SOME y)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± -> bool) (l :Œ± list). EVERY P l ‚áî ¬¨EXISTS (Œª(x :Œ±). ¬¨P x) l
proof failed.
Failed theorem:
‚àÄ(P :Œ± -> bool) (l :Œ± list). EVERY P l ‚áî ¬¨EXISTS (Œª(x :Œ±). ¬¨P x) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). s = ùïå(:Œ±) ‚áí ‚àÄ(v :Œ±). v ‚àà s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
‚àÄ(n :num). SUC (m :num) = n ‚áí m < n
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , prim_recTheory.LESS_SUC_REFL]
minimized proof:
  metis_tac [prim_recTheory.LESS_SUC_REFL]
((if (P :bool) then SOME (x :Œ±) else (NONE :Œ± option)) = (NONE :Œ± option) ‚áî
 ¬¨P) ‚àß ((if P then (NONE :Œ± option) else SOME x) = (NONE :Œ± option) ‚áî P) ‚àß
((if P then SOME x else (NONE :Œ± option)) = SOME (y :Œ±) ‚áî P ‚àß x = y) ‚àß
((if P then (NONE :Œ± option) else SOME x) = SOME y ‚áî ¬¨P ‚àß x = y)
proof failed.
Failed theorem:
((if (P :bool) then SOME (x :Œ±) else (NONE :Œ± option)) = (NONE :Œ± option) ‚áî
 ¬¨P) ‚àß ((if P then (NONE :Œ± option) else SOME x) = (NONE :Œ± option) ‚áî P) ‚àß
((if P then SOME x else (NONE :Œ± option)) = SOME (y :Œ±) ‚áî P ‚àß x = y) ‚àß
((if P then (NONE :Œ± option) else SOME x) = SOME y ‚áî ¬¨P ‚àß x = y)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some(x :bool). x) = SOME T
proof failed.
Failed theorem:
(some(x :bool). x) = SOME T
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) ‚àß
REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list))
  ((i2 :bool)::(is2 :bool list)) =
(i1 ‚àß i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
proof failed.
Failed theorem:
REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) ‚àß
REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list))
  ((i2 :bool)::(is2 :bool list)) =
(i1 ‚àß i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)
proof failed.
Failed theorem:
‚àÄ(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ± recspace) (y :Œ± recspace). dest_rec x = dest_rec y ‚áî x = y
proof found by vampire:
  metisTools.METIS_TAC [ind_typeTheory.recspace_repfns]
minimized proof:
  metis_tac [ind_typeTheory.recspace_repfns]
((R1 :Œ± -> Œ± -> bool) LEX (R2 :Œ≤ -> Œ≤ -> bool)) ((a :Œ±),(b :Œ≤))
  ((c :Œ±),(d :Œ≤)) ‚áî R1 a c ‚à® a = c ‚àß R2 b d
proof failed.
Failed theorem:
((R1 :Œ± -> Œ± -> bool) LEX (R2 :Œ≤ -> Œ≤ -> bool)) ((a :Œ±),(b :Œ≤))
  ((c :Œ±),(d :Œ≤)) ‚áî R1 a c ‚à® a = c ‚àß R2 b d
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(l :Œ± list). ([] :Œ± list) ‚âº l ‚áî T) ‚àß
(‚àÄ(x :Œ±) (l :Œ± list). x::l ‚âº ([] :Œ± list) ‚áî F) ‚àß
‚àÄ(x1 :Œ±) (l1 :Œ± list) (x2 :Œ±) (l2 :Œ± list).
    x2::l2 ‚âº x1::l1 ‚áî x1 = x2 ‚àß l2 ‚âº l1
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , listTheory.isPREFIX_THM]
minimized proof:
  metis_tac [listTheory.isPREFIX_THM]
‚àÄ(n :num) (l :Œ± list).
    n ‚â§ LENGTH l ‚áí DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.REVERSE_REVERSE , rich_listTheory.BUTLASTN_def]
minimized proof:
  metis_tac [listTheory.REVERSE_REVERSE, rich_listTheory.BUTLASTN_def]
‚àÄ(l :Œ± list) (f :Œ± -> Œ≤) (x :Œ≤). MEM x (MAP f l) ‚áî ‚àÉ(y :Œ±). x = f y ‚àß MEM y l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list) (f :Œ± -> Œ≤) (x :Œ≤). MEM x (MAP f l) ‚áî ‚àÉ(y :Œ±). x = f y ‚àß MEM y l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool) (t :Œ≤ -> bool).
    s ‚äÜ t ‚áí PREIMAGE f s ‚äÜ PREIMAGE f t
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool) (t :Œ≤ -> bool).
    s ‚äÜ t ‚áí PREIMAGE f s ‚äÜ PREIMAGE f t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_ALL (P :Œ± -> bool) (Q :Œ≤ -> bool) ((x :Œ±),(y :Œ≤)) ‚áî P x ‚àß Q y
proof failed.
Failed theorem:
PROD_ALL (P :Œ± -> bool) (Q :Œ≤ -> bool) ((x :Œ±),(y :Œ≤)) ‚áî P x ‚àß Q y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ± -> bool) (x :Œ±) (y :Œ±). R‚Å∫ x y ‚áí RÍô≥ x y
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool) (x :Œ±) (y :Œ±). R‚Å∫ x y ‚áí RÍô≥ x y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l2 :Œ± list) (l1 :Œ± list). BUTLASTN (LENGTH l2) (l1 ‚ß∫ l2) = l1
proof failed.
Failed theorem:
‚àÄ(l2 :Œ± list) (l1 :Œ± list). BUTLASTN (LENGTH l2) (l1 ‚ß∫ l2) = l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list). LENGTH l = FOLDR (Œª(x :Œ±) (l' :num). SUC l') (0 :num) l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list). LENGTH l = FOLDR (Œª(x :Œ±) (l' :num). SUC l') (0 :num) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí LASTN n l = DROP (LENGTH l ‚àí n) l
proof failed.
Failed theorem:
‚àÄ(n :num) (l :Œ± list). n ‚â§ LENGTH l ‚áí LASTN n l = DROP (LENGTH l ‚àí n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(t :bool). F ‚à® t ‚áî t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool). IMAGE f (PREIMAGE f s) ‚äÜ s
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (s :Œ≤ -> bool). IMAGE f (PREIMAGE f s) ‚äÜ s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool). s ‚äÇ t ‚áî s ‚äÜ t ‚àß ‚àÉ(y :Œ±). y ‚àà t ‚àß y ‚àâ s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.BOUNDED_THM , boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.NOT_EQUAL_SETS , pred_setTheory.PSUBSET_DEF , pred_setTheory.PSUBSET_IRREFL , pred_setTheory.SET_EQ_SUBSET , pred_setTheory.SUBSET_applied]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.PSUBSET_DEF, pred_setTheory.SET_EQ_SUBSET, pred_setTheory.SUBSET_applied]
(R :Œ± -> Œ± -> bool)‚Å∫ (x :Œ±) (z :Œ±) ‚áî R x z ‚à® ‚àÉ(y :Œ±). R x y ‚àß R‚Å∫ y z
proof failed.
Failed theorem:
(R :Œ± -> Œ± -> bool)‚Å∫ (x :Œ±) (z :Œ±) ‚áî R x z ‚à® ‚àÉ(y :Œ±). R x y ‚àß R‚Å∫ y z
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(m :num) (n :num) (l :Œ± list).
    m ‚â§ n ‚àß n ‚â§ LENGTH l ‚áí
    BUTLASTN m (LASTN n l) = LASTN (n ‚àí m) (BUTLASTN m l)
proof failed.
Failed theorem:
‚àÄ(m :num) (n :num) (l :Œ± list).
    m ‚â§ n ‚àß n ‚â§ LENGTH l ‚áí
    BUTLASTN m (LASTN n l) = LASTN (n ‚àí m) (BUTLASTN m l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (P :Œ± -> bool) (Q :Œ± -> Œ≤ -> bool).
    f ‚àà DFUNSET P Q ‚áî ‚àÄ(x :Œ±). x ‚àà P ‚áí f x ‚àà Q x
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (P :Œ± -> bool) (Q :Œ± -> Œ≤ -> bool).
    f ‚àà DFUNSET P Q ‚áî ‚àÄ(x :Œ±). x ‚àà P ‚áí f x ‚àà Q x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÄ(x :Œ±). MEM x ([] :Œ± list) ‚áî F) ‚àß
‚àÄ(x :Œ±) (h :Œ±) (t :Œ± list). MEM x (h::t) ‚áî x = h ‚à® MEM x t
proof failed.
Failed theorem:
(‚àÄ(x :Œ±). MEM x ([] :Œ± list) ‚áî F) ‚àß
‚àÄ(x :Œ±) (h :Œ±) (t :Œ± list). MEM x (h::t) ‚áî x = h ‚à® MEM x t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (s :Œ± -> bool). x ‚àâ s ‚áî s DELETE x = s
proof failed.
Failed theorem:
‚àÄ(x :Œ±) (s :Œ± -> bool). x ‚àâ s ‚áî s DELETE x = s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
((INL (a :Œ±) :Œ± + Œ≤) ‚àà (A :Œ± -> bool) ‚äî (B :Œ≤ -> bool) ‚áî a ‚àà A) ‚àß
((INR (b :Œ≤) :Œ± + Œ≤) ‚àà A ‚äî B ‚áî b ‚àà B)
proof failed.
Failed theorem:
((INL (a :Œ±) :Œ± + Œ≤) ‚àà (A :Œ± -> bool) ‚äî (B :Œ≤ -> bool) ‚áî a ‚àà A) ‚àß
((INR (b :Œ≤) :Œ± + Œ≤) ‚àà A ‚äî B ‚áî b ‚àà B)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
WF (Œª(x :num) (y :num). y = SUC x)
proof failed.
Failed theorem:
WF (Œª(x :num) (y :num). y = SUC x)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(L :num list) (n :num). SUM_ACC L n = SUM L + n
proof failed.
Failed theorem:
‚àÄ(L :num list) (n :num). SUM_ACC L n = SUM L + n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INFINITE ùïå(:Œ±) ‚áî ‚àÄ(s :Œ± -> bool). FINITE s ‚áí s ‚äÇ ùïå(:Œ±)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.EQ_UNIV , pred_setTheory.FINITE_PSUBSET_INFINITE , pred_setTheory.PSUBSET_UNIV , pred_setTheory.SPECIFICATION]
minimized proof:
  metis_tac [pred_setTheory.EQ_UNIV, pred_setTheory.PSUBSET_UNIV]
‚àÄ(f :Œ± -> Œ≤).
    (‚àÄ(s :Œ≤ -> bool). INJ f (‚àÖ :Œ± -> bool) s) ‚àß
    ‚àÄ(s :Œ± -> bool). INJ f s (‚àÖ :Œ≤ -> bool) ‚áî s = (‚àÖ :Œ± -> bool)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤).
    (‚àÄ(s :Œ≤ -> bool). INJ f (‚àÖ :Œ± -> bool) s) ‚àß
    ‚àÄ(s :Œ± -> bool). INJ f s (‚àÖ :Œ≤ -> bool) ‚áî s = (‚àÖ :Œ± -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list) (f :Œ± -> Œ≤).
    (MAP f l = ([] :Œ≤ list) ‚áî l = ([] :Œ± list)) ‚àß
    (([] :Œ≤ list) = MAP f l ‚áî l = ([] :Œ± list))
proof failed.
Failed theorem:
‚àÄ(l :Œ± list) (f :Œ± -> Œ≤).
    (MAP f l = ([] :Œ≤ list) ‚áî l = ([] :Œ± list)) ‚àß
    (([] :Œ≤ list) = MAP f l ‚áî l = ([] :Œ± list))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :num list). SUM l = FOLDR $+ (0 :num) l
proof failed.
Failed theorem:
‚àÄ(l :num list). SUM l = FOLDR $+ (0 :num) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ≤ -> bool) (l1 :Œ± list) (l2 :Œ≤ list) (n :num).
    LIST_REL R l1 l2 ‚áí LIST_REL R (DROP n l1) (DROP n l2)
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ≤ -> bool) (l1 :Œ± list) (l2 :Œ≤ list) (n :num).
    LIST_REL R l1 l2 ‚áí LIST_REL R (DROP n l1) (DROP n l2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some(x :Œ±). F) = (NONE :Œ± option)
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_NONE_DEF , optionTheory.IS_NONE_EQ_NONE , optionTheory.some_intro]
proof failed.
Failed theorem:
(some(x :Œ±). F) = (NONE :Œ± option)
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (l1 :Œ± list) (l2 :Œ± list). MAP f (l1 ‚ß∫ l2) = MAP f l1 ‚ß∫ MAP f l2
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (l1 :Œ± list) (l2 :Œ± list). MAP f (l1 ‚ß∫ l2) = MAP f l1 ‚ß∫ MAP f l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(g :Œ± -> Œ± -> Œ±) (f :Œ≤ -> Œ± -> Œ±).
    FCOMM g f ‚áí
    ‚àÄ(e :Œ±).
        LEFT_ID g e ‚áí
        ‚àÄ(l1 :Œ≤ list) (l2 :Œ≤ list).
            FOLDR f e (l1 ‚ß∫ l2) = g (FOLDR f e l1) (FOLDR f e l2)
proof failed.
Failed theorem:
‚àÄ(g :Œ± -> Œ± -> Œ±) (f :Œ≤ -> Œ± -> Œ±).
    FCOMM g f ‚áí
    ‚àÄ(e :Œ±).
        LEFT_ID g e ‚áí
        ‚àÄ(l1 :Œ≤ list) (l2 :Œ≤ list).
            FOLDR f e (l1 ‚ß∫ l2) = g (FOLDR f e l1) (FOLDR f e l2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÖ (x :Œ±) ‚áî F
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.EMPTY_DEF]
minimized proof:
  metis_tac [pred_setTheory.EMPTY_DEF]
‚àÄ(R :Œ± -> Œ± -> bool).
    WeakLinearOrder R ‚áî WeakOrder R ‚àß ‚àÄ(a :Œ±) (b :Œ±). R a b ‚à® R b a
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool).
    WeakLinearOrder R ‚áî WeakOrder R ‚àß ‚àÄ(a :Œ±) (b :Œ±). R a b ‚à® R b a
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(R :Œ± -> Œ≤ -> bool) (R' :Œ≥ -> Œ± -> bool). (R ‚àò·µ£ R')·µÄ = R'·µÄ ‚àò·µ£ R·µÄ
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ≤ -> bool) (R' :Œ≥ -> Œ± -> bool). (R ‚àò·µ£ R')·µÄ = R'·µÄ ‚àò·µ£ R·µÄ
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (l :Œ± list). x::l = [x] ‚ß∫ l
proof failed.
Failed theorem:
‚àÄ(x :Œ±) (l :Œ± list). x::l = [x] ‚ß∫ l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (l :Œ± list).
    MAP f l = FOLDR (Œª(x :Œ±) (l' :Œ≤ list). f x::l') ([] :Œ≤ list) l
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (l :Œ± list).
    MAP f l = FOLDR (Œª(x :Œ±) (l' :Œ≤ list). f x::l') ([] :Œ≤ list) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±). x ‚àà ùïå(:Œ±)
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
ùïå(:Œ± + Œ≤) = ùïå(:Œ±) ‚äî ùïå(:Œ≤)
proof failed.
Failed theorem:
ùïå(:Œ± + Œ≤) = ùïå(:Œ±) ‚äî ùïå(:Œ≤)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (g :Œ± -> bool). (s DIFF t) ‚à© g = s ‚à© g DIFF t
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (t :Œ± -> bool) (g :Œ± -> bool). (s DIFF t) ‚à© g = s ‚à© g DIFF t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(Q :num -> bool) (P :num -> bool).
    (‚àÉ(n :num). P n) ‚àß (‚àÄ(n :num). (‚àÄ(m :num). m < n ‚áí ¬¨P m) ‚àß P n ‚áí Q n) ‚áí
    Q ($LEAST P)
proof failed.
Failed theorem:
‚àÄ(Q :num -> bool) (P :num -> bool).
    (‚àÉ(n :num). P n) ‚àß (‚àÄ(n :num). (‚àÄ(m :num). m < n ‚áí ¬¨P m) ‚àß P n ‚áí Q n) ‚áí
    Q ($LEAST P)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(xs :Œ± list). FILTER (Œª(x :Œ±). F) xs = ([] :Œ± list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_NIL]
proof failed.
Failed theorem:
‚àÄ(xs :Œ± list). FILTER (Œª(x :Œ±). F) xs = ([] :Œ± list)
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤) (x :Œ±) (s :Œ± -> bool).
    IMAGE f (x INSERT s) = f x INSERT IMAGE f s
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤) (x :Œ±) (s :Œ± -> bool).
    IMAGE f (x INSERT s) = f x INSERT IMAGE f s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list). TAKE (LENGTH l1) (l1 ‚ß∫ l2) = l1
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list). TAKE (LENGTH l1) (l1 ‚ß∫ l2) = l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list list).
    FLAT l = FOLDR ($++ :Œ± list -> Œ± list -> Œ± list) ([] :Œ± list) l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list list).
    FLAT l = FOLDR ($++ :Œ± list -> Œ± list -> Œ± list) ([] :Œ± list) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(¬¨LLEX (R :Œ± -> Œ± -> bool) ([] :Œ± list) ([] :Œ± list) ‚àß
 ¬¨LLEX R ((h1 :Œ±)::(t1 :Œ± list)) ([] :Œ± list)) ‚àß
LLEX R ([] :Œ± list) ((h2 :Œ±)::(t2 :Œ± list)) ‚àß
(LLEX R (h1::t1) (h2::t2) ‚áî R h1 h2 ‚à® h1 = h2 ‚àß LLEX R t1 t2)
proof failed.
Failed theorem:
(¬¨LLEX (R :Œ± -> Œ± -> bool) ([] :Œ± list) ([] :Œ± list) ‚àß
 ¬¨LLEX R ((h1 :Œ±)::(t1 :Œ± list)) ([] :Œ± list)) ‚àß
LLEX R ([] :Œ± list) ((h2 :Œ±)::(t2 :Œ± list)) ‚àß
(LLEX R (h1::t1) (h2::t2) ‚áî R h1 h2 ‚à® h1 = h2 ‚àß LLEX R t1 t2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list). l ‚ß∫ ([] :Œ± list) = l
proof failed.
Failed theorem:
‚àÄ(l :Œ± list). l ‚ß∫ ([] :Œ± list) = l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (f :Œ± -> Œ≤). f ‚àà FUNSET s (‚àÖ :Œ≤ -> bool) ‚áî s = (‚àÖ :Œ± -> bool)
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (f :Œ± -> Œ≤). f ‚àà FUNSET s (‚àÖ :Œ≤ -> bool) ‚áî s = (‚àÖ :Œ± -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(b :bool). b ‚áí (b ‚áî T)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
‚àÄ(l :Œ± list) (x :Œ±). ELL (0 :num) (SNOC x l) = x
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LAST_SNOC , rich_listTheory.ELL]
minimized proof:
  metis_tac [listTheory.LAST_SNOC, rich_listTheory.ELL]
‚àÄ(ls :Œ± list).
    ls ‚â† ([] :Œ± list) ‚áí MAP (f :Œ± -> Œ≤) (FRONT ls) = FRONT (MAP f ls)
proof failed.
Failed theorem:
‚àÄ(ls :Œ± list).
    ls ‚â† ([] :Œ± list) ‚áí MAP (f :Œ± -> Œ≤) (FRONT ls) = FRONT (MAP f ls)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num). (0 :num) < SUC n
proof failed.
Failed theorem:
‚àÄ(n :num). (0 :num) < SUC n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
IMAGE (f :Œ≤ -> Œ±) (s :Œ≤ -> bool) = {(z :Œ±)} ‚áî
s ‚â† (‚àÖ :Œ≤ -> bool) ‚àß ‚àÄ(x :Œ≤). x ‚àà s ‚áí f x = z
proof failed.
Failed theorem:
IMAGE (f :Œ≤ -> Œ±) (s :Œ≤ -> bool) = {(z :Œ±)} ‚áî
s ‚â† (‚àÖ :Œ≤ -> bool) ‚àß ‚àÄ(x :Œ≤). x ‚àà s ‚áí f x = z
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(f :Œ± -> Œ≤ -> Œ≤) (e :Œ≤) (l :Œ± list).
    FOLDR f e l = FOLDL (Œª(x :Œ≤) (y :Œ±). f y x) e (REVERSE l)
proof failed.
Failed theorem:
‚àÄ(f :Œ± -> Œ≤ -> Œ≤) (e :Œ≤) (l :Œ± list).
    FOLDR f e l = FOLDL (Œª(x :Œ≤) (y :Œ±). f y x) e (REVERSE l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(l1 :Œ± list) (l2 :Œ± list) (a :Œ±). IS_SUFFIX l1 l2 ‚áí IS_SUFFIX (a::l1) l2
proof failed.
Failed theorem:
‚àÄ(l1 :Œ± list) (l2 :Œ± list) (a :Œ±). IS_SUFFIX l1 l2 ‚áí IS_SUFFIX (a::l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(x :Œ±) (P :Œ± -> bool). x ‚àà P ‚áî P x
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
minimized proof:
  metis_tac [IN_DEF]
‚àÄ(R :Œ± -> Œ± -> bool). StrongOrder R ‚áí Order R
proof failed.
Failed theorem:
‚àÄ(R :Œ± -> Œ± -> bool). StrongOrder R ‚áí Order R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(n :num) (l :Œ± list). n < LENGTH l ‚áí MEM (EL n l) l
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , listTheory.MEM_EL]
minimized proof:
  metis_tac [listTheory.MEM_EL]
‚àÄ(x :Œ±) (y :Œ±) (P :Œ± -> bool). x ‚àà y INSERT P ‚áî x = y ‚à® x ‚â† y ‚àß x ‚àà P
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.INSERT_applied , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
OWHILE (G :Œ± -> bool) (f :Œ± -> Œ±) (s :Œ±) = SOME (s' :Œ±) ‚áí ¬¨G s'
proof failed.
Failed theorem:
OWHILE (G :Œ± -> bool) (f :Œ± -> Œ±) (s :Œ±) = SOME (s' :Œ±) ‚áí ¬¨G s'
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
symmetric (R1 :Œ± -> Œ± -> bool) ‚àß symmetric (R2 :Œ≤ -> Œ≤ -> bool) ‚áí
symmetric (R1 LEX R2)
proof failed.
Failed theorem:
symmetric (R1 :Œ± -> Œ± -> bool) ‚àß symmetric (R2 :Œ≤ -> Œ≤ -> bool) ‚áí
symmetric (R1 LEX R2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(P :Œ± -> bool) (l :Œ± list). PREFIX P l ‚âº l
proof failed.
Failed theorem:
‚àÄ(P :Œ± -> bool) (l :Œ± list). PREFIX P l ‚âº l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool) (f :Œ± -> Œ≤).
    (‚àÉ(t :Œ≤ -> bool). INJ f s t) ‚áí BIJ f s (IMAGE f s)
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool) (f :Œ± -> Œ≤).
    (‚àÉ(t :Œ≤ -> bool). INJ f s t) ‚áí BIJ f s (IMAGE f s)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(s :Œ± -> bool). s DIFF ùïå(:Œ±) = (‚àÖ :Œ± -> bool)
proof failed.
Failed theorem:
‚àÄ(s :Œ± -> bool). s DIFF ùïå(:Œ±) = (‚àÖ :Œ± -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
‚àÄ(t :bool). t ‚àß t ‚áî t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(‚àÉ(x :Œ±). x ‚àà (s :Œ± -> bool)) ‚àß (‚àÄ(x :Œ±). x ‚àà s ‚áí (P :Œ± -> bool) x) ‚áí
P (CHOICE s)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.CHOICE_DEF , pred_setTheory.NOT_IN_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.CHOICE_DEF, pred_setTheory.NOT_IN_EMPTY]
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
val it = fn: tactic
>
