
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Mon May 17 01:15:23 2021)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
> > > > Loading holyHammer
> > > > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> Loading Json
Cannot find file Json.ui
error in load Json : Fail "Cannot find file Json.ui"
Exception- Fail "Cannot find file Json.ui" raised
> > > > > > > > signature JSON =
  sig
    datatype json =
        ARRAY of json list
      | BOOL of bool
      | NULL
      | NUMBER of real
      | OBJECT of (string * json) list
      | STRING of string
    val parse: string -> json result
    datatype 'a result = ERROR of string | OK of 'a
    val serialise: json -> string
    val serialiseIndented: json -> string
  end
structure Json: JSON
val it = (): unit
val it = (): unit
val infile = "test_dep_dict.json": string
val readjson = fn: string -> Json.json Json.result
val readfirstkey = fn: string -> string
val allterms = fn: string -> term list
val json_string_to_string = fn: Json.json -> string
val string_to_term = fn: string -> term
val value_to_input = fn: string * Json.json -> term * string list
val value_to_term = fn: string * Json.json -> term
val firstpair = fn: string -> (term * string list) list
val construct_hh_input = fn: term * string list -> tactic
val gen_data = fn: string -> (term * string list) list
val gen_premises = fn: goal -> int -> string list -> string list
val gen_premises_better = fn:
   goal -> int -> string list -> int -> string list
val premise_filter = fn: ''a list -> ''a list -> ''a list
val premise_filter_better = fn: ''a list -> ''a list -> int -> ''a list
val premise_selection = fn: goal -> int -> string list
val run_hh_pb = fn: (term * string list) list -> prover list -> tactic
val it = (): unit
val run_hh_pb_better = fn:
   (term * string list) list -> prover list -> int -> int -> tactic
val it = (): unit
>
*** Emacs/HOL command completed ***

> val data = gen_data infile;
val data =
   [(“∀s t. t ⊆ s ⇒ s DIFF (s DIFF t) = t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", "boolTheory.LEFT_EXISTS_IMP_THM",
      ...]),
    (“∀set e. e ∈ POW set ⇔ e ⊆ set”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM",
      "boolTheory.LEFT_FORALL_IMP_THM", ...]),
    (“FINITE 𝕌(:α # β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", "boolTheory.LEFT_FORALL_OR_THM", ...]),
    (“∀f s t. FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      "boolTheory.LEFT_OR_OVER_AND", "boolTheory.LEFT_OR_EXISTS_THM",
      "boolTheory.LEFT_OR_CONG", ...]),
    (“{x | T} = 𝕌(:α)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", ...]),
    (“COMPL ∅ = 𝕌(:α)”,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", "pred_setTheory.SUBSET_DEF",
      "pred_setTheory.SING_DEF", "pred_setTheory.schroeder_close_def",
      "pred_setTheory.RINV_LO", "pred_setTheory.REST_DEF",
      "pred_setTheory.REL_RESTRICT_DEF", "pred_setTheory.PSUBSET_DEF",
      "pred_setTheory.LINV_OPT_def", "pred_setTheory.LINV_LO",
      "pred_setTheory.INTER_DEF", "pred_setTheory.INSERT_DEF",
      "pred_setTheory.INJ_DEF", "pred_setTheory.IMAGE_DEF",
      "pred_setTheory.HAS_SIZE", "pred_setTheory.GSPECIFICATION",
      "pred_setTheory.FUNSET", "pred_setTheory.FINITE_DEF",
      "pred_setTheory.EMPTY_DEF", "pred_setTheory.disjUNION_def",
      "pred_setTheory.DISJOINT_DEF", "pred_setTheory.DIFF_DEF",
      "pred_setTheory.DFUNSET", "pred_setTheory.DELETE_DEF",
      "pred_setTheory.CROSS_DEF", "pred_setTheory.count_def",
      "pred_setTheory.COMPL_DEF", "pred_setTheory.CHOICE_DEF",
      "pred_setTheory.CARD_DEF", "pred_setTheory.BIJ_DEF",
      "pred_setTheory.BIGUNION", "pred_setTheory.BIGINTER",
      "pred_setTheory.UNIV_SUBSET", "pred_setTheory.UNIV_NOT_EMPTY",
      "pred_setTheory.UNIV_FUNSET_UNIV", "pred_setTheory.UNIV_BOOL",
      "pred_setTheory.UNIV_applied", "pred_setTheory.UNION_UNIV",
      "pred_setTheory.UNION_SUBSET", "pred_setTheory.UNION_OVER_INTER",
      "pred_setTheory.UNION_IDEMPOT", "pred_setTheory.UNION_EMPTY",
      "pred_setTheory.UNION_DIFF_EQ", "pred_setTheory.UNION_DIFF",
      "pred_setTheory.UNION_COMM", "pred_setTheory.UNION_ASSOC",
      "pred_setTheory.UNION_applied", "pred_setTheory.transitive_PSUBSET",
      "pred_setTheory.TC_SUBSET_THM", "pred_setTheory.TC_PSUBSET",
      "pred_setTheory.SURJ_INJ_INV", "pred_setTheory.SURJ_IMP_INJ",
      "pred_setTheory.SURJ_IMAGE", "pred_setTheory.SURJ_ID",
      "pred_setTheory.SURJ_EMPTY", "pred_setTheory.SURJ_COMPOSE",
      "pred_setTheory.SURJ_CARD", "pred_setTheory.SUM_UNIV",
      "pred_setTheory.SUBSET_UNIV", "pred_setTheory.SUBSET_UNION_ABSORPTION",
      "pred_setTheory.SUBSET_UNION", "pred_setTheory.SUBSET_transitive",
      "pred_setTheory.SUBSET_TRANS", "pred_setTheory.SUBSET_THM",
      "pred_setTheory.SUBSET_reflexive", "pred_setTheory.SUBSET_REFL",
      "pred_setTheory.SUBSET_OF_INSERT", "pred_setTheory.SUBSET_K",
      "pred_setTheory.SUBSET_INTER_ABSORPTION",
      "pred_setTheory.SUBSET_INTER2", "pred_setTheory.SUBSET_INTER1",
      "pred_setTheory.SUBSET_INTER", "pred_setTheory.SUBSET_INSERT_DELETE",
      "pred_setTheory.SUBSET_INSERT", "pred_setTheory.SUBSET_IMAGE",
      "pred_setTheory.SUBSET_FINITE_I", "pred_setTheory.SUBSET_FINITE",
      "pred_setTheory.SUBSET_EQ_CARD", "pred_setTheory.SUBSET_EMPTY",
      "pred_setTheory.SUBSET_DISJOINT", "pred_setTheory.SUBSET_DELETE",
      "pred_setTheory.SUBSET_CROSS", "pred_setTheory.SUBSET_BIGUNION_I",
      "pred_setTheory.SUBSET_BIGUNION", "pred_setTheory.SUBSET_BIGINTER",
      "pred_setTheory.SUBSET_applied", "pred_setTheory.SUBSET_ANTISYM_EQ",
      "pred_setTheory.SUBSET_ANTISYM", "pred_setTheory.SUBSET_ADD",
      "pred_setTheory.SPECIFICATION", "pred_setTheory.SING_UNION",
      "pred_setTheory.SING_INSERT", ...]),
    (“∀s t. s = t ⇔ ∀x. x ∈ s ⇔ x ∈ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", "boolTheory.LET_CONG",
      ...]),
    (“∀s. (∃f. BIJ f 𝕌(:num) s) ⇒ countable s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", "boolTheory.LET_RAND", ...]),
    (“∀a0 a1 a0' a1'. a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM",
      "boolTheory.LET_RATOR", ...]),
    (“∀s1 s2. BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", "boolTheory.LET_THM", ...]),
    (“∀f s t. s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λn. s × f n) t)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR",
      "boolTheory.literal_case_RAND", "boolTheory.literal_case_id",
      "boolTheory.literal_case_CONG", ...]),
    (“PMATCH_EQUIV_ROWS v rows1 rows2 ⇒ PMATCH v rows1 = PMATCH v rows2”,
     ["patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE"]),
    (“∀l x. SEG 1 (LENGTH l) (SNOC x l) = [x]”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (“∀s. FINITE s ⇒ countable s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      "boolTheory.literal_case_THM", "boolTheory.literal_case_RATOR", ...]),
    (“∀l. FINITE (set l)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", "boolTheory.MONO_ALL",
      ...]),
    (“∀f x ls. MEM x ls ⇒ f x ≤ SUM (MAP f ls)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (“∀x s. x ∈ x INSERT s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      "boolTheory.MONO_COND", "boolTheory.MONO_AND", ...]),
    (“∀n l. n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", "boolTheory.MONO_EXISTS",
      ...]),
    (“∀v p g p' g' RES.
          PMATCH_ROW_COND_EX v p g ⇒
          (∀x. g x ⇒ ((∃x'. p' x' = p x ∧ g' x') ⇔ RES)) ⇒
          (PMATCH_ROW_COND_EX v p' g' ⇔ RES)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_AUX_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_def",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_def",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_def",
      "patternMatchesTheory.STRONGEST_REDUNDANT_ROWS_INFO_OK",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_DISJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_THM",
      "patternMatchesTheory.REDUNDANT_ROWS_INFOS_CONJ_REWRITE",
      "patternMatchesTheory.REDUNDANT_ROWS_INFO_TO_PMATCH_EQ",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_ROWS_INFO_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_SUC",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_NIL",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_LT",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_APPEND_GE",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_0",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_WEAKEN",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FULL_DEF",
      "patternMatchesTheory.PMATCH_ROW_COND_EX_FALSE",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_IS_EXHAUSTIVE_REWRITES",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.LENGTH_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC_PMATCH_ROW",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_SNOC",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_NIL",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_EXTRACT_IS_EXHAUSTIVE",
      "patternMatchesTheory.IS_REDUNDANT_ROWS_INFO_CONS",
      "patternMatchesTheory.FST_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL_STRONGEST_REDUNDANT_ROWS_INFO",
      "patternMatchesTheory.EL2_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.EL1_STRONGEST_REDUNDANT_ROWS_INFO_AUX",
      "patternMatchesTheory.APPLY_REDUNDANT_ROWS_INFO_THMS",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", ...]),
    (“∀x. ∅ DELETE x = ∅”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", "boolTheory.MONO_IMP", ...]),
    (“∀s t. s DIFF t ∩ s = s DIFF t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", "boolTheory.MONO_NOT_EQ",
      "boolTheory.MONO_NOT", ...]),
    (“∀n l1 l2. TAKE n (l1 ⧺ l2) = TAKE n l1 ⧺ TAKE (n − LENGTH l1) l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (“∀s t u. s ∩ (t ∩ u) = s ∩ t ∩ u”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES",
      "boolTheory.NOT_AND", "boolTheory.MONO_OR", ...]),
    (“∀P. (∀l. LENGTH l = 0 ⇒ P l) ⇔ P []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", "boolTheory.NOT_IMP",
      "boolTheory.NOT_FORALL_THM", "boolTheory.NOT_F",
      "boolTheory.NOT_EXISTS_THM", "boolTheory.NOT_CLAUSES", ...]),
    (“ASSOC $++”,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L",
      "combinTheory.MONOID_DISJ_F", "combinTheory.MONOID_CONJ_T",
      "combinTheory.literal_case_FORALL_ELIM",
      "combinTheory.LET_FORALL_ELIM", "combinTheory.K_THM",
      "combinTheory.K_o_THM", "combinTheory.I_THM", "combinTheory.I_o_ID",
      "combinTheory.GEN_literal_case_RATOR",
      "combinTheory.GEN_literal_case_RAND", "combinTheory.GEN_LET_RATOR",
      "combinTheory.GEN_LET_RAND", "combinTheory.FCOMM_ASSOC",
      "combinTheory.FAIL_THM", "combinTheory.C_THM", "combinTheory.C_ABS_L",
      "combinTheory.ASSOC_SYM", "combinTheory.ASSOC_DISJ",
      "combinTheory.ASSOC_CONJ", "combinTheory.APPLY_UPDATE_THM",
      "combinTheory.APPLY_UPDATE_ID", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.UNIQUE_DEF",
      "listTheory.TL_DEF", "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF",
      "listTheory.SUM", "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.OPT_MMAP_def", "listTheory.oHD_def",
      "listTheory.oEL_def", ...]),
    (“PMATCH_ROW_REDUNDANT v [] i ⇔ F”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM",
      "patternMatchesTheory.PMATCH_ROW_REDUNDANT_def",
      "patternMatchesTheory.PMATCH_ROW_def",
      "patternMatchesTheory.PMATCH_ROW_COND_def",
      "patternMatchesTheory.PMATCH_INCOMPLETE_def",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_def",
      "patternMatchesTheory.PMATCH_def",
      "patternMatchesTheory.some_var_bool_T",
      "patternMatchesTheory.some_var_bool_F",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_SUBSUMED",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS_EQUIV",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_TRIVIAL_SOUNDNESS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT_PMATCH_ROWS",
      "patternMatchesTheory.PMATCH_ROWS_DROP_REDUNDANT",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN_VAR",
      "patternMatchesTheory.PMATCH_ROW_REMOVE_FUN",
      "patternMatchesTheory.PMATCH_ROW_EXTEND_INPUT",
      "patternMatchesTheory.PMATCH_ROW_EQ_SOME",
      "patternMatchesTheory.PMATCH_ROW_EQ_NONE",
      "patternMatchesTheory.PMATCH_ROW_EQ_AUX",
      "patternMatchesTheory.PMATCH_ROW_CONG",
      "patternMatchesTheory.PMATCH_ROW_COND_DEF_GSYM",
      "patternMatchesTheory.PMATCH_REMOVE_ARB_NO_OVERLAP",
      "patternMatchesTheory.PMATCH_REMOVE_ARB",
      "patternMatchesTheory.PMATCH_INTRO_CATCHALL",
      "patternMatchesTheory.PMATCH_EXTEND_OLD",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH_ID",
      "patternMatchesTheory.PMATCH_EXTEND_BOTH",
      "patternMatchesTheory.PMATCH_EXTEND_BASE",
      "patternMatchesTheory.PMATCH_EVAL_MATCH",
      "patternMatchesTheory.PMATCH_EVAL",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_MATCH",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_3",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_2",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_is_equiv_1",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_EQUIV_EXPAND",
      "patternMatchesTheory.PMATCH_EQUIV_ROWS_CONS_NONE",
      "patternMatchesTheory.PMATCH_EQUIV_APPEND",
      "patternMatchesTheory.PMATCH_CONG",
      "patternMatchesTheory.PMATCH_COND_SELECT_UNIQUE",
      "patternMatchesTheory.PMATCH_APPEND_SEM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (“∀ZRECSPACE'.
          ZRECSPACE' ind_type$ZBOT ∧
          (∀c i r.
               (∀n. ZRECSPACE' (r n)) ⇒ ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
          ∀a0. ZRECSPACE a0 ⇒ ZRECSPACE' a0”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "ind_typeTheory.ZRECSPACE_def", "ind_typeTheory.ZCONSTR",
      "ind_typeTheory.ZBOT", "ind_typeTheory.NUMSUM_DEST",
      "ind_typeTheory.NUMSUM", "ind_typeTheory.NUMPAIR_DEST",
      "ind_typeTheory.NUMPAIR", "ind_typeTheory.INJP", "ind_typeTheory.INJN",
      "ind_typeTheory.INJF", "ind_typeTheory.INJA",
      "ind_typeTheory.ZRECSPACE_rules", "ind_typeTheory.ZCONSTR_ZBOT",
      "ind_typeTheory.NUMSUM_INJ", "ind_typeTheory.NUMPAIR_INJ_LEMMA",
      "ind_typeTheory.NUMPAIR_INJ", "ind_typeTheory.INJP_INJ",
      "ind_typeTheory.INJN_INJ", "ind_typeTheory.INJF_INJ",
      "ind_typeTheory.INJA_INJ", "ind_typeTheory.INJ_INVERSE2",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (“∀l1 l2.
          LENGTH l1 = LENGTH l2 ⇒
          ∀x1 x2. ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "pairTheory.UNCURRY_VAR",
      "pairTheory.SWAP_def", "pairTheory.RPROD_DEF",
      "pairTheory.prod_TY_DEF", "pairTheory.PROD_ALL_def",
      "pairTheory.PAIR_MAP", "pairTheory.pair_CASE_def", "pairTheory.PAIR",
      "pairTheory.LEX_DEF", "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM",
      "pairTheory.CURRY_ONE_ONE_THM", "pairTheory.CLOSED_PAIR_EQ",
      "pairTheory.C_UNCURRY_L", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (“¬SHORTLEX R l []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", "boolTheory.ONTO_THM",
      "boolTheory.ONE_ONE_THM", ...]),
    (“∀e. ∃fn. fn () = e”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "oneTheory.one_TY_DEF", "oneTheory.one_DEF", "oneTheory.one_Axiom",
      "oneTheory.one_axiom", "oneTheory.one", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", ...]),
    (“∀l. l ≠ [] ⇒ FRONT l ⧺ [LAST l] = l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", "boolTheory.OR_CLAUSES", ...]),
    (“∀l n. n < LENGTH l ⇒ LAST (DROP n l) = LAST l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM",
      "boolTheory.OR_CONG", ...]),
    (“∀n l. n ≤ LENGTH l ⇒ ∀x. BUTLASTN n (x::l) = x::BUTLASTN n l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (“∀f s t. DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1",
      "boolTheory.OR_IMP_THM", "boolTheory.OR_ELIM_THM", ...]),
    (“(∃ls. P ls) ⇔ ∃n f. P (GENLIST f n)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE",
      "boolTheory.OR_INTRO_THM2", "boolTheory.OR_INTRO_THM1", ...]),
    (“nub [] = []”,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SHORTLEX_def", "listTheory.SET_TO_LIST_primitive_def",
      "listTheory.REVERSE_DEF", "listTheory.REV_DEF", "listTheory.PAD_RIGHT",
      "listTheory.PAD_LEFT", "listTheory.NULL_DEF", "listTheory.nub_def",
      "listTheory.MAP", "listTheory.LUPDATE_def", "listTheory.LRC_def",
      "listTheory.LLEX_def", "listTheory.list_TY_DEF",
      "listTheory.LIST_TO_SET_DEF", "listTheory.list_size_def",
      "listTheory.LIST_LIFT2_def", "listTheory.LIST_IGNORE_BIND_def",
      "listTheory.LIST_GUARD_def", "listTheory.list_case_def",
      "listTheory.LIST_BIND_def", "listTheory.LIST_APPLY_def",
      "listTheory.LENGTH", "listTheory.LEN_DEF", "listTheory.LAST_DEF",
      "listTheory.isPREFIX", "listTheory.INDEX_OF_def",
      "listTheory.INDEX_FIND_def", "listTheory.HD", "listTheory.GENLIST_AUX",
      "listTheory.GENLIST", "listTheory.FRONT_DEF", "listTheory.FOLDR",
      "listTheory.FOLDL", "listTheory.FLAT", "listTheory.FIND_def",
      "listTheory.FILTER", "listTheory.EXISTS_DEF", "listTheory.EVERYi_def",
      "listTheory.EVERY_DEF", "listTheory.EL", "listTheory.DROP_def",
      "listTheory.APPEND", "listTheory.ALL_DISTINCT", "listTheory.ZIP_UNZIP",
      "listTheory.ZIP_MAP", "listTheory.ZIP_GENLIST", "listTheory.ZIP",
      "listTheory.WF_SHORTLEX_same_lengths", "listTheory.WF_SHORTLEX",
      "listTheory.WF_LIST_PRED", "listTheory.UNZIP_ZIP",
      "listTheory.UNZIP_THM", "listTheory.UNZIP_MAP",
      "listTheory.UNION_APPEND", ...]),
    (“WF R⁺ ⇔ WF R”,
     ["relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.SC_DEF", "relationTheory.RTC_def",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.equivalence_def",
      "relationTheory.EQC_DEF", "relationTheory.EMPTY_REL_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.WF_TC",
      "relationTheory.WF_SUBSET", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_irreflexive", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_INDUCTION_THM", "relationTheory.WF_EMPTY_REL",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_EQC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_MONOTONE",
      "relationTheory.TC_lifts_transitive_relations",
      "relationTheory.TC_lifts_monotonicities",
      "relationTheory.TC_lifts_invariants",
      "relationTheory.TC_lifts_equalities",
      "relationTheory.TC_INDUCT_RIGHT1", "relationTheory.TC_INDUCT_LEFT1",
      "relationTheory.TC_INDUCT_ALT_RIGHT",
      "relationTheory.TC_INDUCT_ALT_LEFT", "relationTheory.TC_INDUCT",
      "relationTheory.TC_implies_one_step", "relationTheory.TC_IDEM",
      "relationTheory.TC_CASES2_E", "relationTheory.TC_CASES2",
      "relationTheory.TC_CASES1_E", "relationTheory.TC_CASES1",
      "relationTheory.symmetric_TC", "relationTheory.symmetric_SC_identity",
      "relationTheory.symmetric_RC", "relationTheory.symmetric_EQC",
      "relationTheory.STRONG_EQC_INDUCTION", "relationTheory.SC_SYMMETRIC",
      "relationTheory.SC_MONOTONE", "relationTheory.SC_lifts_monotonicities",
      "relationTheory.SC_lifts_equalities", "relationTheory.SC_IDEM",
      "relationTheory.RTC_TC_RC", "relationTheory.RTC_SINGLE",
      "relationTheory.RTC_strongind", ...]),
    (“∀n. countable (count n)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", "boolTheory.PULL_FORALL",
      "boolTheory.PULL_EXISTS", "boolTheory.PEIRCE", ...]),
    (“{x | y = x} = {y}”,
     ["pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def",
      "pairTheory.RPROD_DEF", "pairTheory.prod_TY_DEF",
      "pairTheory.PROD_ALL_def", "pairTheory.PAIR_MAP",
      "pairTheory.pair_CASE_def", "pairTheory.PAIR", "pairTheory.LEX_DEF",
      "pairTheory.CURRY_DEF", "pairTheory.COMMA_DEF",
      "pairTheory.ABS_REP_prod", "pairTheory.WF_RPROD", "pairTheory.WF_LEX",
      "pairTheory.UNCURRY_ONE_ONE_THM", "pairTheory.UNCURRY_DEF",
      "pairTheory.UNCURRY_CURRY_THM", "pairTheory.UNCURRY_CONG",
      "pairTheory.transitive_LEX", "pairTheory.total_LEX",
      "pairTheory.symmetric_LEX", "pairTheory.SND_PAIR_MAP",
      "pairTheory.SND_EQ_EQUIV", "pairTheory.SND", "pairTheory.S_UNCURRY_R",
      "pairTheory.reflexive_LEX", "pairTheory.PROD_ALL_THM",
      "pairTheory.PROD_ALL_MONO", "pairTheory.PROD_ALL_CONG",
      "pairTheory.PFORALL_THM", "pairTheory.PEXISTS_THM",
      "pairTheory.PAIR_MAP_THM", "pairTheory.pair_induction",
      "pairTheory.PAIR_FUN_THM", "pairTheory.PAIR_FST_SND_EQ",
      "pairTheory.PAIR_EQ", "pairTheory.ABS_PAIR_THM",
      "pairTheory.pair_case_def", "pairTheory.pair_case_eq",
      "pairTheory.pair_case_cong", "pairTheory.pair_Axiom",
      "pairTheory.o_UNCURRY_R", "pairTheory.LEX_MONO",
      "pairTheory.LEX_DEF_THM", "pairTheory.LEX_CONG",
      "pairTheory.LET2_RATOR", "pairTheory.LET2_RAND",
      "pairTheory.LAMBDA_PROD", "pairTheory.FST_PAIR_MAP",
      "pairTheory.FST_EQ_EQUIV", "pairTheory.FST",
      "pairTheory.FORALL_UNCURRY", "pairTheory.FORALL_PROD",
      "pairTheory.EXISTS_PROD", "pairTheory.ELIM_UNCURRY",
      "pairTheory.ELIM_PFORALL_EVAL", "pairTheory.ELIM_PFORALL",
      "pairTheory.ELIM_PEXISTS_EVAL", "pairTheory.ELIM_PEXISTS",
      "pairTheory.datatype_pair", "pairTheory.CURRY_UNCURRY_THM", ...]),
    (“∀x l. SNOC x l = l ⧺ [x]”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (“∀s t. DISJOINT s t ⇔ ∀x. x ∈ s ⇒ x ∉ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", "boolTheory.RES_EXISTS_CONG",
      "boolTheory.REFL_CLAUSE", ...]),
    (“GENLIST f 0 = [] ∧ GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (“∀s x. x ⊂ {s} ⇔ x = ∅”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", "boolTheory.RES_EXISTS_THM",
      "boolTheory.RES_EXISTS_FALSE", ...]),
    (“∀R. symmetric Rᵀ ⇔ symmetric R”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_ON_WFREC",
      "relationTheory.TC_TRANSITIVE", "relationTheory.TC_SUBSET",
      "relationTheory.TC_STRONG_INDUCT_RIGHT1", ...]),
    (“∀t1 t2. (if F then t1 else t2) = t2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", "boolTheory.RES_FORALL_CONG",
      "boolTheory.RES_EXISTS_UNIQUE_THM", ...]),
    (“∀l1 l2. set (l1 ⧺ l2) = set l1 ∪ set l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE",
      "boolTheory.RES_FORALL_THM", ...]),
    (“∀l1 l2. l2 ≼ l1 ⇔ ∃l. l1 = l2 ⧺ l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", "boolTheory.RES_FORALL_TRUE", ...]),
    (“∀R. irreflexive Rᵀ ⇔ irreflexive R”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.inv_image_def",
      "relationTheory.inv_DEF", "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", "relationTheory.WF_TC_EQN",
      "relationTheory.WF_TC", "relationTheory.WF_SUBSET",
      "relationTheory.WF_RECURSION_THM", "relationTheory.WF_NOT_REFL",
      "relationTheory.WF_noloops", "relationTheory.WF_irreflexive",
      "relationTheory.WF_inv_image", "relationTheory.WF_INDUCTION_THM",
      "relationTheory.WF_EQ_WFP", "relationTheory.WF_EQ_INDUCTION_THM",
      "relationTheory.WF_EMPTY_REL", "relationTheory.WF_antisymmetric",
      "relationTheory.transitive_TC_identity",
      "relationTheory.RTC_TRANSITIVE", "relationTheory.transitive_RC",
      "relationTheory.transitive_inv_image", "relationTheory.transitive_EQC",
      "relationTheory.total_inv_image",
      "relationTheory.TFL_INDUCTIVE_INVARIANT_WFREC", ...]),
    (“∀s. CHOICE s ∉ REST s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", "boolTheory.RIGHT_AND_FORALL_THM",
      "boolTheory.RES_SELECT_THM", ...]),
    (“∀l1 l2. l1 ⧺ l2 = FOLDL (λl' x. SNOC x l') l1 l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      "boolTheory.RIGHT_AND_OVER_OR", ...]),
    (“∀L n. LEN L n = LENGTH L + n”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (“∀x x' y y'. (x ⇒ y' ⇒ y) ∧ (¬y' ⇒ x ⇒ x') ⇒ (x' ⇒ y') ⇒ x ⇒ y”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", "boolTheory.RIGHT_EXISTS_AND_THM",
      ...]),
    (“∀P l. EVERY P l ⇔ ∀e. MEM e l ⇒ P e”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      "boolTheory.RIGHT_EXISTS_IMP_THM", ...]),
    (“∀n1 n2. count n1 = count n2 ⇔ n1 = n2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM",
      "boolTheory.RIGHT_FORALL_OR_THM", "boolTheory.RIGHT_FORALL_IMP_THM",
      ...]),
    (“∀n. 0 < n ⇒ ∀x l. EL n (x::l) = EL (PRE n) l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", "boolTheory.RIGHT_OR_EXISTS_THM", ...]),
    (“∀e l. LIST_ELEM_COUNT e l > 0 ⇔ MEM e l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (“∀t. t ∨ t ⇔ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM",
      "boolTheory.RIGHT_OR_OVER_AND", ...]),
    (“(∀x y. f x = f y ⇔ x = y) ⇒
      (DISJOINT (IMAGE f s1) (IMAGE f s2) ⇔ DISJOINT s1 s2)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", "boolTheory.SELECT_ELIM_THM", ...]),
    (“∀x x' y y'. (y ⇒ x' ⇒ x) ∧ (x' ⇒ y' ⇒ y) ⇒ x' ∧ y' ⇒ x ∧ y”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", "boolTheory.SELECT_REFL_2",
      "boolTheory.SELECT_REFL", ...]),
    (“∀n. DROP n [] = []”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (“∀s. s ⊂ 𝕌(:α) ⇔ ∃x. x ∉ s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", "boolTheory.SWAP_EXISTS_THM",
      "boolTheory.SKOLEM_THM", "boolTheory.SELECT_UNIQUE",
      "boolTheory.SELECT_THM", ...]),
    (“Q ($some P) ⇒ (∃x. P x ∧ Q (SOME x)) ∨ (∀x. ¬P x) ∧ Q NONE”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.NONE_DEF", "optionTheory.THE_DEF",
      "optionTheory.SOME_SOME_APPLY", "optionTheory.some_intro",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME",
      "optionTheory.OPTREL_refl", "optionTheory.OPTREL_O",
      "optionTheory.OPTREL_MONO", "optionTheory.OPTREL_eq",
      "optionTheory.option_nchotomy", "optionTheory.OPTION_MCOMP_ID",
      "optionTheory.OPTION_MCOMP_ASSOC", "optionTheory.OPTION_MAP_id",
      "optionTheory.OPTION_MAP_EQ_SOME",
      "optionTheory.OPTION_MAP_EQ_NONE_both_ways",
      "optionTheory.OPTION_MAP_EQ_NONE", "optionTheory.OPTION_MAP_CONG",
      "optionTheory.OPTION_MAP_COMPOSE", "optionTheory.OPTION_MAP_CASE", ...]),
    (“transitive $SUBSET”,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.WCR_def",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.the_fun_def",
      "relationTheory.TC_DEF", "relationTheory.symmetric_def",
      "relationTheory.STRORD", "relationTheory.StrongOrder",
      "relationTheory.StrongLinearOrder", "relationTheory.SN_def",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", "relationTheory.RRESTRICT_DEF",
      "relationTheory.RRANGE", "relationTheory.RINTER",
      "relationTheory.RESTRICT_DEF", "relationTheory.reflexive_def",
      "relationTheory.RDOM_DELETE_DEF", "relationTheory.RDOM_DEF",
      "relationTheory.RCOMPL", "relationTheory.rcdiamond_def",
      "relationTheory.RC_DEF", "relationTheory.PreOrder",
      "relationTheory.Order", "relationTheory.O_DEF",
      "relationTheory.nf_def", "relationTheory.LinearOrder",
      "relationTheory.irreflexive_def", ...]),
    (“∀f g s t u. INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC",
      "combinTheory.o_ABS_R", "combinTheory.o_ABS_L", ...]),
    (“∀y s f. IMAGE f s y ⇔ ∃x. y = f x ∧ x ∈ s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM",
      "boolTheory.TYPE_DEFINITION_THM", "boolTheory.TRUTH",
      "boolTheory.SWAP_FORALL_THM", ...]),
    (“∀f g s t u. SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "combinTheory.W_DEF",
      "combinTheory.UPDATE_def", "combinTheory.S_DEF",
      "combinTheory.RIGHT_ID_DEF", "combinTheory.o_DEF",
      "combinTheory.MONOID_DEF", "combinTheory.LEFT_ID_DEF",
      "combinTheory.K_DEF", "combinTheory.I_DEF", "combinTheory.FCOMM_DEF",
      "combinTheory.FAIL_DEF", "combinTheory.COMM_DEF", "combinTheory.C_DEF",
      "combinTheory.ASSOC_DEF", "combinTheory.APP_DEF", "combinTheory.W_THM",
      "combinTheory.UPDATE_EQ", "combinTheory.UPDATE_COMMUTES",
      "combinTheory.UPDATE_APPLY_IMP_ID", "combinTheory.UPDATE_APPLY_ID_RWT",
      "combinTheory.UPDATE_APPLY_ID", "combinTheory.UPDATE_APPLY",
      "combinTheory.UPD_SAME_KEY_UNWIND",
      "combinTheory.UPD11_SAME_KEY_AND_BASE", "combinTheory.UPD11_SAME_BASE",
      "combinTheory.SAME_KEY_UPDATE_DIFFER", "combinTheory.S_THM",
      "combinTheory.S_ABS_R", "combinTheory.S_ABS_L", "combinTheory.o_THM",
      "combinTheory.o_ASSOC'", "combinTheory.o_ASSOC", ...]),
    (“∀f. INVOL f ⇒ ∀a b. f a = f b ⇔ a = b”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.RESTRICT_DEF",
      "relationTheory.reflexive_def", "relationTheory.RC_DEF",
      "relationTheory.irreflexive_def", "relationTheory.INVOL_DEF",
      "relationTheory.inv_image_def", "relationTheory.inv_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_ON_DEF",
      "relationTheory.INDUCTIVE_INVARIANT_DEF",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.EMPTY_REL_DEF", "relationTheory.approx_def",
      "relationTheory.antisymmetric_def", "relationTheory.WFREC_THM",
      "relationTheory.WFREC_COROLLARY", "relationTheory.WFP_STRONG_INDUCT",
      "relationTheory.WFP_RULES", "relationTheory.WFP_INDUCT",
      "relationTheory.WFP_CASES", ...]),
    (“∀l1 l2 l3. l1 ⧺ (l2 ⧺ l3) = l1 ⧺ l2 ⧺ l3”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", "boolTheory.UNWIND_FORALL_THM1",
      "boolTheory.UEXISTS_SIMP", "boolTheory.UEXISTS_OR_THM", ...]),
    (“$OLEAST P = NONE ⇔ ∀n. ¬P n”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID", "whileTheory.WHILE",
      "whileTheory.OLEAST_def", "whileTheory.LEAST_DEF",
      "whileTheory.HOARE_SPEC_DEF", "whileTheory.WHILE_RULE",
      "whileTheory.WHILE_INDUCTION", "whileTheory.OLEAST_INTRO",
      "whileTheory.OLEAST_EQNS", "whileTheory.LESS_LEAST",
      "whileTheory.LEAST_T", "whileTheory.LEAST_LESS_EQ",
      "whileTheory.LEAST_INTRO", "whileTheory.LEAST_EXISTS_IMP",
      "whileTheory.LEAST_EXISTS", "whileTheory.LEAST_EQ",
      "whileTheory.LEAST_ELIM", "whileTheory.ITERATION",
      "whileTheory.FULL_LEAST_INTRO", "optionTheory.some_def",
      "optionTheory.SOME_DEF", "optionTheory.OPTREL_def",
      "optionTheory.option_TY_DEF", "optionTheory.option_REP_ABS_DEF",
      "optionTheory.OPTION_MCOMP_def", "optionTheory.OPTION_MAP_DEF",
      "optionTheory.OPTION_MAP2_DEF", "optionTheory.OPTION_IGNORE_BIND_def",
      "optionTheory.OPTION_GUARD_def", "optionTheory.OPTION_CHOICE_def", ...]),
    (“∀n l1 l2. DROP n (l1 ⧺ l2) = DROP n l1 ⧺ DROP (n − LENGTH l1) l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1",
      "boolTheory.UNWIND_FORALL_THM2", ...]),
    (“∀ls f. EVERY (λx. ∃y. x = f y) ls ⇒ ∃l. ls = MAP f l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", "boolTheory.UNWIND_THM1", ...]),
    (“∀opt. (∃x. opt = SOME x) ∨ opt = NONE”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "optionTheory.some_def", "optionTheory.SOME_DEF",
      "optionTheory.OPTREL_def", "optionTheory.option_TY_DEF",
      "optionTheory.option_REP_ABS_DEF", "optionTheory.OPTION_MCOMP_def",
      "optionTheory.OPTION_MAP_DEF", "optionTheory.OPTION_MAP2_DEF",
      "optionTheory.OPTION_IGNORE_BIND_def", "optionTheory.OPTION_GUARD_def",
      "optionTheory.OPTION_CHOICE_def", "optionTheory.option_case_def",
      "optionTheory.OPTION_BIND_def", "optionTheory.OPTION_APPLY_def",
      "optionTheory.OPTION_ALL_def", "optionTheory.NONE_DEF",
      "optionTheory.THE_DEF", "optionTheory.SOME_SOME_APPLY",
      "optionTheory.some_intro", "optionTheory.some_F",
      "optionTheory.some_EQ", "optionTheory.some_elim",
      "optionTheory.SOME_APPLY_PERMUTE", "optionTheory.SOME_11",
      "optionTheory.OPTREL_THM", "optionTheory.OPTREL_SOME", ...]),
    (“SURJ f s t ⇒ ∃g. INJ g t s ∧ ∀y. y ∈ t ⇒ f (g y) = y”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", "boolTheory.AND_DEF",
      "boolTheory.UNWIND_THM2", ...]),
    (“∀R x y z. R꙳ x y ∧ R y z ⇒ R⁺ x z”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", "relationTheory.irreflexive_def",
      "relationTheory.equivalence_def", "relationTheory.EQC_DEF",
      "relationTheory.antisymmetric_def", "relationTheory.RTC_TRANSITIVE",
      "relationTheory.transitive_RC", "relationTheory.TC_TRANSITIVE",
      "relationTheory.TC_SUBSET", "relationTheory.TC_STRONG_INDUCT_RIGHT1",
      "relationTheory.TC_STRONG_INDUCT_LEFT1",
      "relationTheory.TC_STRONG_INDUCT", "relationTheory.TC_RULES",
      "relationTheory.TC_RTC", "relationTheory.TC_RC_EQNS",
      "relationTheory.TC_lifts_transitive_relations", ...]),
    (“∀f s t. INJ f s t ∧ INFINITE s ⇒ INFINITE t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      "boolTheory.literal_case_DEF", "boolTheory.LET_DEF",
      "boolTheory.itself_TY_DEF", "boolTheory.itself_case_thm",
      "boolTheory.IN_DEF", "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", "boolTheory.COND_DEF",
      "boolTheory.BOUNDED_DEF", ...]),
    (“∀x1 l1 x2 l2. SNOC x1 l1 = SNOC x2 l2 ⇒ LENGTH l1 = LENGTH l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF",
      "boolTheory.DATATYPE_TAG_DEF", ...]),
    (“∀x l. TL (SNOC x l) = if NULL l then [] else SNOC x (TL l)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", "boolTheory.EXISTS_DEF", ...]),
    (“∀P n.
          (∀l. LENGTH l = SUC n ⇒ P l) ⇔
          ∀l. LENGTH l = n ⇒ (λl. ∀x. P (x::l)) l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", "boolTheory.F_DEF",
      "boolTheory.EXISTS_UNIQUE_DEF", ...]),
    (“x ∈ RDOM (RRESTRICT R s) ⇔ x ∈ RDOM R ∧ x ∈ s”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.STRORD",
      "relationTheory.StrongOrder", "relationTheory.StrongLinearOrder",
      "relationTheory.SC_DEF", "relationTheory.RUNIV",
      "relationTheory.RUNION", "relationTheory.RTC_def",
      "relationTheory.RSUBSET", ...]),
    (“∀x l. FRONT (SNOC x l) = l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF",
      "boolTheory.FORALL_DEF", ...]),
    (“∀l x. MEM x (REVERSE l) ⇔ MEM x l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", "boolTheory.IN_DEF", ...]),
    (“∀l. NULL l ⇔ FOLDL (λx l'. F) T l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF",
      "boolTheory.itself_case_thm", ...]),
    (“∀l m x. MEM x (DROP m l) ⇒ MEM x l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", "boolTheory.literal_case_DEF",
      "boolTheory.LET_DEF", "boolTheory.itself_TY_DEF", ...]),
    (“∀x. ISR x ⇒ INR (OUTR x) = x”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "sumTheory.sum_TY_DEF", "sumTheory.sum_ISO_DEF", "sumTheory.OUTR",
      "sumTheory.OUTL", "sumTheory.ISR", "sumTheory.ISL",
      "sumTheory.IS_SUM_REP", "sumTheory.INR_DEF", "sumTheory.INL_DEF",
      "sumTheory.sum_INDUCT", "sumTheory.sum_distinct1",
      "sumTheory.sum_distinct", "sumTheory.sum_CASES", "sumTheory.sum_Axiom",
      ...]),
    (“[f] <*> l = MAP f l”,
     ["listTheory.LENGTH_NIL_SYM", "listTheory.INFINITE_LIST_UNIV",
      "listTheory.ZIP_def", "listTheory.UNZIP", "listTheory.TL_DEF",
      "listTheory.TAKE_def", "listTheory.SUM_ACC_DEF", "listTheory.SUM",
      "listTheory.splitAtPki_def", "listTheory.SNOC",
      "listTheory.SET_TO_LIST_primitive_def", "listTheory.REVERSE_DEF",
      "listTheory.REV_DEF", "listTheory.PAD_RIGHT", "listTheory.PAD_LEFT",
      ...]),
    (“∀n x. SNOC x (REPLICATE n x) = REPLICATE (SUC n) x”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF",
      "boolTheory.NOT_DEF", ...]),
    (“∀s x y. x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF",
      "boolTheory.RES_EXISTS_UNIQUE_DEF", "boolTheory.RES_EXISTS_DEF",
      "boolTheory.RES_ABSTRACT_DEF", "boolTheory.OR_DEF",
      "boolTheory.ONTO_DEF", "boolTheory.ONE_ONE_DEF", "boolTheory.NOT_DEF",
      ...]),
    (“∀n l1 l2. l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", "boolTheory.RES_ABSTRACT_DEF",
      "boolTheory.OR_DEF", "boolTheory.ONTO_DEF", ...]),
    (“∀R. reflexive (RC R)”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "relationTheory.trichotomous", "relationTheory.transitive_def",
      "relationTheory.total_def", "relationTheory.TC_DEF",
      "relationTheory.symmetric_def", "relationTheory.SC_DEF",
      "relationTheory.RTC_def", "relationTheory.reflexive_def",
      "relationTheory.RC_DEF", ...]),
    (“R1 ∘ᵣ R2 ∘ᵣ R3 = (R1 ∘ᵣ R2) ∘ᵣ R3”,
     ["relationTheory.WFREC_DEF", "relationTheory.WFP_DEF",
      "relationTheory.WF_DEF", "relationTheory.WeakOrder",
      "relationTheory.WeakLinearOrder", "relationTheory.trichotomous",
      "relationTheory.transitive_def", "relationTheory.total_def",
      "relationTheory.the_fun_def", "relationTheory.TC_DEF", ...]),
    (“∀n. 0 < n ⇒ ∀x l. ELL n (SNOC x l) = ELL (PRE n) l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF",
      "boolTheory.RES_EXISTS_DEF", ...]),
    (“∀l1 l2.
          ALL_DISTINCT (l1 ⧺ l2) ⇔
          ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀e. MEM e l1 ⇒ ¬MEM e l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", "boolTheory.RES_EXISTS_UNIQUE_DEF", ...]),
    (“∀l. l ≠ [] ⇒ BUTLASTN 1 l = FRONT l”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", "boolTheory.RES_SELECT_DEF",
      "boolTheory.RES_FORALL_DEF", ...]),
    (“∀s t. BIGUNION {s; t} = s ∪ t”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "boolTheory.TYPE_DEFINITION", "boolTheory.T_DEF",
      "boolTheory.RES_SELECT_DEF", "boolTheory.RES_FORALL_DEF", ...]),
    (“∀l2 l1. ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ⧺ l2) = HD l2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "listTheory.LENGTH_NIL_SYM", "boolTheory.TYPE_DEFINITION",
      "boolTheory.T_DEF", ...]),
    (“reflexive (R1 LEX R2) ⇔ reflexive R1 ∨ reflexive R2”,
     ["boolTheory.FALSITY", "boolTheory.bool_case_ID",
      "pairTheory.UNCURRY_VAR", "pairTheory.SWAP_def", ...]),
    (“INJ f s (IMAGE f s) ⇒ (countable (IMAGE f s) ⇔ countable s)”,
     ["pred_setTheory.UNIV_DEF", "pred_setTheory.UNION_DEF",
      "pred_setTheory.SURJ_DEF", ...]),
    (“MAP f (LIST_BIND l g) = LIST_BIND l (MAP f ∘ g)”,
     ["listTheory.LENGTH_NIL_SYM", "combinTheory.W_DEF", ...]),
    (“FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)”, ["pred_setTheory.UNIV_DEF", ...]),
    (“∀A B C. A ∧ B ⇒ C ⇔ A ⇒ B ⇒ C”, [...]), ...]: (term * string list) list
> # # # # # # # # # ** types trace now on
> run_hh_pb_better [holyHammer.Vampire] 256 128;
poly: : error: Type error in function application.
   Function: run_hh_pb_better :
      (term * string list) list -> prover list -> int -> int -> tactic
   Argument: [holyHammer.Vampire] : prover list
   Reason: Can't unify prover to term * string list (Incompatible types)
Found near run_hh_pb_better [holyHammer.Vampire] 256 128
poly: : error: Type error in function application.
   Function: run_hh_pb_better [holyHammer.Vampire] :
      prover list -> int -> int -> tactic
   Argument: 256 : int
   Reason:
      Can't unify int (*In Basis*) with prover list (*In Basis*)
         (Different type constructors)
Found near run_hh_pb_better [holyHammer.Vampire] 256 128
Static Errors
> run_hh_pb_better data[holyHammer.Vampire] 256 128;
∀(s :α -> bool) (t :α -> bool). t ⊆ s ⇒ s DIFF (s DIFF t) = t
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool). t ⊆ s ⇒ s DIFF (s DIFF t) = t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(set :α -> bool) (e :α -> bool). e ∈ POW set ⇔ e ⊆ set
proof failed.
Failed theorem:
∀(set :α -> bool) (e :α -> bool). e ∈ POW set ⇔ e ⊆ set
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FINITE 𝕌(:α # β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)
proof failed.
Failed theorem:
FINITE 𝕌(:α # β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (s :α -> bool) (t :β -> bool).
    FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t
proof failed.
Failed theorem:
∀(f :α -> β) (s :α -> bool) (t :β -> bool).
    FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
{x | T} = 𝕌(:α)
proof failed.
Failed theorem:
{x | T} = 𝕌(:α)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
COMPL (∅ :α -> bool) = 𝕌(:α)
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.COMPL_CLAUSES , pred_setTheory.COMPL_COMPL , pred_setTheory.INTER_UNIV]
minimized proof:
  metis_tac [pred_setTheory.COMPL_CLAUSES, pred_setTheory.COMPL_COMPL, pred_setTheory.INTER_UNIV]
∀(s :α -> bool) (t :α -> bool). s = t ⇔ ∀(x :α). x ∈ s ⇔ x ∈ t
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool). s = t ⇔ ∀(x :α). x ∈ s ⇔ x ∈ t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). (∃(f :num -> α). BIJ f 𝕌(:num) s) ⇒ countable s
proof failed.
Failed theorem:
∀(s :α -> bool). (∃(f :num -> α). BIJ f 𝕌(:num) s) ⇒ countable s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(a0 :α) (a1 :α list) (a0' :α) (a1' :α list).
    a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'
proof found by vampire:
  metisTools.METIS_TAC [listTheory.HD , listTheory.TL]
minimized proof:
  metis_tac [listTheory.HD, listTheory.TL]
∀(s1 :(α -> bool) -> bool) (s2 :(α -> bool) -> bool).
    BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2
proof failed.
Failed theorem:
∀(s1 :(α -> bool) -> bool) (s2 :(α -> bool) -> bool).
    BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β -> bool) (s :γ -> bool) (t :α -> bool).
    s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λ(n :α). s × f n) t)
proof failed.
Failed theorem:
∀(f :α -> β -> bool) (s :γ -> bool) (t :α -> bool).
    s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λ(n :α). s × f n) t)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_EQUIV_ROWS (v :α) (rows1 :(α -> β option) list)
  (rows2 :(α -> β option) list) ⇒
PMATCH v rows1 = PMATCH v rows2
proof failed.
Failed theorem:
PMATCH_EQUIV_ROWS (v :α) (rows1 :(α -> β option) list)
  (rows2 :(α -> β option) list) ⇒
PMATCH v rows1 = PMATCH v rows2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list) (x :α). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]
proof failed.
Failed theorem:
∀(l :α list) (x :α). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). FINITE s ⇒ countable s
proof failed.
Failed theorem:
∀(s :α -> bool). FINITE s ⇒ countable s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list). FINITE (set l)
proof failed.
Failed theorem:
∀(l :α list). FINITE (set l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> num) (x :α) (ls :α list). MEM x ls ⇒ f x ≤ SUM (MAP f ls)
proof failed.
Failed theorem:
∀(f :α -> num) (x :α) (ls :α list). MEM x ls ⇒ f x ≤ SUM (MAP f ls)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (s :α -> bool). x ∈ x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.INSERT_applied]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.INSERT_applied]
∀(n :num) (l :α list).
    n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
proof failed.
Failed theorem:
∀(n :num) (l :α list).
    n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(v :α) (p :β -> α) (g :β -> bool) (p' :γ -> α) (g' :γ -> bool) (RES :bool).
    PMATCH_ROW_COND_EX v p g ⇒
    (∀(x :β). g x ⇒ ((∃(x' :γ). p' x' = p x ∧ g' x') ⇔ RES)) ⇒
    (PMATCH_ROW_COND_EX v p' g' ⇔ RES)
proof failed.
Failed theorem:
∀(v :α) (p :β -> α) (g :β -> bool) (p' :γ -> α) (g' :γ -> bool) (RES :bool).
    PMATCH_ROW_COND_EX v p g ⇒
    (∀(x :β). g x ⇒ ((∃(x' :γ). p' x' = p x ∧ g' x') ⇔ RES)) ⇒
    (PMATCH_ROW_COND_EX v p' g' ⇔ RES)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α). (∅ :α -> bool) DELETE x = (∅ :α -> bool)
proof failed.
Failed theorem:
∀(x :α). (∅ :α -> bool) DELETE x = (∅ :α -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool). s DIFF t ∩ s = s DIFF t
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool). s DIFF t ∩ s = s DIFF t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l1 :α list) (l2 :α list).
    TAKE n (l1 ⧺ l2) = TAKE n l1 ⧺ TAKE (n − LENGTH l1) l2
proof failed.
Failed theorem:
∀(n :num) (l1 :α list) (l2 :α list).
    TAKE n (l1 ⧺ l2) = TAKE n l1 ⧺ TAKE (n − LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ∩ (t ∩ u) = s ∩ t ∩ u
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ∩ (t ∩ u) = s ∩ t ∩ u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α list -> bool).
    (∀(l :α list). LENGTH l = (0 :num) ⇒ P l) ⇔ P ([] :α list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH , listTheory.NULL_EQ , listTheory.NULL_LENGTH]
minimized proof:
  metis_tac [listTheory.NULL_EQ, listTheory.NULL_LENGTH]
ASSOC ($++ :α list -> α list -> α list)
proof failed.
Failed theorem:
ASSOC ($++ :α list -> α list -> α list)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_REDUNDANT (v :α) ([] :(α -> β option) list) (i :num) ⇔ F
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT (v :α) ([] :(α -> β option) list) (i :num) ⇔ F
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(ZRECSPACE' :(num -> α -> bool) -> bool).
    ZRECSPACE' (ind_type$ZBOT :num -> α -> bool) ∧
    (∀(c :num) (i :α) (r :num -> num -> α -> bool).
         (∀(n :num). ZRECSPACE' (r n)) ⇒ ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
    ∀(a0 :num -> α -> bool). ZRECSPACE a0 ⇒ ZRECSPACE' a0
proof failed.
Failed theorem:
∀(ZRECSPACE' :(num -> α -> bool) -> bool).
    ZRECSPACE' (ind_type$ZBOT :num -> α -> bool) ∧
    (∀(c :num) (i :α) (r :num -> num -> α -> bool).
         (∀(n :num). ZRECSPACE' (r n)) ⇒ ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒
    ∀(a0 :num -> α -> bool). ZRECSPACE a0 ⇒ ZRECSPACE' a0
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :β list).
    LENGTH l1 = LENGTH l2 ⇒
    ∀(x1 :α) (x2 :β).
        ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :β list).
    LENGTH l1 = LENGTH l2 ⇒
    ∀(x1 :α) (x2 :β).
        ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
¬SHORTLEX (R :α -> α -> bool) (l :α list) ([] :α list)
proof failed.
Failed theorem:
¬SHORTLEX (R :α -> α -> bool) (l :α list) ([] :α list)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(e :α). ∃(fn :unit -> α). fn () = e
proof found by vampire:
  metisTools.METIS_TAC []
proof failed.
Failed theorem:
∀(e :α). ∃(fn :unit -> α). fn () = e
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list). l ≠ ([] :α list) ⇒ FRONT l ⧺ [LAST l] = l
proof failed.
Failed theorem:
∀(l :α list). l ≠ ([] :α list) ⇒ FRONT l ⧺ [LAST l] = l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list) (n :num). n < LENGTH l ⇒ LAST (DROP n l) = LAST l
proof failed.
Failed theorem:
∀(l :α list) (n :num). n < LENGTH l ⇒ LAST (DROP n l) = LAST l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list).
    n ≤ LENGTH l ⇒ ∀(x :α). BUTLASTN n (x::l) = x::BUTLASTN n l
proof failed.
Failed theorem:
∀(n :num) (l :α list).
    n ≤ LENGTH l ⇒ ∀(x :α). BUTLASTN n (x::l) = x::BUTLASTN n l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (s :β -> bool) (t :β -> bool).
    DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)
proof failed.
Failed theorem:
∀(f :α -> β) (s :β -> bool) (t :β -> bool).
    DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∃(ls :α list). (P :α list -> bool) ls) ⇔
∃(n :num) (f :num -> α). P (GENLIST f n)
proof failed.
Failed theorem:
(∃(ls :α list). (P :α list -> bool) ls) ⇔
∃(n :num) (f :num -> α). P (GENLIST f n)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
nub ([] :α list) = ([] :α list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.nub_def]
minimized proof:
  metis_tac [listTheory.nub_def]
WF (R :α -> α -> bool)⁺ ⇔ WF R
proof failed.
Failed theorem:
WF (R :α -> α -> bool)⁺ ⇔ WF R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num). countable (count n)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.COUNTABLE_ALT]
proof failed.
Failed theorem:
∀(n :num). countable (count n)
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
{x | (y :α) = x} = {y}
proof failed.
Failed theorem:
{x | (y :α) = x} = {y}
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (l :α list). SNOC x l = l ⧺ [x]
proof failed.
Failed theorem:
∀(x :α) (l :α list). SNOC x l = l ⧺ [x]
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool). DISJOINT s t ⇔ ∀(x :α). x ∈ s ⇒ x ∉ t
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool). DISJOINT s t ⇔ ∀(x :α). x ∈ s ⇒ x ∉ t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
GENLIST (f :num -> α) (0 :num) = ([] :α list) ∧
GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :α list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.GENLIST , listTheory.GENLIST_GENLIST_AUX]
minimized proof:
  metis_tac [listTheory.GENLIST, listTheory.GENLIST_GENLIST_AUX]
∀(s :α) (x :α -> bool). x ⊂ {s} ⇔ x = (∅ :α -> bool)
proof failed.
Failed theorem:
∀(s :α) (x :α -> bool). x ⊂ {s} ⇔ x = (∅ :α -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> α -> bool). symmetric Rᵀ ⇔ symmetric R
proof failed.
Failed theorem:
∀(R :α -> α -> bool). symmetric Rᵀ ⇔ symmetric R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(t1 :α) (t2 :α). (if F then t1 else t2) = t2
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.bool_case_thm]
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list). set (l1 ⧺ l2) = set l1 ∪ set l2
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list). set (l1 ⧺ l2) = set l1 ∪ set l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list). l2 ≼ l1 ⇔ ∃(l :α list). l1 = l2 ⧺ l
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list). l2 ≼ l1 ⇔ ∃(l :α list). l1 = l2 ⧺ l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> α -> bool). irreflexive Rᵀ ⇔ irreflexive R
proof failed.
Failed theorem:
∀(R :α -> α -> bool). irreflexive Rᵀ ⇔ irreflexive R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). CHOICE s ∉ REST s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.REST_applied]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.REST_applied]
∀(l1 :α list) (l2 :α list).
    l1 ⧺ l2 = FOLDL (λ(l' :α list) (x :α). SNOC x l') l1 l2
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list).
    l1 ⧺ l2 = FOLDL (λ(l' :α list) (x :α). SNOC x l') l1 l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(L :α list) (n :num). LEN L n = LENGTH L + n
proof failed.
Failed theorem:
∀(L :α list) (n :num). LEN L n = LENGTH L + n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :bool) (x' :bool) (y :bool) (y' :bool).
    (x ⇒ y' ⇒ y) ∧ (¬y' ⇒ x ⇒ x') ⇒ (x' ⇒ y') ⇒ x ⇒ y
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α -> bool) (l :α list). EVERY P l ⇔ ∀(e :α). MEM e l ⇒ P e
proof failed.
Failed theorem:
∀(P :α -> bool) (l :α list). EVERY P l ⇔ ∀(e :α). MEM e l ⇒ P e
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n1 :num) (n2 :num). count n1 = count n2 ⇔ n1 = n2
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.CARD_COUNT]
minimized proof:
  metis_tac [pred_setTheory.CARD_COUNT]
∀(n :num). (0 :num) < n ⇒ ∀(x :α) (l :α list). EL n (x::l) = EL (PRE n) l
proof failed.
Failed theorem:
∀(n :num). (0 :num) < n ⇒ ∀(x :α) (l :α list). EL n (x::l) = EL (PRE n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(e :α) (l :α list). LIST_ELEM_COUNT e l > (0 :num) ⇔ MEM e l
proof failed.
Failed theorem:
∀(e :α) (l :α list). LIST_ELEM_COUNT e l > (0 :num) ⇔ MEM e l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(t :bool). t ∨ t ⇔ t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(x :α) (y :α). (f :α -> β) x = f y ⇔ x = y) ⇒
(DISJOINT (IMAGE f (s1 :α -> bool)) (IMAGE f (s2 :α -> bool)) ⇔
 DISJOINT s1 s2)
proof failed.
Failed theorem:
(∀(x :α) (y :α). (f :α -> β) x = f y ⇔ x = y) ⇒
(DISJOINT (IMAGE f (s1 :α -> bool)) (IMAGE f (s2 :α -> bool)) ⇔
 DISJOINT s1 s2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :bool) (x' :bool) (y :bool) (y' :bool).
    (y ⇒ x' ⇒ x) ∧ (x' ⇒ y' ⇒ y) ⇒ x' ∧ y' ⇒ x ∧ y
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num). DROP n ([] :α list) = ([] :α list)
proof failed.
Failed theorem:
∀(n :num). DROP n ([] :α list) = ([] :α list)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). s ⊂ 𝕌(:α) ⇔ ∃(x :α). x ∉ s
proof failed.
Failed theorem:
∀(s :α -> bool). s ⊂ 𝕌(:α) ⇔ ∃(x :α). x ∉ s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(Q :α option -> bool) ($some (P :α -> bool)) ⇒
(∃(x :α). P x ∧ Q (SOME x)) ∨ (∀(x :α). ¬P x) ∧ Q (NONE :α option)
proof failed.
Failed theorem:
(Q :α option -> bool) ($some (P :α -> bool)) ⇒
(∃(x :α). P x ∧ Q (SOME x)) ∨ (∀(x :α). ¬P x) ∧ Q (NONE :α option)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
transitive ($SUBSET :(α -> bool) -> (α -> bool) -> bool)
proof failed.
Failed theorem:
transitive ($SUBSET :(α -> bool) -> (α -> bool) -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool).
    INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u
proof failed.
Failed theorem:
∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool).
    INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(y :β) (s :α -> bool) (f :α -> β). IMAGE f s y ⇔ ∃(x :α). y = f x ∧ x ∈ s
proof failed.
Failed theorem:
∀(y :β) (s :α -> bool) (f :α -> β). IMAGE f s y ⇔ ∃(x :α). y = f x ∧ x ∈ s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool).
    SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u
proof failed.
Failed theorem:
∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool).
    SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :'z -> 'z). INVOL f ⇒ ∀(a :'z) (b :'z). f a = f b ⇔ a = b
proof failed.
Failed theorem:
∀(f :'z -> 'z). INVOL f ⇒ ∀(a :'z) (b :'z). f a = f b ⇔ a = b
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list) (l3 :α list). l1 ⧺ (l2 ⧺ l3) = l1 ⧺ l2 ⧺ l3
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list) (l3 :α list). l1 ⧺ (l2 ⧺ l3) = l1 ⧺ l2 ⧺ l3
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
$OLEAST (P :num -> bool) = (NONE :num option) ⇔ ∀(n :num). ¬P n
proof failed.
Failed theorem:
$OLEAST (P :num -> bool) = (NONE :num option) ⇔ ∀(n :num). ¬P n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l1 :α list) (l2 :α list).
    DROP n (l1 ⧺ l2) = DROP n l1 ⧺ DROP (n − LENGTH l1) l2
proof failed.
Failed theorem:
∀(n :num) (l1 :α list) (l2 :α list).
    DROP n (l1 ⧺ l2) = DROP n l1 ⧺ DROP (n − LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(ls :α list) (f :β -> α).
    EVERY (λ(x :α). ∃(y :β). x = f y) ls ⇒ ∃(l :β list). ls = MAP f l
proof failed.
Failed theorem:
∀(ls :α list) (f :β -> α).
    EVERY (λ(x :α). ∃(y :β). x = f y) ls ⇒ ∃(l :β list). ls = MAP f l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(opt :α option). (∃(x :α). opt = SOME x) ∨ opt = (NONE :α option)
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.option_nchotomy]
minimized proof:
  metis_tac [optionTheory.option_nchotomy]
SURJ (f :α -> β) (s :α -> bool) (t :β -> bool) ⇒
∃(g :β -> α). INJ g t s ∧ ∀(y :β). y ∈ t ⇒ f (g y) = y
proof failed.
Failed theorem:
SURJ (f :α -> β) (s :α -> bool) (t :β -> bool) ⇒
∃(g :β -> α). INJ g t s ∧ ∀(y :β). y ∈ t ⇒ f (g y) = y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> α -> bool) (x :α) (y :α) (z :α). R꙳ x y ∧ R y z ⇒ R⁺ x z
proof failed.
Failed theorem:
∀(R :α -> α -> bool) (x :α) (y :α) (z :α). R꙳ x y ∧ R y z ⇒ R⁺ x z
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (s :α -> bool) (t :β -> bool).
    INJ f s t ∧ INFINITE s ⇒ INFINITE t
proof failed.
Failed theorem:
∀(f :α -> β) (s :α -> bool) (t :β -> bool).
    INJ f s t ∧ INFINITE s ⇒ INFINITE t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x1 :α) (l1 :α list) (x2 :α) (l2 :α list).
    SNOC x1 l1 = SNOC x2 l2 ⇒ LENGTH l1 = LENGTH l2
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FRONT_SNOC]
minimized proof:
  metis_tac [listTheory.FRONT_SNOC]
∀(x :α) (l :α list).
    TL (SNOC x l) = if NULL l then ([] :α list) else SNOC x (TL l)
proof failed.
Failed theorem:
∀(x :α) (l :α list).
    TL (SNOC x l) = if NULL l then ([] :α list) else SNOC x (TL l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α list -> bool) (n :num).
    (∀(l :α list). LENGTH l = SUC n ⇒ P l) ⇔
    ∀(l :α list). LENGTH l = n ⇒ (λ(l :α list). ∀(x :α). P (x::l)) l
proof failed.
Failed theorem:
∀(P :α list -> bool) (n :num).
    (∀(l :α list). LENGTH l = SUC n ⇒ P l) ⇔
    ∀(l :α list). LENGTH l = n ⇒ (λ(l :α list). ∀(x :α). P (x::l)) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(x :α) ∈ RDOM (RRESTRICT (R :α -> β -> bool) (s :α -> bool)) ⇔
x ∈ RDOM R ∧ x ∈ s
proof failed.
Failed theorem:
(x :α) ∈ RDOM (RRESTRICT (R :α -> β -> bool) (s :α -> bool)) ⇔
x ∈ RDOM R ∧ x ∈ s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (l :α list). FRONT (SNOC x l) = l
proof failed.
Failed theorem:
∀(x :α) (l :α list). FRONT (SNOC x l) = l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list) (x :α). MEM x (REVERSE l) ⇔ MEM x l
proof failed.
Failed theorem:
∀(l :α list) (x :α). MEM x (REVERSE l) ⇔ MEM x l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list). NULL l ⇔ FOLDL (λ(x :bool) (l' :α). F) T l
proof failed.
Failed theorem:
∀(l :α list). NULL l ⇔ FOLDL (λ(x :bool) (l' :α). F) T l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list) (m :num) (x :α). MEM x (DROP m l) ⇒ MEM x l
proof failed.
Failed theorem:
∀(l :α list) (m :num) (x :α). MEM x (DROP m l) ⇒ MEM x l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α + β). ISR x ⇒ (INR (OUTR x) :α + β) = x
proof failed.
Failed theorem:
∀(x :α + β). ISR x ⇒ (INR (OUTR x) :α + β) = x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(([(f :β -> α)] <*> (l :β list)) :α list) = MAP f l
proof failed.
Failed theorem:
(([(f :β -> α)] <*> (l :β list)) :α list) = MAP f l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (x :α). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
proof failed.
Failed theorem:
∀(n :num) (x :α). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (x :α) (y :α). x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}
proof failed.
Failed theorem:
∀(s :α -> bool) (x :α) (y :α). x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l1 :α list) (l2 :α list).
    l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2
proof failed.
Failed theorem:
∀(n :num) (l1 :α list) (l2 :α list).
    l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> α -> bool). reflexive (RC R)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , relationTheory.RC_DEF , relationTheory.reflexive_def]
minimized proof:
  metis_tac [relationTheory.RC_DEF, relationTheory.reflexive_def]
(R1 :γ -> β -> bool) ∘ᵣ (R2 :δ -> γ -> bool) ∘ᵣ (R3 :α -> δ -> bool) =
(R1 ∘ᵣ R2) ∘ᵣ R3
proof failed.
Failed theorem:
(R1 :γ -> β -> bool) ∘ᵣ (R2 :δ -> γ -> bool) ∘ᵣ (R3 :α -> δ -> bool) =
(R1 ∘ᵣ R2) ∘ᵣ R3
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num).
    (0 :num) < n ⇒ ∀(x :α) (l :α list). ELL n (SNOC x l) = ELL (PRE n) l
proof failed.
Failed theorem:
∀(n :num).
    (0 :num) < n ⇒ ∀(x :α) (l :α list). ELL n (SNOC x l) = ELL (PRE n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list).
    ALL_DISTINCT (l1 ⧺ l2) ⇔
    ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀(e :α). MEM e l1 ⇒ ¬MEM e l2
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list).
    ALL_DISTINCT (l1 ⧺ l2) ⇔
    ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀(e :α). MEM e l1 ⇒ ¬MEM e l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list). l ≠ ([] :α list) ⇒ BUTLASTN (1 :num) l = FRONT l
proof found by vampire:
  metisTools.METIS_TAC [arithmeticTheory.ONE , listTheory.APPEND_FRONT_LAST , listTheory.LENGTH , rich_listTheory.BUTLASTN_LENGTH_APPEND]
minimized proof:
  metis_tac [arithmeticTheory.ONE, listTheory.APPEND_FRONT_LAST, listTheory.LENGTH, rich_listTheory.BUTLASTN_LENGTH_APPEND]
∀(s :α -> bool) (t :α -> bool). BIGUNION {s; t} = s ∪ t
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool). BIGUNION {s; t} = s ∪ t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l2 :α list) (l1 :α list). ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ⧺ l2) = HD l2
proof failed.
Failed theorem:
∀(l2 :α list) (l1 :α list). ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ⧺ l2) = HD l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
reflexive ((R1 :α -> α -> bool) LEX (R2 :β -> β -> bool)) ⇔
reflexive R1 ∨ reflexive R2
proof failed.
Failed theorem:
reflexive ((R1 :α -> α -> bool) LEX (R2 :β -> β -> bool)) ⇔
reflexive R1 ∨ reflexive R2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INJ (f :α -> β) (s :α -> bool) (IMAGE f s) ⇒
(countable (IMAGE f s) ⇔ countable s)
proof failed.
Failed theorem:
INJ (f :α -> β) (s :α -> bool) (IMAGE f s) ⇒
(countable (IMAGE f s) ⇔ countable s)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP (f :β -> α) (LIST_BIND (l :γ list) (g :γ -> β list)) =
LIST_BIND l (MAP f ∘ g)
proof failed.
Failed theorem:
MAP (f :β -> α) (LIST_BIND (l :γ list) (g :γ -> β list)) =
LIST_BIND l (MAP f ∘ g)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)
proof failed.
Failed theorem:
FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(A :bool) (B :bool) (C :bool). A ∧ B ⇒ C ⇔ A ⇒ B ⇒ C
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP (SND :β # α -> α)
  (FILTER (λ((x :β),(y :α)). y ≠ (z :α)) (ls :(β # α) list)) =
FILTER (λ(y :α). z ≠ y) (MAP (SND :β # α -> α) ls)
proof failed.
Failed theorem:
MAP (SND :β # α -> α)
  (FILTER (λ((x :β),(y :α)). y ≠ (z :α)) (ls :(β # α) list)) =
FILTER (λ(y :α). z ≠ y) (MAP (SND :β # α -> α) ls)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REPLICATE (n :num) (a :α) ⧺ REPLICATE (m :num) a = REPLICATE (n + m) a
proof failed.
Failed theorem:
REPLICATE (n :num) (a :α) ⧺ REPLICATE (m :num) a = REPLICATE (n + m) a
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(b :bool). ¬b ⇒ (b ⇔ F)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
∀(x :α) (y :β) (a :α) (b :β). (x,y) = (a,b) ⇔ x = a ∧ y = b
proof found by vampire:
  metisTools.METIS_TAC [pairTheory.PAIR_EQ]
minimized proof:
  metis_tac [pairTheory.PAIR_EQ]
∀(f :α -> β) (n :num) (x :α). MAP f (REPLICATE n x) = REPLICATE n (f x)
proof failed.
Failed theorem:
∀(f :α -> β) (n :num) (x :α). MAP f (REPLICATE n x) = REPLICATE n (f x)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list).
    n < LENGTH l ⇒ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
proof failed.
Failed theorem:
∀(n :num) (l :α list).
    n < LENGTH l ⇒ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_COND_EX (i :α) (p :β -> α) (g :β -> bool) ⇒
PMATCH_ROW p g (r :β -> γ) i = SOME (r (@(x :β). PMATCH_ROW_COND p g i x))
proof failed.
Failed theorem:
PMATCH_ROW_COND_EX (i :α) (p :β -> α) (g :β -> bool) ⇒
PMATCH_ROW p g (r :β -> γ) i = SOME (r (@(x :β). PMATCH_ROW_COND p g i x))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R1 :α -> α -> bool) (R2 :α -> α -> bool) (x :α) (y :α).
    (R1 ∩ᵣ R2)꙳ x y ⇒ (R1꙳ ∩ᵣ R2꙳) x y
proof failed.
Failed theorem:
∀(R1 :α -> α -> bool) (R2 :α -> α -> bool) (x :α) (y :α).
    (R1 ∩ᵣ R2)꙳ x y ⇒ (R1꙳ ∩ᵣ R2꙳) x y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α -> bool) (a :α) (s :α -> bool).
    (∃(x :α). x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃(x :α). x ∈ s ∧ P x
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.COMPONENT , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
∀(f :α -> γ) (g :β -> δ) (z :α + β).
    SUM_MAP f g z =
    if ISL z then (INL (f (OUTL z)) :γ + δ) else (INR (g (OUTR z)) :γ + δ)
proof failed.
Failed theorem:
∀(f :α -> γ) (g :β -> δ) (z :α + β).
    SUM_MAP f g z =
    if ISL z then (INL (f (OUTL z)) :γ + δ) else (INR (g (OUTR z)) :γ + δ)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list list).
    REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :α list -> α list) l))
proof failed.
Failed theorem:
∀(l :α list list).
    REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :α list -> α list) l))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f1 :α -> β) (f2 :α -> β) (l :α list).
    MAP f1 l = MAP f2 l ⇔ ∀(e :α). MEM e l ⇒ f1 e = f2 e
proof failed.
Failed theorem:
∀(f1 :α -> β) (f2 :α -> β) (l :α list).
    MAP f1 l = MAP f2 l ⇔ ∀(e :α). MEM e l ⇒ f1 e = f2 e
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
($= :α -> α -> bool)ᵀ = ($= :α -> α -> bool)
proof failed.
Failed theorem:
($= :α -> α -> bool)ᵀ = ($= :α -> α -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list).
    n < LENGTH l ⇒ ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l
proof failed.
Failed theorem:
∀(n :num) (l :α list).
    n < LENGTH l ⇒ ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (s :α -> bool). (∅ :α -> bool) ≠ x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.NOT_INSERT_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.NOT_INSERT_EMPTY]
(¬SHORTLEX (R :α -> α -> bool) ([] :α list) ([] :α list) ∧
 ¬SHORTLEX R ((h1 :α)::(t1 :α list)) ([] :α list)) ∧
SHORTLEX R ([] :α list) ((h2 :α)::(t2 :α list)) ∧
(SHORTLEX R (h1::t1) (h2::t2) ⇔
 LENGTH t1 < LENGTH t2 ∨
 LENGTH t1 = LENGTH t2 ∧ (R h1 h2 ∨ h1 = h2 ∧ SHORTLEX R t1 t2))
proof failed.
Failed theorem:
(¬SHORTLEX (R :α -> α -> bool) ([] :α list) ([] :α list) ∧
 ¬SHORTLEX R ((h1 :α)::(t1 :α list)) ([] :α list)) ∧
SHORTLEX R ([] :α list) ((h2 :α)::(t2 :α list)) ∧
(SHORTLEX R (h1::t1) (h2::t2) ⇔
 LENGTH t1 < LENGTH t2 ∨
 LENGTH t1 = LENGTH t2 ∧ (R h1 h2 ∨ h1 = h2 ∧ SHORTLEX R t1 t2))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(v :α). PMATCH_IS_EXHAUSTIVE v ([] :(α -> β option) list) ⇔ F) ∧
∀(v :γ) (r :γ -> δ option) (rs :(γ -> δ option) list).
    PMATCH_IS_EXHAUSTIVE v (r::rs) ⇔
    r v ≠ (NONE :δ option) ∨ PMATCH_IS_EXHAUSTIVE v rs
proof failed.
Failed theorem:
(∀(v :α). PMATCH_IS_EXHAUSTIVE v ([] :(α -> β option) list) ⇔ F) ∧
∀(v :γ) (r :γ -> δ option) (rs :(γ -> δ option) list).
    PMATCH_IS_EXHAUSTIVE v (r::rs) ⇔
    r v ≠ (NONE :δ option) ∨ PMATCH_IS_EXHAUSTIVE v rs
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(s :α -> bool). 𝕌(:α) ∩ s = s) ∧ ∀(s :α -> bool). s ∩ 𝕌(:α) = s
proof failed.
Failed theorem:
(∀(s :α -> bool). 𝕌(:α) ∩ s = s) ∧ ∀(s :α -> bool). s ∩ 𝕌(:α) = s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (s :α -> bool) (t :β -> bool).
    BIJ f s t ⇔ f ∈ FUNSET s t ∧ ∀(y :β). y ∈ t ⇒ ∃!(x :α). x ∈ s ∧ y = f x
proof failed.
Failed theorem:
∀(f :α -> β) (s :α -> bool) (t :β -> bool).
    BIJ f s t ⇔ f ∈ FUNSET s t ∧ ∀(y :β). y ∈ t ⇒ ∃!(x :α). x ∈ s ∧ y = f x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l
proof failed.
Failed theorem:
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l2 :α list) (l1 :α list). IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1
proof failed.
Failed theorem:
∀(l2 :α list) (l1 :α list). IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (x :α) (y :α). x ∈ s DELETE y ⇔ x ∈ s ∧ x ≠ y
proof failed.
Failed theorem:
∀(s :α -> bool) (x :α) (y :α). x ∈ s DELETE y ⇔ x ∈ s ∧ x ≠ y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(ls :α list) (n :num).
    n ≤ LENGTH ls ⇒ REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls − n) ls)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , rich_listTheory.DROP_LASTN]
minimized proof:
  metis_tac [rich_listTheory.DROP_LASTN]
∀(f :α -> β). PREIMAGE f (∅ :β -> bool) = (∅ :α -> bool)
proof failed.
Failed theorem:
∀(f :α -> β). PREIMAGE f (∅ :β -> bool) = (∅ :α -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (l :α list). MAP f (REVERSE l) = REVERSE (MAP f l)
proof failed.
Failed theorem:
∀(f :α -> β) (l :α list). MAP f (REVERSE l) = REVERSE (MAP f l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool) (x :α). (s ∪ t) x ⇔ x ∈ s ∨ x ∈ t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_UNION]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_UNION]
∀(n :num). LENGTH (COUNT_LIST n) = n
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LENGTH_GENLIST , rich_listTheory.COUNT_LIST_GENLIST]
minimized proof:
  metis_tac [listTheory.LENGTH_GENLIST, rich_listTheory.COUNT_LIST_GENLIST]
(∃(p :α # β). (P :α # β -> bool) p) ⇔ ∃(p_1 :α) (p_2 :β). P (p_1,p_2)
proof failed.
Failed theorem:
(∃(p :α # β). (P :α # β -> bool) p) ⇔ ∃(p_1 :α) (p_2 :β). P (p_1,p_2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list).
    l1 ⧺ l2 = FOLDR (CONS :α -> α list -> α list) l2 l1
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list).
    l1 ⧺ l2 = FOLDR (CONS :α -> α list -> α list) l2 l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (x :α). COMPL (x INSERT s) = COMPL s DELETE x
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.COMPL_DEF , pred_setTheory.DELETE_INTER , pred_setTheory.DIFF_INSERT , pred_setTheory.DIFF_INTER_COMPL]
minimized proof:
  metis_tac [pred_setTheory.COMPL_DEF, pred_setTheory.DELETE_INTER, pred_setTheory.DIFF_INSERT, pred_setTheory.DIFF_INTER_COMPL]
∀(t :bool). t ⇒ T ⇔ T
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
countable (∅ :α -> bool)
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.FINITE_EMPTY , pred_setTheory.finite_countable]
minimized proof:
  metis_tac [pred_setTheory.FINITE_EMPTY, pred_setTheory.finite_countable]
∀(R :α -> α -> bool). Order R ⇔ StrongOrder (STRORD R)
proof failed.
Failed theorem:
∀(R :α -> α -> bool). Order R ⇔ StrongOrder (STRORD R)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :bool) (x' :bool) (y :bool) (y' :bool).
    (x ⇒ y ⇒ y') ∧ (¬y' ⇒ x' ⇒ x) ⇒ (x ⇒ y) ⇒ x' ⇒ y'
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(x :α list) ≼ (y :α)::(ys :α list) ⇔
x = ([] :α list) ∨ ∃(xs :α list). x = y::xs ∧ xs ≼ ys
proof failed.
Failed theorem:
(x :α list) ≼ (y :α)::(ys :α list) ⇔
x = ([] :α list) ∨ ∃(xs :α list). x = y::xs ∧ xs ≼ ys
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α -> bool) (l :α list) (m :num). EVERY P l ⇒ EVERY P (TAKE m l)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , listTheory.EVERY_APPEND , listTheory.TAKE_DROP]
minimized proof:
  metis_tac [listTheory.EVERY_APPEND, listTheory.TAKE_DROP]
IS_SOME (OPTION_BIND (x :α option) (g :α -> β option)) ⇒ IS_SOME x
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_SOME_DEF , optionTheory.NOT_IS_SOME_EQ_NONE , optionTheory.OPTION_BIND_def]
minimized proof:
  metis_tac [optionTheory.NOT_IS_SOME_EQ_NONE, optionTheory.OPTION_BIND_def]
(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ (Q :α -> α -> bool) x y) ⇒
R꙳ (x :α) (y :α) ⇒
Q꙳ x y
proof failed.
Failed theorem:
(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ (Q :α -> α -> bool) x y) ⇒
R꙳ (x :α) (y :α) ⇒
Q꙳ x y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α list). x ≼ x
proof failed.
Failed theorem:
∀(x :α list). x ≼ x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
count (0 :num) = (∅ :num -> bool)
proof failed.
Failed theorem:
count (0 :num) = (∅ :num -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(x :α). (P :α -> bool) x ⇒ (Q :α -> bool) x) ⇒
EXISTS P (l :α list) ⇒
EXISTS Q l
proof failed.
Failed theorem:
(∀(x :α). (P :α -> bool) x ⇒ (Q :α -> bool) x) ⇒
EXISTS P (l :α list) ⇒
EXISTS Q l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool). s ⊆ t ⇒ s ∩ t = s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_INTER_ABSORPTION]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_INTER_ABSORPTION]
∀(R :α -> α -> bool) (x :α) (y :α). R x y ⇒ R⁺ x y
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , relationTheory.TC_DEF]
minimized proof:
  metis_tac [relationTheory.TC_DEF]
∀(xs :α list). FILTER (λ(x :α). T) xs = xs
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_ID]
proof failed.
Failed theorem:
∀(xs :α list). FILTER (λ(x :α). T) xs = xs
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). (λ(x :α). x) PERMUTES s
proof failed.
Failed theorem:
∀(s :α -> bool). (λ(x :α). x) PERMUTES s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (n :num).
    LENGTH l1 ≤ n ⇒
    ∀(l2 :α list). TAKE n (l1 ⧺ l2) = l1 ⧺ TAKE (n − LENGTH l1) l2
proof failed.
Failed theorem:
∀(l1 :α list) (n :num).
    LENGTH l1 ≤ n ⇒
    ∀(l2 :α list). TAKE n (l1 ⧺ l2) = l1 ⧺ TAKE (n − LENGTH l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). INFINITE s ⇒ ∀(t :α -> bool). s ⊆ t ⇒ INFINITE t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_FINITE]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_FINITE]
(option_CASE (NONE :α option) :β -> (α -> β) -> β) = (λ(v :β) (f :α -> β). v) ∧
(option_CASE (SOME (x :α)) :β -> (α -> β) -> β) = (λ(v :β) (f :α -> β). f x)
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.option_case_def]
minimized proof:
  metis_tac [optionTheory.option_case_def]
∀(t :bool). t ⇒ F ⇔ ¬t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f1 :α -> bool) (f2 :α -> bool) (l :α list).
    FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
proof failed.
Failed theorem:
∀(f1 :α -> bool) (f2 :α -> bool) (l :α list).
    FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (P :α -> bool) (Q :β -> bool).
    FUNSET P Q f ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q
proof failed.
Failed theorem:
∀(f :α -> β) (P :α -> bool) (Q :β -> bool).
    FUNSET P Q f ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
𝕌(:α + β) = IMAGE (INL :α -> α + β) 𝕌(:α) ∪ IMAGE (INR :β -> α + β) 𝕌(:β)
proof failed.
Failed theorem:
𝕌(:α + β) = IMAGE (INL :α -> α + β) 𝕌(:α) ∪ IMAGE (INR :β -> α + β) 𝕌(:β)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (s :α -> bool). s ⊆ x INSERT s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.DELETE_SUBSET , pred_setTheory.SUBSET_INSERT_DELETE]
minimized proof:
  metis_tac [pred_setTheory.DELETE_SUBSET, pred_setTheory.SUBSET_INSERT_DELETE]
∀(l :α list) (x :α). l ≠ x::l ∧ x::l ≠ l
proof failed.
Failed theorem:
∀(l :α list) (x :α). l ≠ x::l ∧ x::l ≠ l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_SET (∅ :num -> bool) = (1 :num) ∧
∀(x :num) (s :num -> bool).
    FINITE s ⇒ PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
proof failed.
Failed theorem:
PROD_SET (∅ :num -> bool) = (1 :num) ∧
∀(x :num) (s :num -> bool).
    FINITE s ⇒ PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (s :β -> bool) (x :α). PREIMAGE f s x ⇔ f x ∈ s
proof failed.
Failed theorem:
∀(f :α -> β) (s :β -> bool) (x :α). PREIMAGE f s x ⇔ f x ∈ s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β -> β) (e :β) (l1 :α list) (l2 :α list).
    FOLDR f e (l1 ⧺ l2) = FOLDR f (FOLDR f e l2) l1
proof failed.
Failed theorem:
∀(f :α -> β -> β) (e :β) (l1 :α list) (l2 :α list).
    FOLDR f e (l1 ⧺ l2) = FOLDR f (FOLDR f e l2) l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ DROP n l = LASTN (LENGTH l − n) l
proof failed.
Failed theorem:
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ DROP n l = LASTN (LENGTH l − n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ LENGTH (TAKE n l) = n
proof failed.
Failed theorem:
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ LENGTH (TAKE n l) = n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(0 :num) < (n :num) ⇒ DROP n ((x :α)::(xs :α list)) = DROP (n − (1 :num)) xs
proof failed.
Failed theorem:
(0 :num) < (n :num) ⇒ DROP n ((x :α)::(xs :α list)) = DROP (n − (1 :num)) xs
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :bool list). AND_EL l ⇔ FOLDL $/\ T l
proof failed.
Failed theorem:
∀(l :bool list). AND_EL l ⇔ FOLDL $/\ T l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α -> bool) (l :α list).
    FILTER P l = ([] :α list) ⇔ EVERY (λ(x :α). ¬P x) l
proof failed.
Failed theorem:
∀(P :α -> bool) (l :α list).
    FILTER P l = ([] :α list) ⇔ EVERY (λ(x :α). ¬P x) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(v :α) (rows :(α -> β option) list) (p :bool) (infos :bool list).
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ⇔
    p ∧ EVERY (λ(r :α -> β option). r v = (NONE :β option)) rows
proof failed.
Failed theorem:
∀(v :α) (rows :(α -> β option) list) (p :bool) (infos :bool list).
    FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ⇔
    p ∧ EVERY (λ(r :α -> β option). r v = (NONE :β option)) rows
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). s ∩ s = s
proof failed.
Failed theorem:
∀(s :α -> bool). s ∩ s = s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α -> bool) (y :α -> bool) (z :α -> bool).
    x DIFF y DIFF z = x DIFF z DIFF y
proof failed.
Failed theorem:
∀(x :α -> bool) (y :α -> bool) (z :α -> bool).
    x DIFF y DIFF z = x DIFF z DIFF y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool).
    (c ⇒ x' ⇒ x) ∧ (¬c ⇒ y' ⇒ y) ⇒
    (if c then x' else y') ⇒
    if c then x else y
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_OR , boolTheory.COND_RAND , boolTheory.EQ_CLAUSES , boolTheory.OR_DEF]
minimized proof:
  metis_tac []
∀(x :α). SING {x}
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.SING_DEF]
minimized proof:
  metis_tac [pred_setTheory.SING_DEF]
((a :α),(b :α)) ∈ {(x,x) | (P :α -> bool) x} ⇔ P a ∧ a = b
proof failed.
Failed theorem:
((a :α),(b :α)) ∈ {(x,x) | (P :α -> bool) x} ⇔ P a ∧ a = b
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(M :α list) (M' :α list) (v :β) (f :α -> α list -> β).
    M = M' ∧ (M' = ([] :α list) ⇒ v = (v' :β)) ∧
    (∀(a0 :α) (a1 :α list).
         M' = a0::a1 ⇒ f a0 a1 = (f' :α -> α list -> β) a0 a1) ⇒
    (list_CASE M v f :β) = (list_CASE M' v' f' :β)
proof failed.
Failed theorem:
∀(M :α list) (M' :α list) (v :β) (f :α -> α list -> β).
    M = M' ∧ (M' = ([] :α list) ⇒ v = (v' :β)) ∧
    (∀(a0 :α) (a1 :α list).
         M' = a0::a1 ⇒ f a0 a1 = (f' :α -> α list -> β) a0 a1) ⇒
    (list_CASE M v f :β) = (list_CASE M' v' f' :β)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (l :α list). SNOC x l ≠ ([] :α list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.EVERY_DEF , listTheory.EVERY_SNOC , listTheory.EXISTS_DEF , listTheory.EXISTS_SNOC]
minimized proof:
  metis_tac [listTheory.EVERY_DEF, listTheory.EVERY_SNOC, listTheory.EXISTS_DEF, listTheory.EXISTS_SNOC]
∀(g :α -> α -> α) (f :β -> α -> α).
    FCOMM g f ⇒
    ∀(e :α).
        LEFT_ID g e ⇒
        ∀(l :β list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
proof failed.
Failed theorem:
∀(g :α -> α -> α) (f :β -> α -> α).
    FCOMM g f ⇒
    ∀(e :α).
        LEFT_ID g e ⇒
        ∀(l :β list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(m :num) (n :num). m < SUC n ⇒ m ≠ n ⇒ m < n
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , prim_recTheory.LESS_THM]
minimized proof:
  metis_tac [prim_recTheory.LESS_THM]
∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ⊂ t ∧ t ⊂ u ⇒ s ⊂ u
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ⊂ t ∧ t ⊂ u ⇒ s ⊂ u
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool).
    FINITE s ∧ FINITE t ⇒ CARD (s ∪ t) = CARD s + CARD t − CARD (s ∩ t)
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool).
    FINITE s ∧ FINITE t ⇒ CARD (s ∪ t) = CARD s + CARD t − CARD (s ∩ t)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). 𝕌(:α) ⊆ s ⇔ s = 𝕌(:α)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.SUBSET_ANTISYM , pred_setTheory.SUBSET_UNIV]
minimized proof:
  metis_tac [pred_setTheory.SUBSET_ANTISYM, pred_setTheory.SUBSET_UNIV]
∀(v :α) (rows :(α -> β option) list) (p :bool) (infos :bool list).
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
proof failed.
Failed theorem:
∀(v :α) (rows :(α -> β option) list) (p :bool) (infos :bool list).
    LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) =
    LENGTH rows + LENGTH infos
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
LIST_REL (R :α -> β -> bool) (xs :α list) ((h :β)::(t :β list)) ⇔
∃(h' :α) (t' :α list). xs = h'::t' ∧ R h' h ∧ LIST_REL R t' t
proof failed.
Failed theorem:
LIST_REL (R :α -> β -> bool) (xs :α list) ((h :β)::(t :β list)) ⇔
∃(h' :α) (t' :α list). xs = h'::t' ∧ R h' h ∧ LIST_REL R t' t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(x :α) (y :α). (P :α -> bool) x ∧ (R :α -> α -> bool) x y ⇒ P y) ⇒
∀(x :α) (y :α). P x ∧ R꙳ x y ⇒ P y
proof failed.
Failed theorem:
(∀(x :α) (y :α). (P :α -> bool) x ∧ (R :α -> α -> bool) x y ⇒ P y) ⇒
∀(x :α) (y :α). P x ∧ R꙳ x y ⇒ P y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
((p :bool) ⇔ if (q :bool) then (r :bool) else (s :bool)) ⇔
(p ∨ q ∨ ¬s) ∧ (p ∨ ¬r ∨ ¬q) ∧ (p ∨ ¬r ∨ ¬s) ∧ (¬q ∨ r ∨ ¬p) ∧ (q ∨ s ∨ ¬p)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.COND_EXPAND_OR , boolTheory.COND_RAND , boolTheory.EQ_CLAUSES , boolTheory.MONO_COND]
minimized proof:
  metis_tac []
∀(s :α -> bool) (x :α). x ∈ s ⇔ ∃(t :α -> bool). s = x INSERT t ∧ x ∉ t
proof failed.
Failed theorem:
∀(s :α -> bool) (x :α). x ∈ s ⇔ ∃(t :α -> bool). s = x INSERT t ∧ x ∉ t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PMATCH_ROW_REDUNDANT (v :α) ((r :α -> β option)::(rs :(α -> β option) list))
  (0 :num) ⇔ r v = (NONE :β option)
proof failed.
Failed theorem:
PMATCH_ROW_REDUNDANT (v :α) ((r :α -> β option)::(rs :(α -> β option) list))
  (0 :num) ⇔ r v = (NONE :β option)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool). DISJOINT t (s DIFF t) ∧ DISJOINT (s DIFF t) t
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool). DISJOINT t (s DIFF t) ∧ DISJOINT (s DIFF t) t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β -> bool) (s :α -> bool) (y :β).
    y ∈ BIGUNION (IMAGE f s) ⇔ ∃(x :α). x ∈ s ∧ y ∈ f x
proof failed.
Failed theorem:
∀(f :α -> β -> bool) (s :α -> bool) (y :β).
    y ∈ BIGUNION (IMAGE f s) ⇔ ∃(x :α). x ∈ s ∧ y ∈ f x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(e :α). LIST_ELEM_COUNT e ([] :α list) = (0 :num)) ∧
(∀(e :β) (l1 :β list) (l2 :β list).
     LIST_ELEM_COUNT e (l1 ⧺ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧
(∀(e :γ) (h :γ) (l :γ list).
     h = e ⇒ LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ∧
∀(e :δ) (h :δ) (l :δ list).
    h ≠ e ⇒ LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
proof failed.
Failed theorem:
(∀(e :α). LIST_ELEM_COUNT e ([] :α list) = (0 :num)) ∧
(∀(e :β) (l1 :β list) (l2 :β list).
     LIST_ELEM_COUNT e (l1 ⧺ l2) =
     LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧
(∀(e :γ) (h :γ) (l :γ list).
     h = e ⇒ LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ∧
∀(e :δ) (h :δ) (l :δ list).
    h ≠ e ⇒ LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool) (x :α). (s ∩ t) x ⇔ x ∈ s ∧ x ∈ t
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.IN_INTER]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.IN_INTER]
∀(P :α -> bool) (l1 :α list) (l2 :α list).
    EXISTS P (l1 ⧺ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
proof failed.
Failed theorem:
∀(P :α -> bool) (l1 :α list) (l2 :α list).
    EXISTS P (l1 ⧺ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(ls :α list) (f :α # α -> β).
    MAP f (ZIP (ls,ls)) = MAP (λ(x :α). f (x,x)) ls
proof failed.
Failed theorem:
∀(ls :α list) (f :α # α -> β).
    MAP f (ZIP (ls,ls)) = MAP (λ(x :α). f (x,x)) ls
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
MAP (f :α -> β) (l :α list) = (h :β)::(t :β list) ⇔
∃(x0 :α) (t0 :α list). l = x0::t0 ∧ h = f x0 ∧ t = MAP f t0
proof failed.
Failed theorem:
MAP (f :α -> β) (l :α list) = (h :β)::(t :β list) ⇔
∃(x0 :α) (t0 :α list). l = x0::t0 ∧ h = f x0 ∧ t = MAP f t0
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> α -> bool). symmetric R ⇒ SC R = R
proof failed.
Failed theorem:
∀(R :α -> α -> bool). symmetric R ⇒ SC R = R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list).
    SHORTLEX (R :α -> α -> bool) l1 l2 ⇒ LENGTH l1 ≤ LENGTH l2
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list).
    SHORTLEX (R :α -> α -> bool) l1 l2 ⇒ LENGTH l1 ≤ LENGTH l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :β -> α -> β) (e :β) (x :α) (l :α list).
    FOLDL f e (SNOC x l) = f (FOLDL f e l) x
proof failed.
Failed theorem:
∀(f :β -> α -> β) (e :β) (x :α) (l :α list).
    FOLDL f e (SNOC x l) = f (FOLDL f e l) x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :(α -> bool) -> bool).
    P (∅ :α -> bool) ∧
    (∀(s :α -> bool). FINITE s ∧ P s ⇒ ∀(e :α). e ∉ s ⇒ P (e INSERT s)) ⇒
    ∀(s :α -> bool). FINITE s ⇒ P s
proof failed.
Failed theorem:
∀(P :(α -> bool) -> bool).
    P (∅ :α -> bool) ∧
    (∀(s :α -> bool). FINITE s ∧ P s ⇒ ∀(e :α). e ∉ s ⇒ P (e INSERT s)) ⇒
    ∀(s :α -> bool). FINITE s ⇒ P s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). FINITE s ⇒ FINITE (REST s)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.FINITE_DELETE , pred_setTheory.REST_DEF]
minimized proof:
  metis_tac [pred_setTheory.FINITE_DELETE, pred_setTheory.REST_DEF]
∀(s :α -> bool). FINITE s ⇒ ∃(f :num -> α) (b :num). BIJ f (count b) s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , pred_setTheory.FINITE_BIJ_COUNT_EQ]
minimized proof:
  metis_tac [pred_setTheory.FINITE_BIJ_COUNT_EQ]
∀(P :α -> bool) (l1 :α list) (l2 :α list).
    EVERY P l1 ⇒ dropWhile P (l1 ⧺ l2) = dropWhile P l2
proof failed.
Failed theorem:
∀(P :α -> bool) (l1 :α list) (l2 :α list).
    EVERY P l1 ⇒ dropWhile P (l1 ⧺ l2) = dropWhile P l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(OPTION_IGNORE_BIND (m1 :α option) (m2 :β option) = (NONE :β option) ⇔
 m1 = (NONE :α option) ∨ m2 = (NONE :β option)) ∧
(OPTION_IGNORE_BIND m1 m2 = SOME (y :β) ⇔ ∃(x :α). m1 = SOME x ∧ m2 = SOME y)
proof failed.
Failed theorem:
(OPTION_IGNORE_BIND (m1 :α option) (m2 :β option) = (NONE :β option) ⇔
 m1 = (NONE :α option) ∨ m2 = (NONE :β option)) ∧
(OPTION_IGNORE_BIND m1 m2 = SOME (y :β) ⇔ ∃(x :α). m1 = SOME x ∧ m2 = SOME y)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α -> bool) (l :α list). EVERY P l ⇔ ¬EXISTS (λ(x :α). ¬P x) l
proof failed.
Failed theorem:
∀(P :α -> bool) (l :α list). EVERY P l ⇔ ¬EXISTS (λ(x :α). ¬P x) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). s = 𝕌(:α) ⇒ ∀(v :α). v ∈ s
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
∀(n :num). SUC (m :num) = n ⇒ m < n
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , prim_recTheory.LESS_SUC_REFL]
minimized proof:
  metis_tac [prim_recTheory.LESS_SUC_REFL]
((if (P :bool) then SOME (x :α) else (NONE :α option)) = (NONE :α option) ⇔
 ¬P) ∧ ((if P then (NONE :α option) else SOME x) = (NONE :α option) ⇔ P) ∧
((if P then SOME x else (NONE :α option)) = SOME (y :α) ⇔ P ∧ x = y) ∧
((if P then (NONE :α option) else SOME x) = SOME y ⇔ ¬P ∧ x = y)
proof failed.
Failed theorem:
((if (P :bool) then SOME (x :α) else (NONE :α option)) = (NONE :α option) ⇔
 ¬P) ∧ ((if P then (NONE :α option) else SOME x) = (NONE :α option) ⇔ P) ∧
((if P then SOME x else (NONE :α option)) = SOME (y :α) ⇔ P ∧ x = y) ∧
((if P then (NONE :α option) else SOME x) = SOME y ⇔ ¬P ∧ x = y)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some(x :bool). x) = SOME T
proof failed.
Failed theorem:
(some(x :bool). x) = SOME T
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) ∧
REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list))
  ((i2 :bool)::(is2 :bool list)) =
(i1 ∧ i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
proof failed.
Failed theorem:
REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) ∧
REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list))
  ((i2 :bool)::(is2 :bool list)) =
(i1 ∧ i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)
proof failed.
Failed theorem:
∀(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α recspace) (y :α recspace). dest_rec x = dest_rec y ⇔ x = y
proof found by vampire:
  metisTools.METIS_TAC [ind_typeTheory.recspace_repfns]
minimized proof:
  metis_tac [ind_typeTheory.recspace_repfns]
((R1 :α -> α -> bool) LEX (R2 :β -> β -> bool)) ((a :α),(b :β))
  ((c :α),(d :β)) ⇔ R1 a c ∨ a = c ∧ R2 b d
proof failed.
Failed theorem:
((R1 :α -> α -> bool) LEX (R2 :β -> β -> bool)) ((a :α),(b :β))
  ((c :α),(d :β)) ⇔ R1 a c ∨ a = c ∧ R2 b d
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(l :α list). ([] :α list) ≼ l ⇔ T) ∧
(∀(x :α) (l :α list). x::l ≼ ([] :α list) ⇔ F) ∧
∀(x1 :α) (l1 :α list) (x2 :α) (l2 :α list).
    x2::l2 ≼ x1::l1 ⇔ x1 = x2 ∧ l2 ≼ l1
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , listTheory.isPREFIX_THM]
minimized proof:
  metis_tac [listTheory.isPREFIX_THM]
∀(n :num) (l :α list).
    n ≤ LENGTH l ⇒ DROP n (REVERSE l) = REVERSE (BUTLASTN n l)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.REVERSE_REVERSE , rich_listTheory.BUTLASTN_def]
minimized proof:
  metis_tac [listTheory.REVERSE_REVERSE, rich_listTheory.BUTLASTN_def]
∀(l :α list) (f :α -> β) (x :β). MEM x (MAP f l) ⇔ ∃(y :α). x = f y ∧ MEM y l
proof failed.
Failed theorem:
∀(l :α list) (f :α -> β) (x :β). MEM x (MAP f l) ⇔ ∃(y :α). x = f y ∧ MEM y l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (s :β -> bool) (t :β -> bool).
    s ⊆ t ⇒ PREIMAGE f s ⊆ PREIMAGE f t
proof failed.
Failed theorem:
∀(f :α -> β) (s :β -> bool) (t :β -> bool).
    s ⊆ t ⇒ PREIMAGE f s ⊆ PREIMAGE f t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
PROD_ALL (P :α -> bool) (Q :β -> bool) ((x :α),(y :β)) ⇔ P x ∧ Q y
proof failed.
Failed theorem:
PROD_ALL (P :α -> bool) (Q :β -> bool) ((x :α),(y :β)) ⇔ P x ∧ Q y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> α -> bool) (x :α) (y :α). R⁺ x y ⇒ R꙳ x y
proof failed.
Failed theorem:
∀(R :α -> α -> bool) (x :α) (y :α). R⁺ x y ⇒ R꙳ x y
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l2 :α list) (l1 :α list). BUTLASTN (LENGTH l2) (l1 ⧺ l2) = l1
proof failed.
Failed theorem:
∀(l2 :α list) (l1 :α list). BUTLASTN (LENGTH l2) (l1 ⧺ l2) = l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list). LENGTH l = FOLDR (λ(x :α) (l' :num). SUC l') (0 :num) l
proof failed.
Failed theorem:
∀(l :α list). LENGTH l = FOLDR (λ(x :α) (l' :num). SUC l') (0 :num) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ LASTN n l = DROP (LENGTH l − n) l
proof failed.
Failed theorem:
∀(n :num) (l :α list). n ≤ LENGTH l ⇒ LASTN n l = DROP (LENGTH l − n) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(t :bool). F ∨ t ⇔ t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (s :β -> bool). IMAGE f (PREIMAGE f s) ⊆ s
proof failed.
Failed theorem:
∀(f :α -> β) (s :β -> bool). IMAGE f (PREIMAGE f s) ⊆ s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool). s ⊂ t ⇔ s ⊆ t ∧ ∃(y :α). y ∈ t ∧ y ∉ s
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.BOUNDED_THM , boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.NOT_EQUAL_SETS , pred_setTheory.PSUBSET_DEF , pred_setTheory.PSUBSET_IRREFL , pred_setTheory.SET_EQ_SUBSET , pred_setTheory.SUBSET_applied]
minimized proof:
  metis_tac [IN_DEF, pred_setTheory.PSUBSET_DEF, pred_setTheory.SET_EQ_SUBSET, pred_setTheory.SUBSET_applied]
(R :α -> α -> bool)⁺ (x :α) (z :α) ⇔ R x z ∨ ∃(y :α). R x y ∧ R⁺ y z
proof failed.
Failed theorem:
(R :α -> α -> bool)⁺ (x :α) (z :α) ⇔ R x z ∨ ∃(y :α). R x y ∧ R⁺ y z
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(m :num) (n :num) (l :α list).
    m ≤ n ∧ n ≤ LENGTH l ⇒
    BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l)
proof failed.
Failed theorem:
∀(m :num) (n :num) (l :α list).
    m ≤ n ∧ n ≤ LENGTH l ⇒
    BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (P :α -> bool) (Q :α -> β -> bool).
    f ∈ DFUNSET P Q ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q x
proof failed.
Failed theorem:
∀(f :α -> β) (P :α -> bool) (Q :α -> β -> bool).
    f ∈ DFUNSET P Q ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q x
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∀(x :α). MEM x ([] :α list) ⇔ F) ∧
∀(x :α) (h :α) (t :α list). MEM x (h::t) ⇔ x = h ∨ MEM x t
proof failed.
Failed theorem:
(∀(x :α). MEM x ([] :α list) ⇔ F) ∧
∀(x :α) (h :α) (t :α list). MEM x (h::t) ⇔ x = h ∨ MEM x t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (s :α -> bool). x ∉ s ⇔ s DELETE x = s
proof failed.
Failed theorem:
∀(x :α) (s :α -> bool). x ∉ s ⇔ s DELETE x = s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
((INL (a :α) :α + β) ∈ (A :α -> bool) ⊔ (B :β -> bool) ⇔ a ∈ A) ∧
((INR (b :β) :α + β) ∈ A ⊔ B ⇔ b ∈ B)
proof failed.
Failed theorem:
((INL (a :α) :α + β) ∈ (A :α -> bool) ⊔ (B :β -> bool) ⇔ a ∈ A) ∧
((INR (b :β) :α + β) ∈ A ⊔ B ⇔ b ∈ B)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
WF (λ(x :num) (y :num). y = SUC x)
proof failed.
Failed theorem:
WF (λ(x :num) (y :num). y = SUC x)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(L :num list) (n :num). SUM_ACC L n = SUM L + n
proof failed.
Failed theorem:
∀(L :num list) (n :num). SUM_ACC L n = SUM L + n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
INFINITE 𝕌(:α) ⇔ ∀(s :α -> bool). FINITE s ⇒ s ⊂ 𝕌(:α)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.COND_CLAUSES , boolTheory.EQ_CLAUSES , pred_setTheory.EQ_UNIV , pred_setTheory.FINITE_PSUBSET_INFINITE , pred_setTheory.PSUBSET_UNIV , pred_setTheory.SPECIFICATION]
minimized proof:
  metis_tac [pred_setTheory.EQ_UNIV, pred_setTheory.PSUBSET_UNIV]
∀(f :α -> β).
    (∀(s :β -> bool). INJ f (∅ :α -> bool) s) ∧
    ∀(s :α -> bool). INJ f s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)
proof failed.
Failed theorem:
∀(f :α -> β).
    (∀(s :β -> bool). INJ f (∅ :α -> bool) s) ∧
    ∀(s :α -> bool). INJ f s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list) (f :α -> β).
    (MAP f l = ([] :β list) ⇔ l = ([] :α list)) ∧
    (([] :β list) = MAP f l ⇔ l = ([] :α list))
proof failed.
Failed theorem:
∀(l :α list) (f :α -> β).
    (MAP f l = ([] :β list) ⇔ l = ([] :α list)) ∧
    (([] :β list) = MAP f l ⇔ l = ([] :α list))
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :num list). SUM l = FOLDR $+ (0 :num) l
proof failed.
Failed theorem:
∀(l :num list). SUM l = FOLDR $+ (0 :num) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> β -> bool) (l1 :α list) (l2 :β list) (n :num).
    LIST_REL R l1 l2 ⇒ LIST_REL R (DROP n l1) (DROP n l2)
proof failed.
Failed theorem:
∀(R :α -> β -> bool) (l1 :α list) (l2 :β list) (n :num).
    LIST_REL R l1 l2 ⇒ LIST_REL R (DROP n l1) (DROP n l2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(some(x :α). F) = (NONE :α option)
proof found by vampire:
  metisTools.METIS_TAC [optionTheory.IS_NONE_DEF , optionTheory.IS_NONE_EQ_NONE , optionTheory.some_intro]
proof failed.
Failed theorem:
(some(x :α). F) = (NONE :α option)
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (l1 :α list) (l2 :α list). MAP f (l1 ⧺ l2) = MAP f l1 ⧺ MAP f l2
proof failed.
Failed theorem:
∀(f :α -> β) (l1 :α list) (l2 :α list). MAP f (l1 ⧺ l2) = MAP f l1 ⧺ MAP f l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(g :α -> α -> α) (f :β -> α -> α).
    FCOMM g f ⇒
    ∀(e :α).
        LEFT_ID g e ⇒
        ∀(l1 :β list) (l2 :β list).
            FOLDR f e (l1 ⧺ l2) = g (FOLDR f e l1) (FOLDR f e l2)
proof failed.
Failed theorem:
∀(g :α -> α -> α) (f :β -> α -> α).
    FCOMM g f ⇒
    ∀(e :α).
        LEFT_ID g e ⇒
        ∀(l1 :β list) (l2 :β list).
            FOLDR f e (l1 ⧺ l2) = g (FOLDR f e l1) (FOLDR f e l2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∅ (x :α) ⇔ F
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.EMPTY_DEF]
minimized proof:
  metis_tac [pred_setTheory.EMPTY_DEF]
∀(R :α -> α -> bool).
    WeakLinearOrder R ⇔ WeakOrder R ∧ ∀(a :α) (b :α). R a b ∨ R b a
proof failed.
Failed theorem:
∀(R :α -> α -> bool).
    WeakLinearOrder R ⇔ WeakOrder R ∧ ∀(a :α) (b :α). R a b ∨ R b a
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(R :α -> β -> bool) (R' :γ -> α -> bool). (R ∘ᵣ R')ᵀ = R'ᵀ ∘ᵣ Rᵀ
proof failed.
Failed theorem:
∀(R :α -> β -> bool) (R' :γ -> α -> bool). (R ∘ᵣ R')ᵀ = R'ᵀ ∘ᵣ Rᵀ
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (l :α list). x::l = [x] ⧺ l
proof failed.
Failed theorem:
∀(x :α) (l :α list). x::l = [x] ⧺ l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (l :α list).
    MAP f l = FOLDR (λ(x :α) (l' :β list). f x::l') ([] :β list) l
proof failed.
Failed theorem:
∀(f :α -> β) (l :α list).
    MAP f l = FOLDR (λ(x :α) (l' :β list). f x::l') ([] :β list) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α). x ∈ 𝕌(:α)
proof found by vampire:
  metisTools.METIS_TAC [pred_setTheory.SPECIFICATION , pred_setTheory.UNIV_DEF]
minimized proof:
  metis_tac [pred_setTheory.SPECIFICATION, pred_setTheory.UNIV_DEF]
𝕌(:α + β) = 𝕌(:α) ⊔ 𝕌(:β)
proof failed.
Failed theorem:
𝕌(:α + β) = 𝕌(:α) ⊔ 𝕌(:β)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (t :α -> bool) (g :α -> bool). (s DIFF t) ∩ g = s ∩ g DIFF t
proof failed.
Failed theorem:
∀(s :α -> bool) (t :α -> bool) (g :α -> bool). (s DIFF t) ∩ g = s ∩ g DIFF t
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(Q :num -> bool) (P :num -> bool).
    (∃(n :num). P n) ∧ (∀(n :num). (∀(m :num). m < n ⇒ ¬P m) ∧ P n ⇒ Q n) ⇒
    Q ($LEAST P)
proof failed.
Failed theorem:
∀(Q :num -> bool) (P :num -> bool).
    (∃(n :num). P n) ∧ (∀(n :num). (∀(m :num). m < n ⇒ ¬P m) ∧ P n ⇒ Q n) ⇒
    Q ($LEAST P)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(xs :α list). FILTER (λ(x :α). F) xs = ([] :α list)
proof found by vampire:
  metisTools.METIS_TAC [listTheory.FILTER_NEQ_NIL]
proof failed.
Failed theorem:
∀(xs :α list). FILTER (λ(x :α). F) xs = ([] :α list)
End printing
reconstruction failed
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β) (x :α) (s :α -> bool).
    IMAGE f (x INSERT s) = f x INSERT IMAGE f s
proof failed.
Failed theorem:
∀(f :α -> β) (x :α) (s :α -> bool).
    IMAGE f (x INSERT s) = f x INSERT IMAGE f s
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list). TAKE (LENGTH l1) (l1 ⧺ l2) = l1
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list). TAKE (LENGTH l1) (l1 ⧺ l2) = l1
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list list).
    FLAT l = FOLDR ($++ :α list -> α list -> α list) ([] :α list) l
proof failed.
Failed theorem:
∀(l :α list list).
    FLAT l = FOLDR ($++ :α list -> α list -> α list) ([] :α list) l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(¬LLEX (R :α -> α -> bool) ([] :α list) ([] :α list) ∧
 ¬LLEX R ((h1 :α)::(t1 :α list)) ([] :α list)) ∧
LLEX R ([] :α list) ((h2 :α)::(t2 :α list)) ∧
(LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ h1 = h2 ∧ LLEX R t1 t2)
proof failed.
Failed theorem:
(¬LLEX (R :α -> α -> bool) ([] :α list) ([] :α list) ∧
 ¬LLEX R ((h1 :α)::(t1 :α list)) ([] :α list)) ∧
LLEX R ([] :α list) ((h2 :α)::(t2 :α list)) ∧
(LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ h1 = h2 ∧ LLEX R t1 t2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l :α list). l ⧺ ([] :α list) = l
proof failed.
Failed theorem:
∀(l :α list). l ⧺ ([] :α list) = l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (f :α -> β). f ∈ FUNSET s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)
proof failed.
Failed theorem:
∀(s :α -> bool) (f :α -> β). f ∈ FUNSET s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(b :bool). b ⇒ (b ⇔ T)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES]
minimized proof:
  metis_tac []
∀(l :α list) (x :α). ELL (0 :num) (SNOC x l) = x
proof found by vampire:
  metisTools.METIS_TAC [listTheory.LAST_SNOC , rich_listTheory.ELL]
minimized proof:
  metis_tac [listTheory.LAST_SNOC, rich_listTheory.ELL]
∀(ls :α list).
    ls ≠ ([] :α list) ⇒ MAP (f :α -> β) (FRONT ls) = FRONT (MAP f ls)
proof failed.
Failed theorem:
∀(ls :α list).
    ls ≠ ([] :α list) ⇒ MAP (f :α -> β) (FRONT ls) = FRONT (MAP f ls)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num). (0 :num) < SUC n
proof failed.
Failed theorem:
∀(n :num). (0 :num) < SUC n
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
IMAGE (f :β -> α) (s :β -> bool) = {(z :α)} ⇔
s ≠ (∅ :β -> bool) ∧ ∀(x :β). x ∈ s ⇒ f x = z
proof failed.
Failed theorem:
IMAGE (f :β -> α) (s :β -> bool) = {(z :α)} ⇔
s ≠ (∅ :β -> bool) ∧ ∀(x :β). x ∈ s ⇒ f x = z
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(f :α -> β -> β) (e :β) (l :α list).
    FOLDR f e l = FOLDL (λ(x :β) (y :α). f y x) e (REVERSE l)
proof failed.
Failed theorem:
∀(f :α -> β -> β) (e :β) (l :α list).
    FOLDR f e l = FOLDL (λ(x :β) (y :α). f y x) e (REVERSE l)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(l1 :α list) (l2 :α list) (a :α). IS_SUFFIX l1 l2 ⇒ IS_SUFFIX (a::l1) l2
proof failed.
Failed theorem:
∀(l1 :α list) (l2 :α list) (a :α). IS_SUFFIX l1 l2 ⇒ IS_SUFFIX (a::l1) l2
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(x :α) (P :α -> bool). x ∈ P ⇔ P x
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF]
minimized proof:
  metis_tac [IN_DEF]
∀(R :α -> α -> bool). StrongOrder R ⇒ Order R
proof failed.
Failed theorem:
∀(R :α -> α -> bool). StrongOrder R ⇒ Order R
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(n :num) (l :α list). n < LENGTH l ⇒ MEM (EL n l) l
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , listTheory.MEM_EL]
minimized proof:
  metis_tac [listTheory.MEM_EL]
∀(x :α) (y :α) (P :α -> bool). x ∈ y INSERT P ⇔ x = y ∨ x ≠ y ∧ x ∈ P
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.IN_DEF , pred_setTheory.INSERT_applied , pred_setTheory.IN_INSERT]
minimized proof:
  metis_tac [pred_setTheory.IN_INSERT]
OWHILE (G :α -> bool) (f :α -> α) (s :α) = SOME (s' :α) ⇒ ¬G s'
proof failed.
Failed theorem:
OWHILE (G :α -> bool) (f :α -> α) (s :α) = SOME (s' :α) ⇒ ¬G s'
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
symmetric (R1 :α -> α -> bool) ∧ symmetric (R2 :β -> β -> bool) ⇒
symmetric (R1 LEX R2)
proof failed.
Failed theorem:
symmetric (R1 :α -> α -> bool) ∧ symmetric (R2 :β -> β -> bool) ⇒
symmetric (R1 LEX R2)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(P :α -> bool) (l :α list). PREFIX P l ≼ l
proof failed.
Failed theorem:
∀(P :α -> bool) (l :α list). PREFIX P l ≼ l
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool) (f :α -> β).
    (∃(t :β -> bool). INJ f s t) ⇒ BIJ f s (IMAGE f s)
proof failed.
Failed theorem:
∀(s :α -> bool) (f :α -> β).
    (∃(t :β -> bool). INJ f s t) ⇒ BIJ f s (IMAGE f s)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(s :α -> bool). s DIFF 𝕌(:α) = (∅ :α -> bool)
proof failed.
Failed theorem:
∀(s :α -> bool). s DIFF 𝕌(:α) = (∅ :α -> bool)
End printing
ATPs could not find a proof
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
∀(t :bool). t ∧ t ⇔ t
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
(∃(x :α). x ∈ (s :α -> bool)) ∧ (∀(x :α). x ∈ s ⇒ (P :α -> bool) x) ⇒
P (CHOICE s)
proof found by vampire:
  metisTools.METIS_TAC [boolTheory.EQ_CLAUSES , boolTheory.IN_DEF , pred_setTheory.CHOICE_DEF , pred_setTheory.NOT_IN_EMPTY]
minimized proof:
  metis_tac [pred_setTheory.CHOICE_DEF, pred_setTheory.NOT_IN_EMPTY]
proof found by vampire:
  metisTools.METIS_TAC []
minimized proof:
  metis_tac []
val it = fn: tactic
>
