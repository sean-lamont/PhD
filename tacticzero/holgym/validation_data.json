["\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2286 s \u21d2 s DIFF (s DIFF t) = t", "\u2200(set :\u03b1 -> bool) (e :\u03b1 -> bool). e \u2208 POW set \u21d4 e \u2286 set", "FINITE \ud835\udd4c(:\u03b1 # \u03b2) \u21d4 FINITE \ud835\udd4c(:\u03b1) \u2227 FINITE \ud835\udd4c(:\u03b2)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). FINITE s \u2227 BIJ f s t \u21d2 CARD s = CARD t", "{x | T} = \ud835\udd4c(:\u03b1)", "COMPL (\u2205 :\u03b1 -> bool) = \ud835\udd4c(:\u03b1)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d4 x \u2208 t", "\u2200(s :\u03b1 -> bool). (\u2203(f :num -> \u03b1). BIJ f \ud835\udd4c(:num) s) \u21d2 countable s", "\u2200(a0 :\u03b1) (a1 :\u03b1 list) (a0' :\u03b1) (a1' :\u03b1 list). a0::a1 = a0'::a1' \u21d4 a0 = a0' \u2227 a1 = a1'", "\u2200(s1 :(\u03b1 -> bool) -> bool) (s2 :(\u03b1 -> bool) -> bool). BIGINTER (s1 \u222a s2) = BIGINTER s1 \u2229 BIGINTER s2", "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b3 -> bool) (t :\u03b1 -> bool). s \u00d7 BIGUNION (IMAGE f t) = BIGUNION (IMAGE (\u03bb(n :\u03b1). s \u00d7 f n) t)", "PMATCH_EQUIV_ROWS (v :\u03b1) (rows1 :(\u03b1 -> \u03b2 option) list) (rows2 :(\u03b1 -> \u03b2 option) list) \u21d2 PMATCH v rows1 = PMATCH v rows2", "\u2200(l :\u03b1 list) (x :\u03b1). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 countable s", "\u2200(l :\u03b1 list). FINITE (set l)", "\u2200(f :\u03b1 -> num) (x :\u03b1) (ls :\u03b1 list). MEM x ls \u21d2 f x \u2264 SUM (MAP f ls)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 x INSERT s", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)", "\u2200(v :\u03b1) (p :\u03b2 -> \u03b1) (g :\u03b2 -> bool) (p' :\u03b3 -> \u03b1) (g' :\u03b3 -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g \u21d2 (\u2200(x :\u03b2). g x \u21d2 ((\u2203(x' :\u03b3). p' x' = p x \u2227 g' x') \u21d4 RES)) \u21d2 (PMATCH_ROW_COND_EX v p' g' \u21d4 RES)", "\u2200(x :\u03b1). (\u2205 :\u03b1 -> bool) DELETE x = (\u2205 :\u03b1 -> bool)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t \u2229 s = s DIFF t", "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n \u2212 LENGTH l1) l2", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2229 (t \u2229 u) = s \u2229 t \u2229 u", "\u2200(P :\u03b1 list -> bool). (\u2200(l :\u03b1 list). LENGTH l = (0 :num) \u21d2 P l) \u21d4 P ([] :\u03b1 list)", "ASSOC ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list)", "PMATCH_ROW_REDUNDANT (v :\u03b1) ([] :(\u03b1 -> \u03b2 option) list) (i :num) \u21d4 F", "\u2200(ZRECSPACE' :(num -> \u03b1 -> bool) -> bool). ZRECSPACE' (ind_type$ZBOT :num -> \u03b1 -> bool) \u2227 (\u2200(c :num) (i :\u03b1) (r :num -> num -> \u03b1 -> bool). (\u2200(n :num). ZRECSPACE' (r n)) \u21d2 ZRECSPACE' (ind_type$ZCONSTR c i r)) \u21d2 \u2200(a0 :num -> \u03b1 -> bool). ZRECSPACE a0 \u21d2 ZRECSPACE' a0", "\u2200(l1 :\u03b1 list) (l2 :\u03b2 list). LENGTH l1 = LENGTH l2 \u21d2 \u2200(x1 :\u03b1) (x2 :\u03b2). ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))", "\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)", "\u2200(e :\u03b1). \u2203(fn :unit -> \u03b1). fn () = e", "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 FRONT l ++ [LAST l] = l", "\u2200(l :\u03b1 list) (n :num). n < LENGTH l \u21d2 LAST (DROP n l) = LAST l", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). BUTLASTN n (x::l) = x::BUTLASTN n l", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). DISJOINT s t \u21d2 DISJOINT (PREIMAGE f s) (PREIMAGE f t)", "(\u2203(ls :\u03b1 list). (P :\u03b1 list -> bool) ls) \u21d4 \u2203(n :num) (f :num -> \u03b1). P (GENLIST f n)", "nub ([] :\u03b1 list) = ([] :\u03b1 list)", "WF (R :\u03b1 -> \u03b1 -> bool)\u207a \u21d4 WF R", "\u2200(n :num). countable (count n)", "{x | (y :\u03b1) = x} = {y}", "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = l ++ [x]", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d2 x \u2209 t", "GENLIST (f :num -> \u03b1) (0 :num) = ([] :\u03b1 list) \u2227 GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :\u03b1 list)", "\u2200(s :\u03b1) (x :\u03b1 -> bool). x \u2282 {s} \u21d4 x = (\u2205 :\u03b1 -> bool)", "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric R\u1d40 \u21d4 symmetric R", "\u2200(t1 :\u03b1) (t2 :\u03b1). (if F then t1 else t2) = t2", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). set (l1 ++ l2) = set l1 \u222a set l2", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l2 \u227c l1 \u21d4 \u2203(l :\u03b1 list). l1 = l2 ++ l", "\u2200(R :\u03b1 -> \u03b1 -> bool). irreflexive R\u1d40 \u21d4 irreflexive R", "\u2200(s :\u03b1 -> bool). CHOICE s \u2209 REST s", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 l2", "\u2200(L :\u03b1 list) (n :num). LEN L n = LENGTH L + n", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (x \u21d2 y' \u21d2 y) \u2227 (\u00acy' \u21d2 x \u21d2 x') \u21d2 (x' \u21d2 y') \u21d2 x \u21d2 y", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 \u2200(e :\u03b1). MEM e l \u21d2 P e", "\u2200(n1 :num) (n2 :num). count n1 = count n2 \u21d4 n1 = n2", "\u2200(n :num). (0 :num) < n \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL n (x::l) = EL (PRE n) l", "\u2200(e :\u03b1) (l :\u03b1 list). LIST_ELEM_COUNT e l > (0 :num) \u21d4 MEM e l", "\u2200(t :bool). t \u2228 t \u21d4 t", "(\u2200(x :\u03b1) (y :\u03b1). (f :\u03b1 -> \u03b2) x = f y \u21d4 x = y) \u21d2 (DISJOINT (IMAGE f (s1 :\u03b1 -> bool)) (IMAGE f (s2 :\u03b1 -> bool)) \u21d4 DISJOINT s1 s2)", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (y \u21d2 x' \u21d2 x) \u2227 (x' \u21d2 y' \u21d2 y) \u21d2 x' \u2227 y' \u21d2 x \u2227 y", "\u2200(n :num). DROP n ([] :\u03b1 list) = ([] :\u03b1 list)", "\u2200(s :\u03b1 -> bool). s \u2282 \ud835\udd4c(:\u03b1) \u21d4 \u2203(x :\u03b1). x \u2209 s", "(Q :\u03b1 option -> bool) ($some (P :\u03b1 -> bool)) \u21d2 (\u2203(x :\u03b1). P x \u2227 Q (SOME x)) \u2228 (\u2200(x :\u03b1). \u00acP x) \u2227 Q (NONE :\u03b1 option)", "transitive ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). INJ f s t \u2227 INJ g t u \u21d2 INJ (g \u2218 f) s u", "\u2200(y :\u03b2) (s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). IMAGE f s y \u21d4 \u2203(x :\u03b1). y = f x \u2227 x \u2208 s", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). SURJ f s t \u2227 SURJ g t u \u21d2 SURJ (g \u2218 f) s u", "\u2200(f :'z -> 'z). INVOL f \u21d2 \u2200(a :'z) (b :'z). f a = f b \u21d4 a = b", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3", "$OLEAST (P :num -> bool) = (NONE :num option) \u21d4 \u2200(n :num). \u00acP n", "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n \u2212 LENGTH l1) l2", "\u2200(ls :\u03b1 list) (f :\u03b2 -> \u03b1). EVERY (\u03bb(x :\u03b1). \u2203(y :\u03b2). x = f y) ls \u21d2 \u2203(l :\u03b2 list). ls = MAP f l", "\u2200(opt :\u03b1 option). (\u2203(x :\u03b1). opt = SOME x) \u2228 opt = (NONE :\u03b1 option)", "SURJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 \u2203(g :\u03b2 -> \u03b1). INJ g t s \u2227 \u2200(y :\u03b2). y \u2208 t \u21d2 f (g y) = y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R\ua673 x y \u2227 R y z \u21d2 R\u207a x z", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u2227 INFINITE s \u21d2 INFINITE t", "\u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). SNOC x1 l1 = SNOC x2 l2 \u21d2 LENGTH l1 = LENGTH l2", "\u2200(x :\u03b1) (l :\u03b1 list). TL (SNOC x l) = if NULL l then ([] :\u03b1 list) else SNOC x (TL l)", "\u2200(P :\u03b1 list -> bool) (n :num). (\u2200(l :\u03b1 list). LENGTH l = SUC n \u21d2 P l) \u21d4 \u2200(l :\u03b1 list). LENGTH l = n \u21d2 (\u03bb(l :\u03b1 list). \u2200(x :\u03b1). P (x::l)) l", "(x :\u03b1) \u2208 RDOM (RRESTRICT (R :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool)) \u21d4 x \u2208 RDOM R \u2227 x \u2208 s", "\u2200(x :\u03b1) (l :\u03b1 list). FRONT (SNOC x l) = l", "\u2200(l :\u03b1 list) (x :\u03b1). MEM x (REVERSE l) \u21d4 MEM x l", "\u2200(l :\u03b1 list). NULL l \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l", "\u2200(l :\u03b1 list) (m :num) (x :\u03b1). MEM x (DROP m l) \u21d2 MEM x l", "\u2200(x :\u03b1 + \u03b2). ISR x \u21d2 (INR (OUTR x) :\u03b1 + \u03b2) = x", "(([(f :\u03b2 -> \u03b1)] <*> (l :\u03b2 list)) :\u03b1 list) = MAP f l", "\u2200(n :num) (x :\u03b1). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x", "\u2200(s :\u03b1 -> bool) (x :\u03b1) (y :\u03b1). x INSERT s = {y} \u21d4 x = y \u2227 s \u2286 {y}", "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2", "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive (RC R)", "(R1 :\u03b3 -> \u03b2 -> bool) \u2218\u1d63 (R2 :\u03b4 -> \u03b3 -> bool) \u2218\u1d63 (R3 :\u03b1 -> \u03b4 -> bool) = (R1 \u2218\u1d63 R2) \u2218\u1d63 R3", "\u2200(n :num). (0 :num) < n \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). ELL n (SNOC x l) = ELL (PRE n) l", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). ALL_DISTINCT (l1 ++ l2) \u21d4 ALL_DISTINCT l1 \u2227 ALL_DISTINCT l2 \u2227 \u2200(e :\u03b1). MEM e l1 \u21d2 \u00acMEM e l2", "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 BUTLASTN (1 :num) l = FRONT l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). BIGUNION {s; t} = s \u222a t", "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). \u00acNULL l2 \u21d2 EL (LENGTH l1) (l1 ++ l2) = HD l2", "reflexive ((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) \u21d4 reflexive R1 \u2228 reflexive R2", "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (IMAGE f s) \u21d2 (countable (IMAGE f s) \u21d4 countable s)", "MAP (f :\u03b2 -> \u03b1) (LIST_BIND (l :\u03b3 list) (g :\u03b3 -> \u03b2 list)) = LIST_BIND l (MAP f \u2218 g)", "FUNSET \ud835\udd4c(:\u03b1) \ud835\udd4c(:\u03b2) = \ud835\udd4c(:\u03b1 -> \u03b2)", "\u2200(A :bool) (B :bool) (C :bool). A \u2227 B \u21d2 C \u21d4 A \u21d2 B \u21d2 C", "MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (ls :(\u03b2 # \u03b1) list)) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) ls)", "REPLICATE (n :num) (a :\u03b1) ++ REPLICATE (m :num) a = REPLICATE (n + m) a", "\u2200(b :bool). \u00acb \u21d2 (b \u21d4 F)", "\u2200(x :\u03b1) (y :\u03b2) (a :\u03b1) (b :\u03b2). (x,y) = (a,b) \u21d4 x = a \u2227 y = b", "\u2200(f :\u03b1 -> \u03b2) (n :num) (x :\u03b1). MAP f (REPLICATE n x) = REPLICATE n (f x)", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l", "PMATCH_ROW_COND_EX (i :\u03b1) (p :\u03b2 -> \u03b1) (g :\u03b2 -> bool) \u21d2 PMATCH_ROW p g (r :\u03b2 -> \u03b3) i = SOME (r (@(x :\u03b2). PMATCH_ROW_COND p g i x))", "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). (R1 \u2229\u1d63 R2)\ua673 x y \u21d2 (R1\ua673 \u2229\u1d63 R2\ua673) x y", "\u2200(P :\u03b1 -> bool) (a :\u03b1) (s :\u03b1 -> bool). (\u2203(x :\u03b1). x \u2208 a INSERT s \u2227 P x) \u21d4 P a \u2228 \u2203(x :\u03b1). x \u2208 s \u2227 P x", "\u2200(f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4) (z :\u03b1 + \u03b2). SUM_MAP f g z = if ISL z then (INL (f (OUTL z)) :\u03b3 + \u03b4) else (INR (g (OUTR z)) :\u03b3 + \u03b4)", "\u2200(l :\u03b1 list list). REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))", "\u2200(f1 :\u03b1 -> \u03b2) (f2 :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f1 l = MAP f2 l \u21d4 \u2200(e :\u03b1). MEM e l \u21d2 f1 e = f2 e", "($= :\u03b1 -> \u03b1 -> bool)\u1d40 = ($= :\u03b1 -> \u03b1 -> bool)", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 ELL n (REVERSE l) = ELL (PRE (LENGTH l \u2212 n)) l", "\u2200(x :\u03b1) (s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2260 x INSERT s", "(\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acSHORTLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 SHORTLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (SHORTLEX R (h1::t1) (h2::t2) \u21d4 LENGTH t1 < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 (R h1 h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2))", "(\u2200(v :\u03b1). PMATCH_IS_EXHAUSTIVE v ([] :(\u03b1 -> \u03b2 option) list) \u21d4 F) \u2227 \u2200(v :\u03b3) (r :\u03b3 -> \u03b4 option) (rs :(\u03b3 -> \u03b4 option) list). PMATCH_IS_EXHAUSTIVE v (r::rs) \u21d4 r v \u2260 (NONE :\u03b4 option) \u2228 PMATCH_IS_EXHAUSTIVE v rs", "(\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2229 s = s) \u2227 \u2200(s :\u03b1 -> bool). s \u2229 \ud835\udd4c(:\u03b1) = s", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d4 f \u2208 FUNSET s t \u2227 \u2200(y :\u03b2). y \u2208 t \u21d2 \u2203!(x :\u03b1). x \u2208 s \u2227 y = f x", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n l = TAKE (LENGTH l \u2212 n) l", "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). IS_SUFFIX (REVERSE l1) (REVERSE l2) \u21d4 l2 \u227c l1", "\u2200(s :\u03b1 -> bool) (x :\u03b1) (y :\u03b1). x \u2208 s DELETE y \u21d4 x \u2208 s \u2227 x \u2260 y", "\u2200(ls :\u03b1 list) (n :num). n \u2264 LENGTH ls \u21d2 REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls \u2212 n) ls)", "\u2200(f :\u03b1 -> \u03b2). PREIMAGE f (\u2205 :\u03b2 -> bool) = (\u2205 :\u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f (REVERSE l) = REVERSE (MAP f l)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s \u222a t) x \u21d4 x \u2208 s \u2228 x \u2208 t", "\u2200(n :num). LENGTH (COUNT_LIST n) = n", "(\u2203(p :\u03b1 # \u03b2). (P :\u03b1 # \u03b2 -> bool) p) \u21d4 \u2203(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) l2 l1", "\u2200(s :\u03b1 -> bool) (x :\u03b1). COMPL (x INSERT s) = COMPL s DELETE x", "\u2200(t :bool). t \u21d2 T \u21d4 T", "countable (\u2205 :\u03b1 -> bool)", "\u2200(R :\u03b1 -> \u03b1 -> bool). Order R \u21d4 StrongOrder (STRORD R)", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (x \u21d2 y \u21d2 y') \u2227 (\u00acy' \u21d2 x' \u21d2 x) \u21d2 (x \u21d2 y) \u21d2 x' \u21d2 y'", "(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). x = y::xs \u2227 xs \u227c ys", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list) (m :num). EVERY P l \u21d2 EVERY P (TAKE m l)", "IS_SOME (OPTION_BIND (x :\u03b1 option) (g :\u03b1 -> \u03b2 option)) \u21d2 IS_SOME x", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R\ua673 (x :\u03b1) (y :\u03b1) \u21d2 Q\ua673 x y", "\u2200(x :\u03b1 list). x \u227c x", "count (0 :num) = (\u2205 :num -> bool)", "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 -> bool) x) \u21d2 EXISTS P (l :\u03b1 list) \u21d2 EXISTS Q l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 s \u2229 t = s", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R\u207a x y", "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). T) xs = xs", "\u2200(s :\u03b1 -> bool). (\u03bb(x :\u03b1). x) PERMUTES s", "\u2200(l1 :\u03b1 list) (n :num). LENGTH l1 \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (l1 ++ l2) = l1 ++ TAKE (n \u2212 LENGTH l1) l2", "\u2200(s :\u03b1 -> bool). INFINITE s \u21d2 \u2200(t :\u03b1 -> bool). s \u2286 t \u21d2 INFINITE t", "(option_CASE (NONE :\u03b1 option) :\u03b2 -> (\u03b1 -> \u03b2) -> \u03b2) = (\u03bb(v :\u03b2) (f :\u03b1 -> \u03b2). v) \u2227 (option_CASE (SOME (x :\u03b1)) :\u03b2 -> (\u03b1 -> \u03b2) -> \u03b2) = (\u03bb(v :\u03b2) (f :\u03b1 -> \u03b2). f x)", "\u2200(t :bool). t \u21d2 F \u21d4 \u00act", "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool) (l :\u03b1 list). FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)", "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b2 -> bool). FUNSET P Q f \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q", "\ud835\udd4c(:\u03b1 + \u03b2) = IMAGE (INL :\u03b1 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b1) \u222a IMAGE (INR :\u03b2 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b2)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). s \u2286 x INSERT s", "\u2200(l :\u03b1 list) (x :\u03b1). l \u2260 x::l \u2227 x::l \u2260 l", "PROD_SET (\u2205 :num -> bool) = (1 :num) \u2227 \u2200(x :num) (s :num -> bool). FINITE s \u21d2 PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (x :\u03b1). PREIMAGE f s x \u21d4 f x \u2208 s", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l1 :\u03b1 list) (l2 :\u03b1 list). FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 DROP n l = LASTN (LENGTH l \u2212 n) l", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (TAKE n l) = n", "(0 :num) < (n :num) \u21d2 DROP n ((x :\u03b1)::(xs :\u03b1 list)) = DROP (n \u2212 (1 :num)) xs", "\u2200(l :bool list). AND_EL l \u21d4 FOLDL $/\\ T l", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l = ([] :\u03b1 list) \u21d4 EVERY (\u03bb(x :\u03b1). \u00acP x) l", "\u2200(v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list) (p :bool) (infos :bool list). FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) \u21d4 p \u2227 EVERY (\u03bb(r :\u03b1 -> \u03b2 option). r v = (NONE :\u03b2 option)) rows", "\u2200(s :\u03b1 -> bool). s \u2229 s = s", "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool). x DIFF y DIFF z = x DIFF z DIFF y", "\u2200(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool). (c \u21d2 x' \u21d2 x) \u2227 (\u00acc \u21d2 y' \u21d2 y) \u21d2 (if c then x' else y') \u21d2 if c then x else y", "\u2200(x :\u03b1). SING {x}", "((a :\u03b1),(b :\u03b1)) \u2208 {(x,x) | (P :\u03b1 -> bool) x} \u21d4 P a \u2227 a = b", "\u2200(M :\u03b1 list) (M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). M = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE M v f :\u03b2) = (list_CASE M' v' f' :\u03b2)", "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l \u2260 ([] :\u03b1 list)", "\u2200(g :\u03b1 -> \u03b1 -> \u03b1) (f :\u03b2 -> \u03b1 -> \u03b1). FCOMM g f \u21d2 \u2200(e :\u03b1). LEFT_ID g e \u21d2 \u2200(l :\u03b2 list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)", "\u2200(m :num) (n :num). m < SUC n \u21d2 m \u2260 n \u21d2 m < n", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2282 t \u2227 t \u2282 u \u21d2 s \u2282 u", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). FINITE s \u2227 FINITE t \u21d2 CARD (s \u222a t) = CARD s + CARD t \u2212 CARD (s \u2229 t)", "\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2286 s \u21d4 s = \ud835\udd4c(:\u03b1)", "\u2200(v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list) (p :bool) (infos :bool list). LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) = LENGTH rows + LENGTH infos", "LIST_REL (R :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) ((h :\u03b2)::(t :\u03b2 list)) \u21d4 \u2203(h' :\u03b1) (t' :\u03b1 list). xs = h'::t' \u2227 R h' h \u2227 LIST_REL R t' t", "(\u2200(x :\u03b1) (y :\u03b1). (P :\u03b1 -> bool) x \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). P x \u2227 R\ua673 x y \u21d2 P y", "((p :bool) \u21d4 if (q :bool) then (r :bool) else (s :bool)) \u21d4 (p \u2228 q \u2228 \u00acs) \u2227 (p \u2228 \u00acr \u2228 \u00acq) \u2227 (p \u2228 \u00acr \u2228 \u00acs) \u2227 (\u00acq \u2228 r \u2228 \u00acp) \u2227 (q \u2228 s \u2228 \u00acp)", "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u21d4 \u2203(t :\u03b1 -> bool). s = x INSERT t \u2227 x \u2209 t", "PMATCH_ROW_REDUNDANT (v :\u03b1) ((r :\u03b1 -> \u03b2 option)::(rs :(\u03b1 -> \u03b2 option) list)) (0 :num) \u21d4 r v = (NONE :\u03b2 option)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT t (s DIFF t) \u2227 DISJOINT (s DIFF t) t", "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool) (y :\u03b2). y \u2208 BIGUNION (IMAGE f s) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 y \u2208 f x", "(\u2200(e :\u03b1). LIST_ELEM_COUNT e ([] :\u03b1 list) = (0 :num)) \u2227 (\u2200(e :\u03b2) (l1 :\u03b2 list) (l2 :\u03b2 list). LIST_ELEM_COUNT e (l1 ++ l2) = LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) \u2227 (\u2200(e :\u03b3) (h :\u03b3) (l :\u03b3 list). h = e \u21d2 LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) \u2227 \u2200(e :\u03b4) (h :\u03b4) (l :\u03b4 list). h \u2260 e \u21d2 LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s \u2229 t) x \u21d4 x \u2208 s \u2227 x \u2208 t", "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EXISTS P (l1 ++ l2) \u21d4 EXISTS P l1 \u2228 EXISTS P l2", "\u2200(ls :\u03b1 list) (f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP (ls,ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) ls", "MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0", "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric R \u21d2 SC R = R", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). SHORTLEX (R :\u03b1 -> \u03b1 -> bool) l1 l2 \u21d2 LENGTH l1 \u2264 LENGTH l2", "\u2200(f :\u03b2 -> \u03b1 -> \u03b2) (e :\u03b2) (x :\u03b1) (l :\u03b1 list). FOLDL f e (SNOC x l) = f (FOLDL f e l) x", "\u2200(P :(\u03b1 -> bool) -> bool). P (\u2205 :\u03b1 -> bool) \u2227 (\u2200(s :\u03b1 -> bool). FINITE s \u2227 P s \u21d2 \u2200(e :\u03b1). e \u2209 s \u21d2 P (e INSERT s)) \u21d2 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 P s", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 FINITE (REST s)", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2203(f :num -> \u03b1) (b :num). BIJ f (count b) s", "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EVERY P l1 \u21d2 dropWhile P (l1 ++ l2) = dropWhile P l2", "(OPTION_IGNORE_BIND (m1 :\u03b1 option) (m2 :\u03b2 option) = (NONE :\u03b2 option) \u21d4 m1 = (NONE :\u03b1 option) \u2228 m2 = (NONE :\u03b2 option)) \u2227 (OPTION_IGNORE_BIND m1 m2 = SOME (y :\u03b2) \u21d4 \u2203(x :\u03b1). m1 = SOME x \u2227 m2 = SOME y)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 \u00acEXISTS (\u03bb(x :\u03b1). \u00acP x) l", "\u2200(s :\u03b1 -> bool). s = \ud835\udd4c(:\u03b1) \u21d2 \u2200(v :\u03b1). v \u2208 s", "\u2200(n :num). SUC (m :num) = n \u21d2 m < n", "((if (P :bool) then SOME (x :\u03b1) else (NONE :\u03b1 option)) = (NONE :\u03b1 option) \u21d4 \u00acP) \u2227 ((if P then (NONE :\u03b1 option) else SOME x) = (NONE :\u03b1 option) \u21d4 P) \u2227 ((if P then SOME x else (NONE :\u03b1 option)) = SOME (y :\u03b1) \u21d4 P \u2227 x = y) \u2227 ((if P then (NONE :\u03b1 option) else SOME x) = SOME y \u21d4 \u00acP \u2227 x = y)", "(some(x :bool). x) = SOME T", "REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) \u2227 REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list)) ((i2 :bool)::(is2 :bool list)) = (i1 \u2227 i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2", "\u2200(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)", "\u2200(x :\u03b1 recspace) (y :\u03b1 recspace). dest_rec x = dest_rec y \u21d4 x = y", "((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) ((a :\u03b1),(b :\u03b2)) ((c :\u03b1),(d :\u03b2)) \u21d4 R1 a c \u2228 a = c \u2227 R2 b d", "(\u2200(l :\u03b1 list). ([] :\u03b1 list) \u227c l \u21d4 T) \u2227 (\u2200(x :\u03b1) (l :\u03b1 list). x::l \u227c ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). x2::l2 \u227c x1::l1 \u21d4 x1 = x2 \u2227 l2 \u227c l1", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 DROP n (REVERSE l) = REVERSE (BUTLASTN n l)", "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f l) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). s \u2286 t \u21d2 PREIMAGE f s \u2286 PREIMAGE f t", "PROD_ALL (P :\u03b1 -> bool) (Q :\u03b2 -> bool) ((x :\u03b1),(y :\u03b2)) \u21d4 P x \u2227 Q y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\u207a x y \u21d2 R\ua673 x y", "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). BUTLASTN (LENGTH l2) (l1 ++ l2) = l1", "\u2200(l :\u03b1 list). LENGTH l = FOLDR (\u03bb(x :\u03b1) (l' :num). SUC l') (0 :num) l", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LASTN n l = DROP (LENGTH l \u2212 n) l", "\u2200(t :bool). F \u2228 t \u21d4 t", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). IMAGE f (PREIMAGE f s) \u2286 s", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2282 t \u21d4 s \u2286 t \u2227 \u2203(y :\u03b1). y \u2208 t \u2227 y \u2209 s", "(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (z :\u03b1) \u21d4 R x z \u2228 \u2203(y :\u03b1). R x y \u2227 R\u207a y z", "\u2200(m :num) (n :num) (l :\u03b1 list). m \u2264 n \u2227 n \u2264 LENGTH l \u21d2 BUTLASTN m (LASTN n l) = LASTN (n \u2212 m) (BUTLASTN m l)", "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b1 -> \u03b2 -> bool). f \u2208 DFUNSET P Q \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q x", "(\u2200(x :\u03b1). MEM x ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x :\u03b1) (h :\u03b1) (t :\u03b1 list). MEM x (h::t) \u21d4 x = h \u2228 MEM x t", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d4 s DELETE x = s", "((INL (a :\u03b1) :\u03b1 + \u03b2) \u2208 (A :\u03b1 -> bool) \u2294 (B :\u03b2 -> bool) \u21d4 a \u2208 A) \u2227 ((INR (b :\u03b2) :\u03b1 + \u03b2) \u2208 A \u2294 B \u21d4 b \u2208 B)", "WF (\u03bb(x :num) (y :num). y = SUC x)", "\u2200(L :num list) (n :num). SUM_ACC L n = SUM L + n", "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 s \u2282 \ud835\udd4c(:\u03b1)", "\u2200(ls :\u03b1 list list). FLAT ls = ([] :\u03b1 list) \u21d4 EVERY ($= ([] :\u03b1 list)) ls", "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). INJ f (\u2205 :\u03b1 -> bool) s) \u2227 \u2200(s :\u03b1 -> bool). INJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)", "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). (MAP f l = ([] :\u03b2 list) \u21d4 l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f l \u21d4 l = ([] :\u03b1 list))", "\u2200(l :num list). SUM l = FOLDR $+ (0 :num) l", "\u2200(R :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list) (n :num). LIST_REL R l1 l2 \u21d2 LIST_REL R (DROP n l1) (DROP n l2)", "(some(x :\u03b1). F) = (NONE :\u03b1 option)", "\u2200(f :\u03b1 -> \u03b2) (l1 :\u03b1 list) (l2 :\u03b1 list). MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2", "\u2200(g :\u03b1 -> \u03b1 -> \u03b1) (f :\u03b2 -> \u03b1 -> \u03b1). FCOMM g f \u21d2 \u2200(e :\u03b1). LEFT_ID g e \u21d2 \u2200(l1 :\u03b2 list) (l2 :\u03b2 list). FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)", "\u2205 (x :\u03b1) \u21d4 F", "\u2200(R :\u03b1 -> \u03b1 -> bool). WeakLinearOrder R \u21d4 WeakOrder R \u2227 \u2200(a :\u03b1) (b :\u03b1). R a b \u2228 R b a", "\u2200(R :\u03b1 -> \u03b2 -> bool) (R' :\u03b3 -> \u03b1 -> bool). (R \u2218\u1d63 R')\u1d40 = R'\u1d40 \u2218\u1d63 R\u1d40", "\u2200(x :\u03b1) (l :\u03b1 list). x::l = [x] ++ l", "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f l = FOLDR (\u03bb(x :\u03b1) (l' :\u03b2 list). f x::l') ([] :\u03b2 list) l", "\u2200(x :\u03b1). x \u2208 \ud835\udd4c(:\u03b1)", "\ud835\udd4c(:\u03b1 + \u03b2) = \ud835\udd4c(:\u03b1) \u2294 \ud835\udd4c(:\u03b2)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (g :\u03b1 -> bool). (s DIFF t) \u2229 g = s \u2229 g DIFF t", "\u2200(Q :num -> bool) (P :num -> bool). (\u2203(n :num). P n) \u2227 (\u2200(n :num). (\u2200(m :num). m < n \u21d2 \u00acP m) \u2227 P n \u21d2 Q n) \u21d2 Q ($LEAST P)", "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). F) xs = ([] :\u03b1 list)", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool). IMAGE f (x INSERT s) = f x INSERT IMAGE f s", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). TAKE (LENGTH l1) (l1 ++ l2) = l1", "\u2200(l :\u03b1 list list). FLAT l = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l", "(\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acLLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 LLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (LLEX R (h1::t1) (h2::t2) \u21d4 R h1 h2 \u2228 h1 = h2 \u2227 LLEX R t1 t2)", "\u2200(l :\u03b1 list). l ++ ([] :\u03b1 list) = l", "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). f \u2208 FUNSET s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)", "\u2200(b :bool). b \u21d2 (b \u21d4 T)", "\u2200(l :\u03b1 list) (x :\u03b1). ELL (0 :num) (SNOC x l) = x", "\u2200(ls :\u03b1 list). ls \u2260 ([] :\u03b1 list) \u21d2 MAP (f :\u03b1 -> \u03b2) (FRONT ls) = FRONT (MAP f ls)", "\u2200(n :num). (0 :num) < SUC n", "IMAGE (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool) = {(z :\u03b1)} \u21d4 s \u2260 (\u2205 :\u03b2 -> bool) \u2227 \u2200(x :\u03b2). x \u2208 s \u21d2 f x = z", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l :\u03b1 list). FOLDR f e l = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (a :\u03b1). IS_SUFFIX l1 l2 \u21d2 IS_SUFFIX (a::l1) l2", "\u2200(x :\u03b1) (P :\u03b1 -> bool). x \u2208 P \u21d4 P x", "\u2200(R :\u03b1 -> \u03b1 -> bool). StrongOrder R \u21d2 Order R", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 MEM (EL n l) l", "\u2200(x :\u03b1) (y :\u03b1) (P :\u03b1 -> bool). x \u2208 y INSERT P \u21d4 x = y \u2228 x \u2260 y \u2227 x \u2208 P", "OWHILE (G :\u03b1 -> bool) (f :\u03b1 -> \u03b1) (s :\u03b1) = SOME (s' :\u03b1) \u21d2 \u00acG s'", "symmetric (R1 :\u03b1 -> \u03b1 -> bool) \u2227 symmetric (R2 :\u03b2 -> \u03b2 -> bool) \u21d2 symmetric (R1 LEX R2)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). PREFIX P l \u227c l", "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). (\u2203(t :\u03b2 -> bool). INJ f s t) \u21d2 BIJ f s (IMAGE f s)", "\u2200(s :\u03b1 -> bool). s DIFF \ud835\udd4c(:\u03b1) = (\u2205 :\u03b1 -> bool)", "\u2200(t :bool). t \u2227 t \u21d4 t", "(\u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool)) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 (P :\u03b1 -> bool) x) \u21d2 P (CHOICE s)"]