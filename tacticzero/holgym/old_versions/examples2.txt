Initialization done. Main goal is:
∀l1 l2 f f'. l1 = l2 ∧ (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l1 = MAP f' l2.
Exception raised when applying tactic Induct_on to ∀f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2.
Exception raised when applying tactic irule LIST_TO_SET_DEF to (∀x. MEM x [] ⇒ f x = f' x) ⇒ MAP f [] = MAP f' [].
Exception raised when applying tactic rpt strip_tac >> Induct_on `h` to ((∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2) ==> (∀h. (∀x. MEM x (h::l2) ⇒ f x = f' x) ⇒ MAP f (h::l2) = MAP f' (h::l2)).
Proved in 19 steps.
Reward pool: [0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, -1, 20]
Total reward: 17
Proof trace: [('simp[EL, LIST_TO_SET_DEF, dropWhile_def, MAP, FOLDL, isPREFIX, SHORTLEX_def, FOLDR, oHD_def, SNOC]', "∀l1 l2 f f'. l1 = l2 ∧ (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l1 = MAP f' l2"), ('simp[OPT_MMAP_def, UNIQUE_DEF, NULL_DEF, LIST_TO_SET_DEF, MAP, LIST_TO_SET_DEF, isPREFIX, DROP_def, LIST_LIFT2_def, list_size_def]', "∀l2 f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('fs[EVERY_DEF, nub_def, INDEX_OF_def, EL, LIST_APPLY_def, list_case_def, PAD_LEFT, TL_DEF, LUPDATE_def, TL_DEF]', "∀l2 f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('fs[FLAT, LENGTH, oHD_def, GENLIST_AUX, list_size_def, SNOC, MAP, nub_def, GENLIST, FRONT_DEF]', "∀l2 f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('strip_tac', "∀l2 f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('fs[PAD_LEFT, SUM_ACC_DEF, GENLIST_AUX, OPT_MMAP_def, SNOC, LIST_LIFT2_def, LEN_DEF, list_case_def, UNIQUE_DEF, ALL_DISTINCT]', "∀f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('simp[FILTER, UNIQUE_DEF, SUM_ACC_DEF, FILTER, INDEX_FIND_def, FOLDL, NULL_DEF, EVERYi_def, nub_def, LIST_APPLY_def]', "∀f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('strip_tac', "∀f f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('strip_tac', "∀f'. (∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('simp[LEN_DEF, oHD_def, TAKE_def, oHD_def, LIST_BIND_def, dropWhile_def, LIST_TO_SET_DEF, splitAtPki_def, ZIP_def, INDEX_FIND_def]', "(∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('simp[OPT_MMAP_def, LIST_BIND_def, FRONT_DEF, EL, FOLDL, LIST_BIND_def, oHD_def, LIST_BIND_def, list_size_def, APPEND]', "(∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('fs[LIST_APPLY_def, GENLIST_AUX, isPREFIX, PAD_RIGHT, ALL_DISTINCT, LIST_IGNORE_BIND_def, list_size_def, REV_DEF, SET_TO_LIST_primitive_def, list_size_def]', "(∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('strip_tac', "(∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2"), ('rpt strip_tac >> Induct_on `l2`', "(∀x. MEM x l2 ⇒ f x = f' x) ==> (MAP f l2 = MAP f' l2)"), ('fs[UNIQUE_DEF, SUM_ACC_DEF, SET_TO_LIST_primitive_def, FRONT_DEF, FLAT, MAP, list_TY_DEF, FOLDR, SUM_ACC_DEF, EXISTS_DEF]', "(∀x. MEM x [] ⇒ f x = f' x) ⇒ MAP f [] = MAP f' []"), ('rpt strip_tac >> simp[FLAT, LAST_DEF, DROP_def, FRONT_DEF, LIST_LIFT2_def, LIST_IGNORE_BIND_def, DROP_def, list_size_def, APPEND, SHORTLEX_def]', "((∀x. MEM x l2 ⇒ f x = f' x) ⇒ MAP f l2 = MAP f' l2) ==> (∀h. (∀x. MEM x (h::l2) ⇒ f x = f' x) ⇒ MAP f (h::l2) = MAP f' (h::l2))")]

Initialization done. Main goal is:
∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l.
Exception raised when applying tactic Induct_on to ∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l.
Exception raised when applying tactic irule DROP_def to ∀l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l.
Exception raised when applying tactic drule LIST_APPLY_def to ∀l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l.
Exception raised when applying tactic drule GENLIST_AUX to ∀l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l.
Exception raised when applying tactic rpt strip_tac >> strip_tac to (ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l).
Exception raised when applying tactic rpt strip_tac >> strip_tac to (ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l).
Exception raised when applying tactic rpt strip_tac >> Induct_on `list$LIST_TO_SET` to (ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l).
Proved in 24 steps.
Reward pool: [0, 0, -1, 0, -1, -1, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1, -1, 0, 0, -1, 0, 0, 0, 20]
Total reward: 13
Proof trace: [('simp[SUM, FIND_def, NULL_DEF, GENLIST_AUX, oEL_def, FLAT, EL, SUM, LRC_def, MAP]', '∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l'), ('simp[FRONT_DEF, INDEX_OF_def, list_TY_DEF, FIND_def, FOLDR, LEN_DEF, LIST_BIND_def, FOLDR, LIST_BIND_def, ZIP_def]', '∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l'), ('strip_tac', '∀x l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l'), ('simp[LUPDATE_def, OPT_MMAP_def, list_size_def, list_TY_DEF, SET_TO_LIST_primitive_def, FILTER, EXISTS_DEF, LUPDATE_def, list_TY_DEF, LAST_DEF]', '∀l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l'), ('simp[list_case_def, list_TY_DEF, list_case_def, NULL_DEF, FIND_def, FRONT_DEF, ALL_DISTINCT, nub_def, PAD_LEFT, LIST_BIND_def]', '∀l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l'), ('Induct_on `l`', '∀l. ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l'), ('simp[LEN_DEF, LEN_DEF, DROP_def, EVERYi_def, LLEX_def, DROP_def, UNZIP, PAD_RIGHT, FOLDR, isPREFIX]', 'ALL_DISTINCT (SNOC x []) ⇔ ¬MEM x [] ∧ ALL_DISTINCT []'), ('rpt strip_tac >> simp[SNOC, oEL_def, DROP_def, nub_def, LIST_BIND_def, LIST_GUARD_def, SNOC, SNOC, FIND_def, isPREFIX]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> (∀h. ALL_DISTINCT (SNOC x (h::l)) ⇔ ¬MEM x (h::l) ∧ ALL_DISTINCT (h::l))'), ('rpt strip_tac >> fs[nub_def, list_TY_DEF, LUPDATE_def, ZIP_def, EXISTS_DEF, INDEX_OF_def, FIND_def, FOLDL, DROP_def, LAST_DEF]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> fs[FLAT, isPREFIX, nub_def, EXISTS_DEF, INDEX_FIND_def, FOLDL, LIST_APPLY_def, GENLIST, REVERSE_DEF, LRC_def]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> simp[list_TY_DEF, UNIQUE_DEF, isPREFIX, UNIQUE_DEF, LIST_IGNORE_BIND_def, EVERYi_def, FRONT_DEF, LIST_BIND_def, FRONT_DEF, SNOC]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> simp[isPREFIX, SNOC, nub_def, LIST_GUARD_def, splitAtPki_def, TAKE_def, LIST_APPLY_def, LENGTH, isPREFIX, LIST_LIFT2_def]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> simp[UNZIP, list_TY_DEF, TL_DEF, list_size_def, LIST_BIND_def, LIST_LIFT2_def, nub_def, LIST_APPLY_def, LENGTH, splitAtPki_def]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> simp[FIND_def, FOLDR, LUPDATE_def, PAD_LEFT, TL_DEF, EVERYi_def, UNIQUE_DEF, ALL_DISTINCT, EVERYi_def, list_case_def]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> fs[LLEX_def, APPEND, splitAtPki_def, REV_DEF, LIST_GUARD_def, LIST_BIND_def, REVERSE_DEF, FRONT_DEF, list_case_def, LIST_LIFT2_def]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> simp[LLEX_def, EL, INDEX_OF_def, dropWhile_def, ALL_DISTINCT, LIST_TO_SET_DEF, SUM, UNIQUE_DEF, FIND_def, HD]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)'), ('rpt strip_tac >> metis_tac[PAD_RIGHT, REVERSE_DEF, LIST_IGNORE_BIND_def, EL, REVERSE_DEF, INDEX_FIND_def, FOLDL, OPT_MMAP_def, OPT_MMAP_def, LEN_DEF]', '(ALL_DISTINCT (SNOC x l) ⇔ ¬MEM x l ∧ ALL_DISTINCT l) ==> ((h ≠ x ∧ ¬MEM h l) ∧ ¬MEM x l ∧ ALL_DISTINCT l ⇔ (x ≠ h ∧ ¬MEM x l) ∧ ¬MEM h l ∧ ALL_DISTINCT l)')]

Initialization done. Main goal is:
∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys.
Exception raised when applying tactic Induct_on to ∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys.
Exception raised when applying tactic Induct_on to ∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ []) = xs ⧺ [x] ⧺ [].
Exception raised when applying tactic Induct_on to ∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ []) = xs ⧺ [x] ⧺ [].
Exception raised when applying tactic rpt strip_tac >> irule UNZIP to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys).
Exception raised when applying tactic rpt strip_tac >> Induct_on to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys).
Exception raised when applying tactic rpt strip_tac >> Induct_on `x` to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys).
Exception raised when applying tactic rpt strip_tac >> irule LIST_LIFT2_def to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys).
Exception raised when applying tactic rpt strip_tac >> Induct_on to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys).
Exception raised when applying tactic rpt strip_tac >> strip_tac to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys).
Exception raised when applying tactic rpt strip_tac >> drule EVERYi_def to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x 0 (y::h::ys) = x::h::ys).
Exception raised when applying tactic rpt strip_tac >> metis_tac[LEN_DEF, LENGTH, SET_TO_LIST_primitive_def, DROP_def, SUM_ACC_DEF, FOLDL, LIST_TO_SET_DEF, MAP, LIST_TO_SET_DEF, nub_def] to (∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x 0 (y::h::ys) = x::h::ys).
Proved in 35 steps.
Reward pool: [-1, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, -1, -1, 0, -1, -1, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 20]
Total reward: 9
Proof trace: [('fs[FILTER, LRC_def, APPEND, REV_DEF, list_case_def, splitAtPki_def, LRC_def, FRONT_DEF, LIST_TO_SET_DEF, dropWhile_def]', '∀xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys'), ('Induct_on `ys`', '∀xs x y ys. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys'), ('simp[FIND_def, REV_DEF, PAD_RIGHT, list_case_def, LENGTH, FRONT_DEF, PAD_RIGHT, FIND_def, INDEX_FIND_def, SUM_ACC_DEF]', '∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ []) = xs ⧺ [x] ⧺ []'), ('rpt strip_tac >> simp[GENLIST_AUX, INDEX_OF_def, SUM_ACC_DEF, FLAT, isPREFIX, TL_DEF, FLAT, LLEX_def, PAD_LEFT, EL]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (∀h xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ h::ys) = xs ⧺ [x] ⧺ h::ys)'), ('rpt strip_tac >> simp[LEN_DEF, list_TY_DEF, REVERSE_DEF, NULL_DEF, LIST_BIND_def, SHORTLEX_def, ALL_DISTINCT, list_size_def, LENGTH, LIST_LIFT2_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[EVERY_DEF, LEN_DEF, oEL_def, UNZIP, OPT_MMAP_def, EL, REV_DEF, UNZIP, list_case_def, LIST_LIFT2_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[UNZIP, DROP_def, isPREFIX, EXISTS_DEF, PAD_LEFT, INDEX_OF_def, isPREFIX, oHD_def, isPREFIX, EL]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> fs[FILTER, LIST_GUARD_def, LLEX_def, LIST_IGNORE_BIND_def, PAD_RIGHT, SNOC, GENLIST, ALL_DISTINCT, FRONT_DEF, FLAT]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[SHORTLEX_def, LIST_GUARD_def, GENLIST_AUX, LENGTH, LEN_DEF, LIST_BIND_def, DROP_def, LIST_APPLY_def, LAST_DEF, LLEX_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[REVERSE_DEF, GENLIST, UNZIP, LRC_def, EVERY_DEF, SNOC, FRONT_DEF, UNZIP, EXISTS_DEF, FLAT]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[oHD_def, LIST_IGNORE_BIND_def, LIST_TO_SET_DEF, oHD_def, EVERY_DEF, UNIQUE_DEF, TL_DEF, REVERSE_DEF, LIST_LIFT2_def, oHD_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[FRONT_DEF, ZIP_def, APPEND, NULL_DEF, FIND_def, SET_TO_LIST_primitive_def, isPREFIX, OPT_MMAP_def, SNOC, dropWhile_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[list_case_def, splitAtPki_def, SHORTLEX_def, PAD_LEFT, FOLDL, isPREFIX, LIST_IGNORE_BIND_def, ALL_DISTINCT, LIST_LIFT2_def, REVERSE_DEF]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[REVERSE_DEF, EL, FOLDR, LIST_IGNORE_BIND_def, LIST_TO_SET_DEF, LIST_LIFT2_def, LIST_IGNORE_BIND_def, oEL_def, FOLDR, FILTER]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[ALL_DISTINCT, ZIP_def, GENLIST_AUX, LRC_def, ALL_DISTINCT, REVERSE_DEF, FIND_def, list_TY_DEF, TL_DEF, REVERSE_DEF]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[FLAT, LIST_IGNORE_BIND_def, HD, ZIP_def, FIND_def, EVERYi_def, FOLDR, LIST_GUARD_def, LIST_GUARD_def, LAST_DEF]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> Induct_on `xs`', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> simp[PAD_RIGHT, LIST_BIND_def, list_size_def, TAKE_def, FILTER, REV_DEF, nub_def, SUM_ACC_DEF, FOLDR, dropWhile_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x (LENGTH []) ([] ⧺ [y; h] ⧺ ys) = [] ⧺ [x; h] ⧺ ys)'), ('rpt strip_tac >> fs[PAD_LEFT, DROP_def, FILTER, FOLDL, PAD_LEFT, OPT_MMAP_def, oHD_def, SET_TO_LIST_primitive_def, TAKE_def, ZIP_def]', "(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> ((LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys) ==> (∀h'. LUPDATE x (LENGTH (h'::xs)) (h'::xs ⧺ [y; h] ⧺ ys) = h'::xs ⧺ [x; h] ⧺ ys))"), ('rpt strip_tac >> fs[oHD_def, LIST_GUARD_def, nub_def, APPEND, GENLIST_AUX, LENGTH, EVERY_DEF, LIST_IGNORE_BIND_def, OPT_MMAP_def, PAD_RIGHT]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x 0 (y::h::ys) = x::h::ys)'), ('rpt strip_tac >> fs[PAD_RIGHT, SHORTLEX_def, INDEX_FIND_def, LUPDATE_def, FOLDL, SET_TO_LIST_primitive_def, EL, LEN_DEF, FILTER, SUM_ACC_DEF]', "(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> ((LUPDATE x (LENGTH xs) (xs ⧺ [y; h] ⧺ ys) = xs ⧺ [x; h] ⧺ ys) ==> (LUPDATE x (SUC (LENGTH xs)) (h'::(xs ⧺ [y; h] ⧺ ys)) = h'::(xs ⧺ [x; h] ⧺ ys)))"), ('rpt strip_tac >> simp[oHD_def, SUM_ACC_DEF, EXISTS_DEF, LIST_LIFT2_def, LIST_IGNORE_BIND_def, UNIQUE_DEF, UNIQUE_DEF, LIST_LIFT2_def, FIND_def, oHD_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x 0 (y::h::ys) = x::h::ys)'), ('rpt strip_tac >> simp[LRC_def, list_size_def, ZIP_def, LIST_BIND_def, LEN_DEF, oEL_def, oEL_def, LIST_IGNORE_BIND_def, splitAtPki_def, GENLIST_AUX]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x 0 (y::h::ys) = x::h::ys)'), ('rpt strip_tac >> simp[SNOC, LEN_DEF, FOLDL, TAKE_def, PAD_RIGHT, TL_DEF, FLAT, dropWhile_def, SUM_ACC_DEF, LUPDATE_def]', '(∀xs x y. LUPDATE x (LENGTH xs) (xs ⧺ [y] ⧺ ys) = xs ⧺ [x] ⧺ ys) ==> (LUPDATE x 0 (y::h::ys) = x::h::ys)')]
