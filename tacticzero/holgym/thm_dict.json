{"\u2200l. ZIP (UNZIP l) = l": "ZIP_UNZIP", "\u2200l1 l2 f1 f2. LENGTH l1 = LENGTH l2 \u21d2 ZIP (MAP f1 l1,l2) = MAP (\u03bbp. (f1 (FST p),SND p)) (ZIP (l1,l2)) \u2227 ZIP (l1,MAP f2 l2) = MAP (\u03bbp. (FST p,f2 (SND p))) (ZIP (l1,l2))": "ZIP_MAP", "\u2200l f n. LENGTH l = n \u21d2 ZIP (l,GENLIST f n) = GENLIST (\u03bbx. (EL x l,f x)) n": "ZIP_GENLIST", "\u2200l1 l2. LENGTH l1 = LENGTH l2 \u21d2 (ZIP (l1,l2) = [] \u21d4 l1 = [] \u2227 l2 = [])": "ZIP_EQ_NIL", "\u2200a b n. n \u2264 LENGTH a \u2227 LENGTH a = LENGTH b \u21d2 ZIP (DROP n a,DROP n b) = DROP n (ZIP (a,b))": "ZIP_DROP", "ZIP ([],[]) = [] \u2227 \u2200x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)": "ZIP", "WF R \u21d2 \u2200l s. (\u2200d. d \u2208 s \u21d2 LENGTH d = l) \u2227 (\u2203a. a \u2208 s) \u21d2 \u2203b. b \u2208 s \u2227 \u2200c. SHORTLEX R c b \u21d2 c \u2209 s": "WF_SHORTLEX_same_lengths", "WF R \u21d2 WF (SHORTLEX R)": "WF_SHORTLEX", "WF (\u03bbL1 L2. \u2203h. L2 = h::L1)": "WF_LIST_PRED", "\u2200l1 l2. LENGTH l1 = LENGTH l2 \u21d2 UNZIP (ZIP (l1,l2)) = (l1,l2)": "UNZIP_ZIP", "UNZIP [] = ([],[]) \u2227 UNZIP ((x,y)::t) = (let (L1,L2) = UNZIP t in (x::L1,y::L2))": "UNZIP_THM", "\u2200L. UNZIP L = (MAP FST L,MAP SND L)": "UNZIP_MAP", "\u2200e L. UNIQUE e L \u21d4 LENGTH (FILTER ($= e) L) = 1": "UNIQUE_LENGTH_FILTER", "\u2200e L. UNIQUE e L \u21d4 FILTER ($= e) L = [e]": "UNIQUE_FILTER", "\u2200l1 l2. set l1 \u222a set l2 = set (l1 ++ l2)": "UNION_APPEND", "\u2200f n. TL (GENLIST f (SUC n)) = GENLIST (f \u2218 SUC) n": "TL_GENLIST", "\u2200h t. TL (h::t) = t": "TL", "\u2200m n. TAKE n (TAKE m l) = TAKE (MIN n m) l": "TAKE_TAKE_MIN", "\u2200n m l. TAKE (n + m) l = TAKE n l ++ TAKE m (DROP n l)": "TAKE_SUM", "TAKE n l = splitAtPki (K \u2218 $= n) K l": "TAKE_splitAtPki", "\u2200n. TAKE n [] = []": "TAKE_nil", "\u2200l n. LENGTH l \u2264 n \u21d2 TAKE n l = l": "TAKE_LENGTH_TOO_LONG", "\u2200l m. m = LENGTH l \u21d2 TAKE m l = l": "TAKE_LENGTH_ID_rwt", "\u2200l. TAKE (LENGTH l) l = l": "TAKE_LENGTH_ID", "TAKE n (GENLIST f m) = GENLIST f (MIN n m)": "TAKE_GENLIST", "TAKE n l = [] \u21d4 n = 0 \u2228 l = []": "TAKE_EQ_NIL", "\u2200n l. TAKE n l ++ DROP n l = l": "TAKE_DROP", "0 < n \u21d2 TAKE n (x::xs) = x::TAKE (n \u2212 1) xs": "TAKE_cons", "(\u2200l. TAKE 0 l = []) \u2227 (\u2200n. TAKE (NUMERAL (BIT1 n)) [] = []) \u2227 (\u2200n. TAKE (NUMERAL (BIT2 n)) [] = []) \u2227 (\u2200n h t. TAKE (NUMERAL (BIT1 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n) \u2212 1) t) \u2227 \u2200n h t. TAKE (NUMERAL (BIT2 n)) (h::t) = h::TAKE (NUMERAL (BIT1 n)) t": "TAKE_compute", "\u2200n. LENGTH l1 < n \u21d2 TAKE n (l1 ++ l2) = l1 ++ TAKE (n \u2212 LENGTH l1) l2": "TAKE_APPEND2", "\u2200n. n \u2264 LENGTH l1 \u21d2 TAKE n (l1 ++ l2) = TAKE n l1": "TAKE_APPEND1", "TAKE 0 l = []": "TAKE_0", "\u2200n l. n < LENGTH l \u21d2 TAKE 1 (DROP n l) = [EL n l]": "TAKE1_DROP", "\u2200l. l \u2260 [] \u21d2 TAKE 1 l = [EL 0 l]": "TAKE1", "\u2200l1 l2. REVERSE l1 = l2 \u21d4 l1 = REVERSE l2": "SWAP_REVERSE_SYM", "\u2200l1 l2. l1 = REVERSE l2 \u21d4 l2 = REVERSE l1": "SWAP_REVERSE", "\u2200L. SUM L = SUM_ACC L 0": "SUM_SUM_ACC", "\u2200x l. SUM (SNOC x l) = SUM l + x": "SUM_SNOC", "\u2200ls1 ls2. LENGTH ls1 = LENGTH ls2 \u2227 (\u2200x y. f (x,y) = g x + h y) \u21d2 SUM (MAP f (ZIP (ls1,ls2))) = SUM (MAP g ls1) + SUM (MAP h ls2)": "SUM_MAP_PLUS_ZIP", "\u2200f g ls. SUM (MAP (\u03bbx. f x + g x) ls) = SUM (MAP f ls) + SUM (MAP g ls)": "SUM_MAP_PLUS", "\u2200f x ls. MEM x ls \u21d2 f x \u2264 SUM (MAP f ls)": "SUM_MAP_MEM_bound", "\u2200ls. SUM (MAP f ls) = FOLDL (\u03bba e. a + f e) 0 ls": "SUM_MAP_FOLDL", "\u2200ls. \u2211 f (set ls) \u2264 SUM (MAP f ls)": "SUM_IMAGE_LIST_TO_SET_upper_bound", "FINITE s \u21d2 \u2211 f s = SUM (MAP f (SET_TO_LIST s))": "SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST", "\u2200ls. SUM ls = 0 \u21d4 \u2200x. MEM x ls \u21d2 x = 0": "SUM_eq_0", "\u2200l1 l2. SUM (l1 ++ l2) = SUM l1 + SUM l2": "SUM_APPEND", "\u2200L n. SUM_ACC L n = SUM L + n": "SUM_ACC_SUM_LEM", "f (splitAtPki P k l) = splitAtPki P ($o f \u2218 k) l": "splitAtPki_RAND", "splitAtPki P k (MAP f l) = splitAtPki (combin$C ($o \u2218 P) f) (combin$C ($o \u2218 k \u2218 MAP f) (MAP f)) l": "splitAtPki_MAP", "splitAtPki P k l = case OLEAST i. i < LENGTH l \u2227 P i (EL i l) of NONE => k l [] | SOME i => k (TAKE i l) (DROP i l)": "splitAtPki_EQN", "(\u2200i. i < LENGTH l \u21d2 (P1 i (EL i l) \u21d4 P2 i (EL i l))) \u21d2 splitAtPki P1 k l = splitAtPki P2 k l": "splitAtPki_change_predicate", "\u2200l1 l2 P k. EVERYi (\u03bbi. $~ \u2218 P i) l1 \u2227 (0 < LENGTH l2 \u21d2 P (LENGTH l1) (HD l2)) \u21d2 splitAtPki P k (l1 ++ l2) = k l1 l2": "splitAtPki_APPEND", "\u2200P. P [] \u2227 (\u2200l. P l \u21d2 \u2200x. P (SNOC x l)) \u21d2 \u2200l. P l": "SNOC_INDUCT", "\u2200ll. ll = [] \u2228 \u2203x l. ll = SNOC x l": "SNOC_CASES", "\u2200e f. \u2203fn. fn [] = e \u2227 \u2200x l. fn (SNOC x l) = f x l (fn l)": "SNOC_Axiom", "\u2200x l. SNOC x l = l ++ [x]": "SNOC_APPEND", "\u2200x y a b. SNOC x y = SNOC a b \u21d4 x = a \u2227 y = b": "SNOC_11", "[f] <*> [x] = [f x]": "SINGL_SINGL_APPLY", "LIST_BIND l (\u03bbx. [x]) = l": "SINGL_LIST_APPLY_R", "LIST_BIND [x] f = f x": "SINGL_LIST_APPLY_L", "fs <*> [x] = [(\u03bbf. f x)] <*> fs": "SINGL_APPLY_PERMUTE", "[f] <*> l = MAP f l": "SINGL_APPLY_MAP", "([HD xs] = xs \u21d4 LENGTH xs = 1) \u2227 (xs = [HD xs] \u21d4 LENGTH xs = 1)": "SING_HD", "transitive R \u21d2 transitive (SHORTLEX R)": "SHORTLEX_transitive", "total (RC R) \u21d2 total (RC (SHORTLEX R))": "SHORTLEX_total", "(\u00acSHORTLEX R [] [] \u2227 \u00acSHORTLEX R (h1::t1) []) \u2227 SHORTLEX R [] (h2::t2) \u2227 (SHORTLEX R (h1::t1) (h2::t2) \u21d4 LENGTH t1 < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 (R h1 h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2))": "SHORTLEX_THM", "\u00acSHORTLEX R l []": "SHORTLEX_NIL2", "(\u2200x y. R1 x y \u21d2 R2 x y) \u21d2 SHORTLEX R1 x y \u21d2 SHORTLEX R2 x y": "SHORTLEX_MONO", "\u2200l1 l2. SHORTLEX R l1 l2 \u21d2 LENGTH l1 \u2264 LENGTH l2": "SHORTLEX_LENGTH_LE", "FINITE s \u21d2 SET_TO_LIST s = if s = \u2205 then [] else CHOICE s::SET_TO_LIST (REST s)": "SET_TO_LIST_THM", "SET_TO_LIST {x} = [x]": "SET_TO_LIST_SING", "\u2200s. FINITE s \u21d2 set (SET_TO_LIST s) = s": "SET_TO_LIST_INV", "\u2200P. (\u2200s. (FINITE s \u2227 s \u2260 \u2205 \u21d2 P (REST s)) \u21d2 P s) \u21d2 \u2200v. P v": "SET_TO_LIST_IND", "\u2200s. FINITE s \u21d2 \u2200x. x \u2208 s \u21d4 MEM x (SET_TO_LIST s)": "SET_TO_LIST_IN_MEM", "SET_TO_LIST \u2205 = []": "SET_TO_LIST_EMPTY", "\u2200s. FINITE s \u21d2 LENGTH (SET_TO_LIST s) = CARD s": "SET_TO_LIST_CARD", "REVERSE [] = [] \u2227 \u2200x l. REVERSE (x::l) = SNOC x (REVERSE l)": "REVERSE_SNOC_DEF", "\u2200x l. REVERSE (SNOC x l) = x::REVERSE l": "REVERSE_SNOC", "\u2200l. REVERSE (REVERSE l) = l": "REVERSE_REVERSE", "\u2200L. REVERSE L = REV L []": "REVERSE_REV", "REVERSE \u2218 REVERSE \u2218 f = f": "REVERSE_o_REVERSE", "REVERSE (GENLIST f n) = GENLIST (\u03bbm. f (PRE n \u2212 m)) n": "REVERSE_GENLIST", "REVERSE l = [e] \u21d4 l = [e]": "REVERSE_EQ_SING", "REVERSE l = [] \u21d4 l = []": "REVERSE_EQ_NIL", "\u2200l1 l2. REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1": "REVERSE_APPEND", "\u2200l1 l2. REVERSE l1 = REVERSE l2 \u21d4 l1 = l2": "REVERSE_11", "\u2200L1 L2. REV L1 L2 = REVERSE L1 ++ L2": "REV_REVERSE_LEM", "\u2200f1 f2 x1 x2. x1 = x2 \u2227 (\u2200a. MEM a x2 \u21d2 f1 a = f2 a) \u21d2 OPT_MMAP f1 x1 = OPT_MMAP f2 x2": "OPT_MMAP_cong", "oHD [] = NONE \u2227 oHD (h::t) = SOME h": "oHD_thm", "\u2200xs n. oEL n xs = if n < LENGTH xs then SOME (EL n xs) else NONE": "oEL_THM", "oEL n (TAKE m xs) = SOME x \u21d2 oEL n xs = SOME x": "oEL_TAKE_E", "\u2200xs i n x. oEL n (LUPDATE x i xs) = if i \u2260 n then oEL n xs else if i < LENGTH xs then SOME x else NONE": "oEL_LUPDATE", "\u2200xs n y. oEL n xs = SOME y \u21d4 n < LENGTH xs \u2227 y = EL n xs": "oEL_EQ_EL", "oEL n (DROP m xs) = oEL (m + n) xs": "oEL_DROP", "\u2200l. NULL l \u21d4 LENGTH l = 0": "NULL_LENGTH", "\u2200n f. NULL (GENLIST f n) \u21d4 n = 0": "NULL_GENLIST", "\u2200P ls. NULL (FILTER P ls) \u21d4 \u2200x. MEM x ls \u21d2 \u00acP x": "NULL_FILTER", "\u2200l. NULL l \u21d4 l = []": "NULL_EQ", "NULL (l1 ++ l2) \u21d4 NULL l1 \u2227 NULL l2": "NULL_APPEND", "NULL [] \u2227 \u2200h t. \u00acNULL (h::t)": "NULL", "\u2200l. set (nub l) = set l": "nub_set", "\u2200l1 l2. nub (l1 ++ l2) = nub (FILTER (\u03bbx. \u00acMEM x l2) l1) ++ nub l2": "nub_append", "NRC R n x y \u21d4 \u2203ls. LRC R ls x y \u2227 LENGTH ls = n": "NRC_LRC", "\u2200l. \u00acNULL l \u21d4 \u2203e. MEM e l": "NOT_NULL_MEM", "x \u2260 [] \u21d4 0 < LENGTH x": "NOT_NIL_EQ_LENGTH_NOT_0", "\u2200a1 a0. [] \u2260 a0::a1": "list_distinct", "\u2200P l. \u00acEXISTS P l \u21d4 EVERY ($~ \u2218 P) l": "NOT_EXISTS", "\u2200P l. \u00acEVERY P l \u21d4 EXISTS ($~ \u2218 P) l": "NOT_EVERY", "\u2200h1 h2. h1 \u2260 h2 \u21d2 \u2200l1 l2. h1::l1 \u2260 h2::l2": "NOT_EQ_LIST", "\u2200a1 a0. a0::a1 \u2260 []": "NOT_CONS_NIL", "(\u2200x. P x \u21d2 Q x) \u21d2 EXISTS P l \u21d2 EXISTS Q l": "MONO_EXISTS", "(\u2200x. P x \u21d2 Q x) \u21d2 EVERY P l \u21d2 EVERY Q l": "MONO_EVERY", "LENGTH (FST ps) = LENGTH (SND ps) \u2227 MEM p (ZIP ps) \u21d2 MEM (FST p) (FST ps) \u2227 MEM (SND p) (SND ps)": "MEM_ZIP_MEM_MAP", "\u2200l1 l2 p. LENGTH l1 = LENGTH l2 \u21d2 (MEM p (ZIP (l1,l2)) \u21d4 \u2203n. n < LENGTH l1 \u2227 p = (EL n l1,EL n l2))": "MEM_ZIP", "MEM e l \u21d4 \u2203pfx sfx. l = pfx ++ [e] ++ sfx \u2227 \u00acMEM e sfx": "MEM_SPLIT_APPEND_last", "MEM e l \u21d4 \u2203pfx sfx. l = pfx ++ [e] ++ sfx \u2227 \u00acMEM e pfx": "MEM_SPLIT_APPEND_first", "\u2200x l. MEM x l \u21d4 \u2203l1 l2. l = l1 ++ x::l2": "MEM_SPLIT", "\u2200y x l. MEM y (SNOC x l) \u21d4 y = x \u2228 MEM y l": "MEM_SNOC", "\u2200s. FINITE s \u21d2 \u2200x. MEM x (SET_TO_LIST s) \u21d4 x \u2208 s": "MEM_SET_TO_LIST", "\u2200l x. MEM x (REVERSE l) \u21d4 MEM x l": "MEM_REVERSE", "\u2200l f x. MEM x (MAP f l) \u21d4 \u2203y. x = f y \u2227 MEM y l": "MEM_MAP", "\u2200l x y i. MEM x (LUPDATE y i l) \u21d2 x = y \u2228 MEM x l": "MEM_LUPDATE_E", "\u2200l x y i. MEM x (LUPDATE y i l) \u21d4 i < LENGTH l \u2227 x = y \u2228 \u2203j. j < LENGTH l \u2227 i \u2260 j \u2227 EL j l = x": "MEM_LUPDATE", "MEM x (GENLIST f n) \u21d4 \u2203m. m < n \u2227 x = f m": "MEM_GENLIST", "\u2200x L. MEM x (FLAT L) \u21d4 \u2203l. MEM l L \u2227 MEM x l": "MEM_FLAT", "\u2200P L x. MEM x (FILTER P L) \u21d4 P x \u2227 MEM x L": "MEM_FILTER", "\u2200x y l. MEM (x,y) l \u21d2 \u2203z. x = FST z \u2227 MEM z l": "mem_exists_set", "\u2200l x. MEM x l \u21d4 \u2203n. n < LENGTH l \u2227 x = EL n l": "MEM_EL", "\u2200P ls x. MEM x (dropWhile P ls) \u21d2 MEM x ls": "MEM_dropWhile_IMP", "\u2200x ls n. MEM x (DROP n ls) \u21d4 \u2203m. m + n < LENGTH ls \u2227 x = EL (m + n) ls": "MEM_DROP", "\u2200a b c d x. a ++ [x] ++ b = c ++ [x] ++ d \u2227 \u00acMEM x b \u2227 \u00acMEM x a \u21d2 a = c \u2227 b = d": "MEM_APPEND_lemma", "\u2200e l1 l2. MEM e (l1 ++ l2) \u21d4 MEM e l1 \u2228 MEM e l2": "MEM_APPEND", "(\u2200x. MEM x [] \u21d4 F) \u2227 \u2200x h t. MEM x (h::t) \u21d4 x = h \u2228 MEM x t": "MEM", "\u2200ls f. MAP f (ZIP (ls,ls)) = MAP (\u03bbx. f (x,x)) ls": "MAP_ZIP_SAME", "LENGTH l1 = LENGTH l2 \u21d2 MAP FST (ZIP (l1,l2)) = l1 \u2227 MAP SND (ZIP (l1,l2)) = l2 \u2227 MAP (f \u2218 FST) (ZIP (l1,l2)) = MAP f l1 \u2227 MAP (g \u2218 SND) (ZIP (l1,l2)) = MAP g l2": "MAP_ZIP", "\u2200l f. \u00acNULL l \u21d2 MAP f (TL l) = TL (MAP f l)": "MAP_TL", "\u2200f n l. MAP f (TAKE n l) = TAKE n (MAP f l)": "MAP_TAKE", "\u2200f x l. MAP f (SNOC x l) = SNOC (f x) (MAP f l)": "MAP_SNOC", "\u2200f g. MAP (f \u2218 g) = MAP f \u2218 MAP g": "MAP_o", "\u2200f g l. MAP f (MAP g l) = MAP (f \u2218 g) l": "MAP_MAP_o", "MAP f (LIST_BIND l g) = LIST_BIND l (MAP f \u2218 g)": "MAP_LIST_BIND", "MAP (\u03bbx. x) l = l \u2227 MAP I l = l": "MAP_ID", "\u2200f g n. MAP f (GENLIST g n) = GENLIST (f \u2218 g) n": "MAP_GENLIST", "\u2200ls. ls \u2260 [] \u21d2 MAP f (FRONT ls) = FRONT (MAP f ls)": "MAP_FRONT", "MAP f (FLAT l) = FLAT (MAP (MAP f) l)": "MAP_FLAT", "MAP f l = [x] \u21d4 \u2203x0. l = [x0] \u2227 x = f x0": "MAP_EQ_SING", "\u2200l f. (MAP f l = [] \u21d4 l = []) \u2227 ([] = MAP f l \u21d4 l = [])": "MAP_EQ_NIL", "\u2200f1 f2 l. MAP f1 l = MAP f2 l \u21d4 \u2200e. MEM e l \u21d2 f1 e = f2 e": "MAP_EQ_f", "\u2200f1 f2 l1 l2. MAP f1 l1 = MAP f2 l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 LIST_REL (\u03bbx y. f1 x = f2 y) l1 l2": "MAP_EQ_EVERY2", "MAP f l = h::t \u21d4 \u2203x0 t0. l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0": "MAP_EQ_CONS", "MAP f l = l1 ++ l2 \u21d4 \u2203l10 l20. l = l10 ++ l20 \u2227 l1 = MAP f l10 \u2227 l2 = MAP f l20": "MAP_EQ_APPEND", "\u2200l i. MAP f (DROP i l) = DROP i (MAP f l)": "MAP_DROP", "\u2200l1 l2 f f'. l1 = l2 \u2227 (\u2200x. MEM x l2 \u21d2 f x = f' x) \u21d2 MAP f l1 = MAP f' l2": "MAP_CONG", "\u2200xs ys. MAP f1 xs ++ MAP g1 ys = MAP f2 xs ++ MAP g2 ys \u21d4 MAP f1 xs = MAP f2 xs \u2227 MAP g1 ys = MAP g2 ys": "MAP_APPEND_MAP_EQ", "\u2200f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2": "MAP_APPEND", "\u2200l1 l2. LENGTH l1 = LENGTH l2 \u21d2 \u2200f. MAP2 f l1 l2 = MAP (UNCURRY f) (ZIP (l1,l2))": "MAP2_MAP", "MAP2 f x [] = []": "MAP2_NIL", "\u2200P. (\u2200f h1 t1 h2 t2. P f t1 t2 \u21d2 P f (h1::t1) (h2::t2)) \u2227 (\u2200f y. P f [] y) \u2227 (\u2200f v4 v5. P f (v4::v5) []) \u21d2 \u2200v v1 v2. P v v1 v2": "MAP2_ind", "(\u2200t2 t1 h2 h1 f. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2) \u2227 (\u2200y f. MAP2 f [] y = []) \u2227 \u2200v5 v4 f. MAP2 f (v4::v5) [] = []": "MAP2_DEF", "\u2200l1 l1' l2 l2' f f'. l1 = l1' \u2227 l2 = l2' \u2227 (\u2200x y. MEM x l1' \u2227 MEM y l2' \u21d2 f x y = f' x y) \u21d2 MAP2 f l1 l2 = MAP2 f' l1' l2'": "MAP2_CONG", "\u2200xs ys xs1 ys1 f. LENGTH xs = LENGTH xs1 \u21d2 MAP2 f (xs ++ ys) (xs1 ++ ys1) = MAP2 f xs xs1 ++ MAP2 f ys ys1": "MAP2_APPEND", "(\u2200f. MAP2 f [] [] = []) \u2227 \u2200f h1 t1 h2 t2. MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2": "MAP2", "\u2200xs n f h. LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) = MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs)": "LUPDATE_SOME_MAP", "\u2200ys k x y. LUPDATE x k (SNOC y ys) = if k = LENGTH ys then SNOC x ys else SNOC y (LUPDATE x k ys)": "LUPDATE_SNOC", "(\u2200e n l. LENGTH (LUPDATE e n l) = LENGTH l) \u2227 \u2200e n l p. p < LENGTH l \u21d2 EL p (LUPDATE e n l) = if p = n then e else EL p l": "LUPDATE_SEM", "\u2200n ls. n < LENGTH ls \u21d2 LUPDATE (EL n ls) n ls = ls": "LUPDATE_SAME", "\u2200xs n x. LUPDATE x n xs = [] \u21d4 xs = []": "LUPDATE_NIL", "\u2200x n l f. MAP f (LUPDATE x n l) = LUPDATE (f x) n (MAP f l)": "LUPDATE_MAP", "\u2200xs x y ys. LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys": "LUPDATE_LENGTH", "(\u2200e n. LUPDATE e n [] = []) \u2227 (\u2200e x l. LUPDATE e 0 (x::l) = e::l) \u2227 (\u2200e n x l. LUPDATE e (NUMERAL (BIT1 n)) (x::l) = x::LUPDATE e (NUMERAL (BIT1 n) \u2212 1) l) \u2227 \u2200e n x l. LUPDATE e (NUMERAL (BIT2 n)) (x::l) = x::LUPDATE e (NUMERAL (BIT1 n)) l": "LUPDATE_compute", "\u2200v l1 x l2 l3. LUPDATE v (LENGTH l1) (l1 ++ [x] ++ l2) = l1 ++ [v] ++ l2": "lupdate_append2", "\u2200x n l1 l2. n < LENGTH l1 \u21d2 LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2": "lupdate_append", "LRC R (h::t) x y \u2227 MEM e t \u21d2 \u2203z p. R z e \u2227 LRC R p x z": "LRC_MEM_right", "LRC R ls x y \u2227 MEM e ls \u21d2 \u2203z t. R e z \u2227 LRC R t z y": "LRC_MEM", "transitive R \u21d2 transitive (LLEX R)": "LLEX_transitive", "total (RC R) \u21d2 total (RC (LLEX R))": "LLEX_total", "(\u00acLLEX R [] [] \u2227 \u00acLLEX R (h1::t1) []) \u2227 LLEX R [] (h2::t2) \u2227 (LLEX R (h1::t1) (h2::t2) \u21d4 R h1 h2 \u2228 h1 = h2 \u2227 LLEX R t1 t2)": "LLEX_THM", "(\u2203a b. R a b) \u21d2 \u00acWF (LLEX R)": "LLEX_not_WF", "\u00acLLEX R l []": "LLEX_NIL2", "(\u2200x y. R1 x y \u21d2 R2 x y) \u21d2 LLEX R1 x y \u21d2 LLEX R2 x y": "LLEX_MONO", "\u2200R l1 l2. LLEX R l1 l2 \u21d4 \u2203n. n \u2264 LENGTH l1 \u2227 n < LENGTH l2 \u2227 TAKE n l1 = TAKE n l2 \u2227 (n < LENGTH l1 \u21d2 R (EL n l1) (EL n l2))": "LLEX_EL_THM", "\u2200R l1 l2 R' l1' l2'. l1 = l1' \u2227 l2 = l2' \u2227 (\u2200a b. MEM a l1' \u2227 MEM b l2' \u21d2 (R a b \u21d4 R' a b)) \u21d2 (LLEX R l1 l2 \u21d4 LLEX R' l1' l2')": "LLEX_CONG", "set [] = \u2205 \u2227 set (h::t) = h INSERT set t": "LIST_TO_SET", "set (SNOC x ls) = x INSERT set ls": "LIST_TO_SET_SNOC", "\u2200ls. set (REVERSE ls) = set ls": "LIST_TO_SET_REVERSE", "\u2200f l. set (MAP f l) = IMAGE f (set l)": "LIST_TO_SET_MAP", "\u2200f n. set (GENLIST f n) = IMAGE f (count n)": "LIST_TO_SET_GENLIST", "\u2200ls. set (FLAT ls) = BIGUNION (set (MAP set ls))": "LIST_TO_SET_FLAT", "set (FILTER P l) = {x | P x} \u2229 set l": "LIST_TO_SET_FILTER", "(set l = \u2205 \u21d4 l = []) \u2227 (\u2205 = set l \u21d4 l = [])": "LIST_TO_SET_EQ_EMPTY", "\u2200l1 l2. set l2 DIFF set l1 = set (FILTER (\u03bbx. \u00acMEM x l1) l2)": "list_to_set_diff", "\u2200l1 l2. set (l1 ++ l2) = set l1 \u222a set l2": "LIST_TO_SET_APPEND", "\u2200M N f f'. M = N \u2227 (\u2200x. MEM x N \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' N": "list_size_cong", "\u2200l1 l2 l3. (\u2200n. n < LENGTH l1 \u2227 R (EL n l1) (EL n l2) \u2227 R (EL n l2) (EL n l3) \u21d2 R (EL n l1) (EL n l3)) \u2227 LIST_REL R l1 l2 \u2227 LIST_REL R l2 l3 \u21d2 LIST_REL R l1 l3": "LIST_REL_trans", "\u2200R LIST_REL'. LIST_REL' [] [] \u2227 (\u2200h1 h2 t1 t2. R h1 h2 \u2227 LIST_REL R t1 t2 \u2227 LIST_REL' t1 t2 \u21d2 LIST_REL' (h1::t1) (h2::t2)) \u21d2 \u2200a0 a1. LIST_REL R a0 a1 \u21d2 LIST_REL' a0 a1": "LIST_REL_strongind", "\u2200xs1 zs. LIST_REL P zs (xs1 ++ xs2) \u21d4 \u2203ys1 ys2. zs = ys1 ++ ys2 \u2227 LIST_REL P ys1 xs1 \u2227 LIST_REL P ys2 xs2": "LIST_REL_SPLIT2", "\u2200xs1 zs. LIST_REL P (xs1 ++ xs2) zs \u21d4 \u2203ys1 ys2. zs = ys1 ++ ys2 \u2227 LIST_REL P xs1 ys1 \u2227 LIST_REL P xs2 ys2": "LIST_REL_SPLIT1", "(LIST_REL R (SNOC x xs) yys \u21d4 \u2203y ys. yys = SNOC y ys \u2227 LIST_REL R xs ys \u2227 R x y) \u2227 (LIST_REL R xxs (SNOC y ys) \u21d4 \u2203x xs. xxs = SNOC x xs \u2227 LIST_REL R xs ys \u2227 R x y)": "LIST_REL_SNOC", "\u2200R. LIST_REL R [] [] \u2227 \u2200h1 h2 t1 t2. R h1 h2 \u2227 LIST_REL R t1 t2 \u21d2 LIST_REL R (h1::t1) (h2::t2)": "LIST_REL_rules", "\u2200R1 R2. LIST_REL (R1 \u2218\u1d63 R2) = LIST_REL R1 \u2218\u1d63 LIST_REL R2": "LIST_REL_O", "(LIST_REL R [] y \u21d4 y = []) \u2227 (LIST_REL R x [] \u21d4 x = [])": "LIST_REL_NIL", "(\u2200x y. R1 x y \u21d2 R2 x y) \u21d2 LIST_REL R1 l1 l2 \u21d2 LIST_REL R2 l1 l2": "EVERY2_mono", "\u2200xs ys P x. LIST_REL P xs ys \u2227 MEM x xs \u21d2 \u2203y. MEM y ys \u2227 P x y": "LIST_REL_MEM_IMP", "LIST_REL R (MAP f l1) (MAP f l2) \u21d4 LIST_REL (inv_image R f) l1 l2": "LIST_REL_MAP_inv_image", "LIST_REL (\u03bba b. R a b) l1 (MAP f l2) \u21d4 LIST_REL (\u03bba b. R a (f b)) l1 l2": "LIST_REL_MAP2", "LIST_REL R (MAP f l1) l2 \u21d4 LIST_REL (R \u2218 f) l1 l2": "LIST_REL_MAP1", "\u2200x y. LIST_REL R x y \u21d2 LENGTH x = LENGTH y": "LIST_REL_LENGTH", "\u2200R LIST_REL'. LIST_REL' [] [] \u2227 (\u2200h1 h2 t1 t2. R h1 h2 \u2227 LIST_REL' t1 t2 \u21d2 LIST_REL' (h1::t1) (h2::t2)) \u21d2 \u2200a0 a1. LIST_REL R a0 a1 \u21d2 LIST_REL' a0 a1": "LIST_REL_ind", "\u2200R l1 l2. LIST_REL R l1 l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 EVERY (UNCURRY R) (ZIP (l1,l2))": "LIST_REL_EVERY_ZIP", "LIST_REL $= = $=": "LIST_REL_eq", "\u2200R l1 l2. LIST_REL R l1 l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 \u2200n. n < LENGTH l1 \u21d2 R (EL n l1) (EL n l2)": "LIST_REL_EL_EQN", "(LIST_REL R [] [] \u21d4 T) \u2227 (LIST_REL R (a::as) [] \u21d4 F) \u2227 (LIST_REL R [] (b::bs) \u21d4 F) \u2227 (LIST_REL R (a::as) (b::bs) \u21d4 R a b \u2227 LIST_REL R as bs)": "LIST_REL_def", "LIST_REL R xs (h::t) \u21d4 \u2203h' t'. xs = h'::t' \u2227 R h' h \u2227 LIST_REL R t' t": "LIST_REL_CONS2", "LIST_REL R (h::t) xs \u21d4 \u2203h' t'. xs = h'::t' \u2227 R h h' \u2227 LIST_REL R t t'": "LIST_REL_CONS1", "LIST_REL (\u03bba b. P a b \u2227 Q a b) l1 l2 \u21d4 LIST_REL (\u03bba b. P a b) l1 l2 \u2227 LIST_REL (\u03bba b. Q a b) l1 l2": "LIST_REL_CONJ", "\u2200R a0 a1. LIST_REL R a0 a1 \u21d4 a0 = [] \u2227 a1 = [] \u2228 \u2203h1 h2 t1 t2. a0 = h1::t1 \u2227 a1 = h2::t2 \u2227 R h1 h2 \u2227 LIST_REL R t1 t2": "LIST_REL_cases", "LIST_REL R l1 l2 \u2227 LIST_REL R l3 l4 \u21d2 LIST_REL R (l1 ++ l3) (l2 ++ l4)": "LIST_REL_APPEND_suff", "\u2200xs ys xs1 ys1. LIST_REL P (xs ++ xs1) (ys ++ ys1) \u2227 LENGTH xs = LENGTH ys \u21d2 LIST_REL P xs ys \u2227 LIST_REL P xs1 ys1": "LIST_REL_APPEND_IMP", "LENGTH x1 = LENGTH x2 \u21d2 (LIST_REL R (x1 ++ y1) (x2 ++ y2) \u21d4 LIST_REL R x1 x2 \u2227 LIST_REL R y1 y2)": "LIST_REL_APPEND_EQ", "LIST_REL R l1 l2 \u2227 LIST_REL R l3 l4 \u21d4 LIST_REL R (l1 ++ l3) (l2 ++ l4) \u2227 LENGTH l1 = LENGTH l2 \u2227 LENGTH l3 = LENGTH l4": "LIST_REL_APPEND", "\u2200l1 l2. l1 \u2260 l2 \u21d2 \u2200h1 h2. h1::l1 \u2260 h2::l2": "LIST_NOT_EQ", "\u2200l. l = [] \u2228 \u2203h t. l = h::t": "list_CASES", "\u2200P. P [] \u2227 (\u2200t. P t \u21d2 \u2200h. P (h::t)) \u21d2 \u2200l. P l": "list_INDUCT", "\u2200P. P [] \u2227 (\u2200l. P l \u21d2 \u2200a. P (a::l)) \u21d2 \u2200l. P l": "list_INDUCT0", "\u2200l1 l2. l1 = l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 \u2200x. x < LENGTH l1 \u21d2 EL x l1 = EL x l2": "LIST_EQ_REWRITE", "\u2200l1 l2. MAP FST l1 = MAP FST l2 \u2227 MAP SND l1 = MAP SND l2 \u21d2 l1 = l2": "LIST_EQ_MAP_PAIR", "\u2200l1 l2. LENGTH l1 = LENGTH l2 \u2227 (\u2200x. x < LENGTH l1 \u21d2 EL x l1 = EL x l2) \u21d2 l1 = l2": "LIST_EQ", "list_CASE x v f = v' \u21d4 x = [] \u2227 v = v' \u2228 \u2203a l. x = a::l \u2227 f a l = v'": "list_case_eq", "\u2200M M' v f. M = M' \u2227 (M' = [] \u21d2 v = v') \u2227 (\u2200a0 a1. M' = a0::a1 \u21d2 f a0 a1 = f' a0 a1) \u21d2 list_CASE M v f = list_CASE M' v' f'": "list_case_cong", "\u2200l. list_CASE l b f = if NULL l then b else f (HD l) (TL l)": "list_case_compute", "LIST_BIND [] f = [] \u2227 LIST_BIND (h::t) f = f h ++ LIST_BIND t f": "LIST_BIND_THM", "LIST_BIND (MAP f l) g = LIST_BIND l (g \u2218 f)": "LIST_BIND_MAP", "LIST_BIND (LIST_BIND l g) f = LIST_BIND l (combin$C LIST_BIND f \u2218 g)": "LIST_BIND_LIST_BIND", "LIST_BIND l (\u03bbx. x) = FLAT l \u2227 LIST_BIND l I = FLAT l": "LIST_BIND_ID", "LIST_BIND (l1 ++ l2) f = LIST_BIND l1 f ++ LIST_BIND l2 f": "LIST_BIND_APPEND", "\u2200x f. \u2203!fn1. fn1 [] = x \u2227 \u2200h t. fn1 (h::t) = f (fn1 t) h t": "list_Axiom_old", "\u2200f0 f1. \u2203fn. fn [] = f0 \u2227 \u2200a0 a1. fn (a0::a1) = f1 a0 a1 (fn a1)": "list_Axiom", "[$o] <*> fs <*> gs <*> xs = fs <*> (gs <*> xs)": "LIST_APPLY_o", "\u2200a0 a1 a0' a1'. a0::a1 = a0'::a1' \u21d4 a0 = a0' \u2227 a1 = a1'": "CONS_11", "\u2200xs ys. LENGTH (ZIP (xs,ys)) = MIN (LENGTH xs) (LENGTH ys)": "LENGTH_ZIP_MIN", "\u2200l1 l2. LENGTH l1 = LENGTH l2 \u21d2 LENGTH (ZIP (l1,l2)) = LENGTH l1 \u2227 LENGTH (ZIP (l1,l2)) = LENGTH l2": "LENGTH_ZIP", "\u2200pl. LENGTH (FST (UNZIP pl)) = LENGTH pl \u2227 LENGTH (SND (UNZIP pl)) = LENGTH pl": "LENGTH_UNZIP", "\u2200l. 0 < LENGTH l \u21d2 LENGTH (TL l) = LENGTH l \u2212 1": "LENGTH_TL", "LENGTH (TAKE n xs) = if n \u2264 LENGTH xs then n else LENGTH xs": "LENGTH_TAKE_EQ", "\u2200n l. n \u2264 LENGTH l \u21d2 LENGTH (TAKE n l) = n": "LENGTH_TAKE", "\u2200x l. LENGTH (SNOC x l) = SUC (LENGTH l)": "LENGTH_SNOC", "\u2200l. LENGTH (REVERSE l) = LENGTH l": "LENGTH_REVERSE", "LENGTH \u2218 REVERSE = LENGTH \u2227 LENGTH \u2218 REVERSE \u2218 f = LENGTH \u2218 f": "LENGTH_o_REVERSE", "\u2200l1 l2. LENGTH (nub (l1 ++ l2)) = LENGTH (nub l1) + LENGTH (nub (FILTER (\u03bbx. \u00acMEM x l1) l2))": "length_nub_append", "0 = LENGTH l \u21d4 l = []": "LENGTH_NIL_SYM", "\u2200l. LENGTH l = 0 \u21d4 l = []": "LENGTH_NIL", "\u2200xs ys. LENGTH (MAP2 f xs ys) = MIN (LENGTH xs) (LENGTH ys)": "LENGTH_MAP2", "\u2200l f. LENGTH (MAP f l) = LENGTH l": "LENGTH_MAP", "\u2200x n ys. LENGTH (LUPDATE x n ys) = LENGTH ys": "LENGTH_LUPDATE", "\u2200l1 l2. LENGTH l1 < LENGTH l2 \u21d2 SHORTLEX R l1 l2": "LENGTH_LT_SHORTLEX", "\u2200L. LENGTH L = LEN L 0": "LENGTH_LEN", "\u2200f n. LENGTH (GENLIST f n) = n": "LENGTH_GENLIST", "\u2200x xs. LENGTH (FRONT (x::xs)) = LENGTH xs": "LENGTH_FRONT_CONS", "\u2200P Q. (\u2200x. P x \u21d2 Q x) \u21d2 \u2200ls. LENGTH (FILTER P ls) \u2264 LENGTH (FILTER Q ls)": "LENGTH_FILTER_LEQ_MONO", "\u2200l n1 n2. LENGTH l = n1 + n2 \u21d4 \u2203l1 l2. LENGTH l1 = n1 \u2227 LENGTH l2 = n2 \u2227 l = l1 ++ l2": "LENGTH_EQ_SUM", "(\u2200l. LENGTH l = 0 \u21d4 l = []) \u2227 (\u2200l n. LENGTH l = NUMERAL (BIT1 n) \u21d4 \u2203h l'. LENGTH l' = NUMERAL (BIT1 n) \u2212 1 \u2227 l = h::l') \u2227 (\u2200l n. LENGTH l = NUMERAL (BIT2 n) \u21d4 \u2203h l'. LENGTH l' = NUMERAL (BIT1 n) \u2227 l = h::l') \u2227 \u2200l n1 n2. LENGTH l = n1 + n2 \u21d4 \u2203l1 l2. LENGTH l1 = n1 \u2227 LENGTH l2 = n2 \u2227 l = l1 ++ l2": "LENGTH_EQ_NUM_compute", "(\u2200l. LENGTH l = 0 \u21d4 l = []) \u2227 (\u2200l n. LENGTH l = SUC n \u21d4 \u2203h l'. LENGTH l' = n \u2227 l = h::l') \u2227 \u2200l n1 n2. LENGTH l = n1 + n2 \u21d4 \u2203l1 l2. LENGTH l1 = n1 \u2227 LENGTH l2 = n2 \u2227 l = l1 ++ l2": "LENGTH_EQ_NUM", "\u2200P. (\u2200l. LENGTH l = 0 \u21d2 P l) \u21d4 P []": "LENGTH_EQ_NIL", "\u2200P n. (\u2200l. LENGTH l = SUC n \u21d2 P l) \u21d4 \u2200l. LENGTH l = n \u21d2 (\u03bbl. \u2200x. P (x::l)) l": "LENGTH_EQ_CONS", "\u2200P ls. LENGTH (dropWhile P ls) \u2264 LENGTH ls": "LENGTH_dropWhile_LESS_EQ", "\u2200n l. LENGTH (DROP n l) = LENGTH l \u2212 n": "LENGTH_DROP", "\u2200l n. LENGTH l = SUC n \u21d4 \u2203h l'. LENGTH l' = n \u2227 l = h::l'": "LENGTH_CONS", "\u2200l1 l2. LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2": "LENGTH_APPEND", "\u2200L n. LEN L n = LENGTH L + n": "LEN_LENGTH_LEM", "list_CASE = (\u03bbl b f. if NULL l then b else f (HD l) (TL l))": "lazy_list_case_compute", "\u2200x l. LAST (SNOC x l) = x": "LAST_SNOC", "\u2200ls. ls \u2260 [] \u21d2 LAST (REVERSE ls) = HD ls": "LAST_REVERSE", "\u2200l f. l \u2260 [] \u21d2 LAST (MAP f l) = f (LAST l)": "LAST_MAP", "\u2200ls. ls \u2260 [] \u21d2 LAST ls = EL (PRE (LENGTH ls)) ls": "LAST_EL", "\u2200l n. n < LENGTH l \u21d2 LAST (DROP n l) = LAST l": "last_drop", "LAST (h::t) = if t = [] then h else LAST t": "LAST_CONS_cond", "(\u2200x. LAST [x] = x) \u2227 \u2200x y z. LAST (x::y::z) = LAST (y::z)": "LAST_CONS", "(\u2200x. LAST [x] = x) \u2227 \u2200h1 h2 t. LAST (h1::h2::t) = LAST (h2::t)": "LAST_compute", "\u2200h l1 l2. LAST (l1 ++ h::l2) = LAST (h::l2)": "LAST_APPEND_CONS", "\u2200s. FINITE s \u21d2 \u2200f a. ITSET f s a = FOLDL (combin$C f) a (SET_TO_LIST s)": "ITSET_eq_FOLDL_SET_TO_LIST", "([] \u227c l \u21d4 T) \u2227 (h::t \u227c [] \u21d4 F) \u2227 (h1::t1 \u227c h2::t2 \u21d4 h1 = h2 \u2227 t1 \u227c t2)": "isPREFIX_THM", "x \u227c [] \u21d4 x = []": "isPREFIX_NILR", "x \u227c y::ys \u21d4 x = [] \u2228 \u2203xs. x = y::xs \u2227 xs \u227c ys": "isPREFIX_CONSR", "\u2200f l1 l2. INJ f (set l1 \u222a set l2) \ud835\udd4c(:\u03b2) \u21d2 (MAP f l1 = MAP f l2 \u21d4 l1 = l2)": "INJ_MAP_EQ_IFF", "\u2200f l1 l2. INJ f (set l1 \u222a set l2) \ud835\udd4c(:\u03b2) \u2227 MAP f l1 = MAP f l2 \u21d2 l1 = l2": "INJ_MAP_EQ", "INFINITE \ud835\udd4c(:\u03b1 list)": "INFINITE_LIST_UNIV", "\u2200xs h i. P h \u2227 EVERY P xs \u21d2 EVERY P (LUPDATE h i xs)": "IMP_EVERY_LUPDATE", "\u2200f ls. IMAGE (\u03bbn. f (EL n ls)) (count (LENGTH ls)) = IMAGE f (set ls)": "IMAGE_EL_count_LENGTH", "\u2200x. x \u2260 [] \u21d2 HD (REVERSE x) = LAST x": "HD_REVERSE", "\u2200n f. 0 < n \u21d2 HD (GENLIST f n) = f 0": "HD_GENLIST_COR", "HD (GENLIST f (SUC n)) = f 0": "HD_GENLIST", "\u2200P ls. EXISTS ($~ \u2218 P) ls \u21d2 \u00acP (HD (dropWhile P ls))": "HD_dropWhile", "\u2200n l. n < LENGTH l \u21d2 HD (DROP n l) = EL n l": "HD_DROP", "GENLIST ($+ a) n1 ++ GENLIST ($+ (n1 + a)) n2 = GENLIST ($+ a) (n1 + n2)": "GENLIST_PLUS_APPEND", "GENLIST f 0 = [] \u2227 GENLIST f (NUMERAL n) = GENLIST_AUX f (NUMERAL n) []": "GENLIST_NUMERALS", "\u2200x. GENLIST (\u03bbi. EL i x) (LENGTH x) = x": "GENLIST_ID", "\u2200n. GENLIST f n = GENLIST_AUX f n []": "GENLIST_GENLIST_AUX", "\u2200n f g. GENLIST f n = GENLIST g n \u21d4 \u2200x. x < n \u21d2 f x = g x": "GENLIST_FUN_EQ", "\u2200f ls. GENLIST (\u03bbn. f (EL n ls)) (LENGTH ls) = MAP f ls": "GENLIST_EL_MAP", "\u2200ls f n. n = LENGTH ls \u2227 (\u2200i. i < n \u21d2 f i = EL i ls) \u21d2 GENLIST f n = ls": "GENLIST_EL", "GENLIST f (SUC n) = f 0::GENLIST (f \u2218 SUC) n": "GENLIST_CONS", "(\u2200f l. GENLIST_AUX f 0 l = l) \u2227 (\u2200f n l. GENLIST_AUX f (NUMERAL (BIT1 n)) l = GENLIST_AUX f (NUMERAL (BIT1 n) \u2212 1) (f (NUMERAL (BIT1 n) \u2212 1)::l)) \u2227 \u2200f n l. GENLIST_AUX f (NUMERAL (BIT2 n)) l = GENLIST_AUX f (NUMERAL (BIT1 n)) (f (NUMERAL (BIT1 n))::l)": "GENLIST_AUX_compute", "\u2200f a b. GENLIST f (a + b) = GENLIST f b ++ GENLIST (\u03bbt. f (t + b)) a": "GENLIST_APPEND", "\u2200x l. FRONT (SNOC x l) = l": "FRONT_SNOC", "(\u2200x xs. FRONT (x::xs) = [] \u21d4 xs = []) \u2227 (\u2200x xs. [] = FRONT (x::xs) \u21d4 xs = []) \u2227 \u2200x xs. NULL (FRONT (x::xs)) \u21d4 NULL xs": "FRONT_CONS_EQ_NIL", "(\u2200x. FRONT [x] = []) \u2227 \u2200x y z. FRONT (x::y::z) = x::FRONT (y::z)": "FRONT_CONS", "(\u2200l. P l) \u21d4 P [] \u2227 \u2200h t. P (h::t)": "FORALL_LIST", "\u2200f ls a. FOLDR (\u03bbx y. f x::y) a ls = MAP f ls ++ a": "FOLDR_CONS", "\u2200l l' b b' f f'. l = l' \u2227 b = b' \u2227 (\u2200x a. MEM x l' \u21d2 f x a = f' x a) \u21d2 FOLDR f b l = FOLDR f' b' l'": "FOLDR_CONG", "\u2200ls f e. FOLDL f e (ZIP (ls,ls)) = FOLDL (\u03bbx y. f x (y,y)) e ls": "FOLDL_ZIP_SAME", "\u2200f ls s. FOLDL (\u03bbs (x,y). s \u222a f x y) s ls = s \u222a BIGUNION (IMAGE (UNCURRY f) (set ls))": "FOLDL_UNION_BIGUNION_paired", "\u2200f ls s. FOLDL (\u03bbs x. s \u222a f x) s ls = s \u222a BIGUNION (IMAGE f (set ls))": "FOLDL_UNION_BIGUNION", "\u2200f e x l. FOLDL f e (SNOC x l) = f (FOLDL f e l) x": "FOLDL_SNOC", "\u2200f l e. ASSOC f \u2227 COMM f \u21d2 FOLDL f e l = FOLDR f e l": "FOLDL_EQ_FOLDR", "\u2200l l' b b' f f'. l = l' \u2227 b = b' \u2227 (\u2200x a. MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b l = FOLDL f' b' l'": "FOLDL_CONG", "\u2200P. (\u2200f a b bs c cs. P f (f a b c) bs cs \u21d2 P f a (b::bs) (c::cs)) \u2227 (\u2200f a cs. P f a [] cs) \u2227 (\u2200f a v6 v7. P f a (v6::v7) []) \u21d2 \u2200v v1 v2 v3. P v v1 v2 v3": "FOLDL2_ind", "\u2200l1 l2. LENGTH l1 = LENGTH l2 \u21d2 \u2200f a. FOLDL2 f a l1 l2 = FOLDL (\u03bba. UNCURRY (f a)) a (ZIP (l1,l2))": "FOLDL2_FOLDL", "(\u2200f cs c bs b a. FOLDL2 f a (b::bs) (c::cs) = FOLDL2 f (f a b c) bs cs) \u2227 (\u2200f cs a. FOLDL2 f a [] cs = a) \u2227 \u2200v7 v6 f a. FOLDL2 f a (v6::v7) [] = a": "FOLDL2_def", "\u2200l1 l1' l2 l2' a a' f f'. l1 = l1' \u2227 l2 = l2' \u2227 a = a' \u2227 (\u2200z b c. MEM b l1' \u2227 MEM c l2' \u21d2 f z b c = f' z b c) \u21d2 FOLDL2 f a l1 l2 = FOLDL2 f' a' l1' l2'": "FOLDL2_cong", "\u2200ls. FLAT ls = [] \u21d4 EVERY ($= []) ls": "FLAT_EQ_NIL", "FLAT [] = [] \u2227 FLAT ([]::t) = FLAT t \u2227 FLAT ((h::t1)::t2) = h::FLAT (t1::t2)": "FLAT_compute", "\u2200l1 l2. FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2": "FLAT_APPEND", "\u2200l. FINITE (set l)": "FINITE_LIST_TO_SET", "\u2200xs. FILTER (\u03bbx. T) xs = xs": "FILTER_T", "\u2200l P. FILTER P (REVERSE l) = REVERSE (FILTER P l)": "FILTER_REVERSE", "\u2200P l. FILTER P l \u2260 [] \u21d4 \u2203x. MEM x l \u2227 P x": "FILTER_NEQ_NIL", "\u2200P l. FILTER P l \u2260 l \u21d4 \u2203x. MEM x l \u2227 \u00acP x": "FILTER_NEQ_ID", "\u2200xs. FILTER (\u03bbx. F) xs = []": "FILTER_F", "\u2200P l. FILTER P l = [] \u21d4 EVERY (\u03bbx. \u00acP x) l": "FILTER_EQ_NIL", "\u2200P l. FILTER P l = l \u21d4 EVERY P l": "FILTER_EQ_ID", "\u2200P l h lr. FILTER P l = h::lr \u21d4 \u2203l1 l2. l = l1 ++ [h] ++ l2 \u2227 FILTER P l1 = [] \u2227 FILTER P l2 = lr \u2227 P h": "FILTER_EQ_CONS", "\u2200P l l1 l2. FILTER P l = l1 ++ l2 \u21d4 \u2203l3 l4. l = l3 ++ l4 \u2227 FILTER P l3 = l1 \u2227 FILTER P l4 = l2": "FILTER_EQ_APPEND", "FILTER P [] = [] \u2227 (\u2200h. P h \u21d2 FILTER P (h::l) = h::FILTER P l) \u2227 \u2200h. \u00acP h \u21d2 FILTER P (h::l) = FILTER P l": "FILTER_COND_REWRITE", "\u2200P L M. FILTER P (L ++ M) = FILTER P L ++ FILTER P M": "FILTER_APPEND_DISTRIB", "\u2200P l. ALL_DISTINCT l \u21d2 ALL_DISTINCT (FILTER P l)": "FILTER_ALL_DISTINCT", "\u2200P x l. EXISTS P (SNOC x l) \u21d4 P x \u2228 EXISTS P l": "EXISTS_SNOC", "\u2200c l. EXISTS (\u03bbx. c) l \u21d4 l \u2260 [] \u2227 c": "EXISTS_SIMP", "\u2200P l. EXISTS P l \u21d4 \u00acEVERY (\u03bbx. \u00acP x) l": "EXISTS_NOT_EVERY", "\u2200P l. EXISTS P l \u21d4 \u2203e. MEM e l \u2227 P e": "EXISTS_MEM", "\u2200P f l. EXISTS P (MAP f l) \u21d4 EXISTS (\u03bbx. P (f x)) l": "EXISTS_MAP", "(\u2203ls. P ls) \u21d4 \u2203n f. P (GENLIST f n)": "exists_list_GENLIST", "\u2200ls f. EVERY (\u03bbx. \u2203y. x = f y) ls \u21d2 \u2203l. ls = MAP f l": "EXISTS_LIST_EQ_MAP", "(\u2203l. P l) \u21d4 P [] \u2228 \u2203h t. P (h::t)": "EXISTS_LIST", "\u2200n. EXISTS P (GENLIST f n) \u21d4 \u2203i. i < n \u2227 P (f i)": "EXISTS_GENLIST", "\u2200l1 l2 P P'. l1 = l2 \u2227 (\u2200x. MEM x l2 \u21d2 (P x \u21d4 P' x)) \u21d2 (EXISTS P l1 \u21d4 EXISTS P' l2)": "EXISTS_CONG", "\u2200P l1 l2. EXISTS P (l1 ++ l2) \u21d4 EXISTS P l1 \u2228 EXISTS P l2": "EXISTS_APPEND", "\u2200l1 l2 P. LENGTH l1 = LENGTH l2 \u21d2 (EVERY (\u03bbx. P (SND x)) (ZIP (l1,l2)) \u21d4 EVERY P l2)": "every_zip_snd", "\u2200l1 l2 P. LENGTH l1 = LENGTH l2 \u21d2 (EVERY (\u03bbx. P (FST x)) (ZIP (l1,l2)) \u21d4 EVERY P l1)": "every_zip_fst", "\u2200P x l. EVERY P (SNOC x l) \u21d4 EVERY P l \u2227 P x": "EVERY_SNOC", "\u2200c l. EVERY (\u03bbx. c) l \u21d4 l = [] \u2228 c": "EVERY_SIMP", "\u2200P l. EVERY P l \u21d4 \u00acEXISTS (\u03bbx. \u00acP x) l": "EVERY_NOT_EXISTS", "\u2200P Q. (\u2200x. P x \u21d2 Q x) \u21d2 \u2200l. EVERY P l \u21d2 EVERY Q l": "EVERY_MONOTONIC", "\u2200P Q l. (\u2200x. MEM x l \u2227 P x \u21d2 Q x) \u2227 EVERY P l \u21d2 EVERY Q l": "EVERY_MEM_MONO", "\u2200P l. EVERY P l \u21d4 \u2200e. MEM e l \u21d2 P e": "EVERY_MEM", "\u2200P f l. EVERY P (MAP f l) \u21d4 EVERY (\u03bbx. P (f x)) l": "EVERY_MAP", "\u2200n. EVERY P (GENLIST f n) \u21d4 \u2200i. i < n \u21d2 P (f i)": "EVERY_GENLIST", "EVERY P (FLAT ls) \u21d4 EVERY (EVERY P) ls": "EVERY_FLAT", "\u2200P1 P2 l. EVERY P1 l \u21d2 EVERY P1 (FILTER P2 l)": "EVERY_FILTER_IMP", "\u2200P1 P2 l. EVERY P1 (FILTER P2 l) \u21d4 EVERY (\u03bbx. P2 x \u21d2 P1 x) l": "EVERY_FILTER", "\u2200l P. EVERY P l \u21d4 \u2200n. n < LENGTH l \u21d2 P (EL n l)": "EVERY_EL", "\u2200P Q l. EVERY (\u03bbx. P x \u2227 Q x) l \u21d4 EVERY P l \u2227 EVERY Q l": "EVERY_CONJ", "\u2200l1 l2 P P'. l1 = l2 \u2227 (\u2200x. MEM x l2 \u21d2 (P x \u21d4 P' x)) \u21d2 (EVERY P l1 \u21d4 EVERY P' l2)": "EVERY_CONG", "\u2200P l1 l2. EVERY P (l1 ++ l2) \u21d4 EVERY P l1 \u2227 EVERY P l2": "EVERY_APPEND", "(\u2200x y z. R x y \u2227 R y z \u21d2 R x z) \u21d2 \u2200x y z. LIST_REL R x y \u2227 LIST_REL R y z \u21d2 LIST_REL R x z": "EVERY2_trans", "(\u2200P ys. LIST_REL P [] ys \u21d4 ys = []) \u2227 (\u2200P yys x xs. LIST_REL P (x::xs) yys \u21d4 \u2203y ys. yys = y::ys \u2227 P x y \u2227 LIST_REL P xs ys) \u2227 (\u2200P xs. LIST_REL P xs [] \u21d4 xs = []) \u2227 \u2200P xxs y ys. LIST_REL P xxs (y::ys) \u21d4 \u2203x xs. xxs = x::xs \u2227 P x y \u2227 LIST_REL P xs ys": "EVERY2_THM", "(\u2200x y. R1 x y \u21d2 R2 y x) \u21d2 \u2200x y. LIST_REL R1 x y \u21d2 LIST_REL R2 y x": "EVERY2_sym", "\u2200R l1 l2. LIST_REL R l1 l2 \u21d2 LIST_REL R (REVERSE l1) (REVERSE l2)": "EVERY2_REVERSE", "(\u2200x. MEM x ls \u21d2 R x x) \u21d2 LIST_REL R ls ls": "EVERY2_refl", "\u2200P Q l1 l2. (\u2200x. MEM x (ZIP (l1,l2)) \u2227 UNCURRY P x \u21d2 UNCURRY Q x) \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL Q l1 l2": "EVERY2_MEM_MONO", "(LIST_REL P (MAP f l1) l2 \u21d4 LIST_REL (\u03bbx y. P (f x) y) l1 l2) \u2227 (LIST_REL Q l1 (MAP g l2) \u21d4 LIST_REL (\u03bbx y. Q x (g y)) l1 l2)": "EVERY2_MAP", "\u2200P l1 l2 v1 v2 n. P v1 v2 \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2)": "EVERY2_LUPDATE_same", "\u2200P l1 l2. LIST_REL P l1 l2 \u21d2 LENGTH l1 = LENGTH l2": "EVERY2_LENGTH", "\u2200l1 l2 f. LIST_REL f l1 l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 EVERY (UNCURRY f) (ZIP (l1,l2))": "EVERY2_EVERY", "\u2200l1 l1' l2 l2' P P'. l1 = l1' \u2227 l2 = l2' \u2227 (\u2200x y. MEM x l1' \u2227 MEM y l2' \u21d2 (P x y \u21d4 P' x y)) \u21d2 (LIST_REL P l1 l2 \u21d4 LIST_REL P' l1' l2')": "EVERY2_cong", "\u2200h1 h2. h1 = h2 \u21d2 \u2200l1 l2. l1 = l2 \u21d2 h1::l1 = h2::l2": "EQ_LIST", "\u2200l1 l2 n. LENGTH l1 = LENGTH l2 \u2227 n < LENGTH l1 \u21d2 EL n (ZIP (l1,l2)) = (EL n l1,EL n l2)": "EL_ZIP", "\u2200n x l. x < n \u21d2 EL x (TAKE n l) = EL x l": "EL_TAKE", "\u2200n l. n < LENGTH l \u21d2 \u2200x. EL n (SNOC x l) = EL n l": "EL_SNOC", "EL (NUMERAL (BIT1 n)) (l::ls) = EL (PRE (NUMERAL (BIT1 n))) ls \u2227 EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls": "EL_simp_restricted", "EL (NUMERAL (BIT1 n)) l = EL (PRE (NUMERAL (BIT1 n))) (TL l) \u2227 EL (NUMERAL (BIT2 n)) l = EL (NUMERAL (BIT1 n)) (TL l)": "EL_simp", "\u2200n l. n < LENGTH l \u21d2 EL n (REVERSE l) = EL (PRE (LENGTH l \u2212 n)) l": "EL_REVERSE", "EL 0 = HD \u2227 EL (SUC n) (l::ls) = EL n ls": "EL_restricted", "\u2200ts tt n. n < MIN (LENGTH ts) (LENGTH tt) \u21d2 EL n (MAP2 f ts tt) = f (EL n ts) (EL n tt)": "EL_MAP2", "\u2200n l. n < LENGTH l \u21d2 \u2200f. EL n (MAP f l) = f (EL n l)": "EL_MAP", "\u2200ys x i k. EL i (LUPDATE x k ys) = if i = k \u2227 k < LENGTH ys then x else EL i ys": "EL_LUPDATE", "\u2200l x. EL (LENGTH l) (SNOC x l) = x": "EL_LENGTH_SNOC", "\u2200P ls k. LENGTH (dropWhile P (REVERSE ls)) \u2264 k \u2227 k < LENGTH ls \u21d2 P (EL k ls)": "EL_LENGTH_dropWhile_REVERSE", "\u2200f n x. x < n \u21d2 EL x (GENLIST f n) = f x": "EL_GENLIST", "\u2200m n l. m + n < LENGTH l \u21d2 EL m (DROP n l) = EL (m + n) l": "EL_DROP", "\u2200n. EL n l = if n = 0 then HD l else EL (PRE n) (TL l)": "EL_compute", "\u2200l1 l2 n. EL n (l1 ++ l2) = if n < LENGTH l1 then EL n l1 else EL (n \u2212 LENGTH l1) l2": "EL_APPEND_EQN", "\u2200l1 x l2. EL (LENGTH l1) (l1 ++ [x] ++ l2) = x": "el_append3", "\u2200l. ALL_DISTINCT l \u21d4 \u2200n1 n2. n1 < LENGTH l \u2227 n2 < LENGTH l \u21d2 (EL n1 l = EL n2 l \u21d4 n1 = n2)": "EL_ALL_DISTINCT_EL_EQ", "\u2200P. dropWhile P = splitAtPki (combin$C (K \u2218 $~ \u2218 P)) (K I)": "dropWhile_splitAtPki", "\u2200P ls. dropWhile P ls = [] \u21d4 EVERY P ls": "dropWhile_eq_nil", "\u2200P l1 l2. EXISTS ($~ \u2218 P) l1 \u21d2 dropWhile P (l1 ++ l2) = dropWhile P l1 ++ l2": "dropWhile_APPEND_EXISTS", "\u2200P l1 l2. EVERY P l1 \u21d2 dropWhile P (l1 ++ l2) = dropWhile P l2": "dropWhile_APPEND_EVERY", "DROP n l = splitAtPki (K \u2218 $= n) (K I) l": "DROP_splitAtPki", "\u2200n. DROP n [] = []": "DROP_nil", "\u2200ls n. DROP n ls = [] \u21d4 n \u2265 LENGTH ls": "DROP_NIL", "\u2200l n. LENGTH l \u2264 n \u21d2 DROP n l = []": "DROP_LENGTH_TOO_LONG", "DROP n (GENLIST f m) = GENLIST (f \u2218 $+ n) (m \u2212 n)": "DROP_GENLIST", "0 < n \u21d2 DROP n (x::xs) = DROP (n \u2212 1) xs": "DROP_cons", "(\u2200l. DROP 0 l = l) \u2227 (\u2200n. DROP (NUMERAL (BIT1 n)) [] = []) \u2227 (\u2200n. DROP (NUMERAL (BIT2 n)) [] = []) \u2227 (\u2200n h t. DROP (NUMERAL (BIT1 n)) (h::t) = DROP (NUMERAL (BIT1 n) \u2212 1) t) \u2227 \u2200n h t. DROP (NUMERAL (BIT2 n)) (h::t) = DROP (NUMERAL (BIT1 n)) t": "DROP_compute", "DROP 0 l = l": "DROP_0", "DISJOINT x (set (GENLIST ($+ n) (a + b))) \u21d2 DISJOINT x (set (GENLIST ($+ n) a)) \u2227 DISJOINT x (set (GENLIST ($+ (n + a)) b))": "DISJOINT_GENLIST_PLUS", "DATATYPE (list [] CONS)": "datatype_list", "\u2200l x. l \u2260 x::l \u2227 x::l \u2260 l": "CONS_ACYCLIC", "\u2200l. \u00acNULL l \u21d2 HD l::TL l = l": "CONS", "\u2200ls. CARD (set ls) = LENGTH ls \u21d2 ALL_DISTINCT ls": "CARD_LIST_TO_SET_ALL_DISTINCT", "CARD (set ls) \u2264 LENGTH ls": "CARD_LIST_TO_SET", "BIGUNION (IMAGE f (set ls)) \u2286 s \u21d4 \u2200x. MEM x ls \u21d2 f x \u2286 s": "BIGUNION_IMAGE_set_SUBSET", "\u2200l1 x l2. l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)": "APPEND_SNOC", "\u2200l. l ++ [] = l": "APPEND_NIL", "\u2200l1 l1'. LENGTH l1 = LENGTH l1' \u21d2 \u2200l2 l2'. LENGTH l2 = LENGTH l2' \u21d2 (l1 ++ l2 = l1' ++ l2' \u21d4 l1 = l1' \u2227 l2 = l2')": "APPEND_LENGTH_EQ", "\u2200l. l \u2260 [] \u21d2 FRONT l ++ [LAST l] = l": "APPEND_FRONT_LAST", "l1 ++ l2 = [e] \u21d4 l1 = [e] \u2227 l2 = [] \u2228 l1 = [] \u2227 l2 = [e]": "APPEND_EQ_SING", "(\u2200l1 l2. l1 ++ l2 = l1 \u21d4 l2 = []) \u2227 (\u2200l1 l2. l1 ++ l2 = l2 \u21d4 l1 = []) \u2227 (\u2200l1 l2. l1 = l1 ++ l2 \u21d4 l2 = []) \u2227 \u2200l1 l2. l2 = l1 ++ l2 \u21d4 l1 = []": "APPEND_EQ_SELF", "(\u2200l1 l2. [] = l1 ++ l2 \u21d4 l1 = [] \u2227 l2 = []) \u2227 \u2200l1 l2. l1 ++ l2 = [] \u21d4 l1 = [] \u2227 l2 = []": "APPEND_eq_NIL", "l1 ++ l2 = h::t \u21d4 l1 = [] \u2227 l2 = h::t \u2228 \u2203lt. l1 = h::lt \u2227 t = lt ++ l2": "APPEND_EQ_CONS", "l1 ++ [e] ++ l2 = m1 ++ m2 \u21d4 (\u2203l. m1 = l1 ++ [e] ++ l \u2227 l2 = l ++ m2) \u2228 \u2203l. l1 = m1 ++ l \u2227 m2 = l ++ [e] ++ l2": "APPEND_EQ_APPEND_MID", "l1 ++ l2 = m1 ++ m2 \u21d4 (\u2203l. l1 = m1 ++ l \u2227 m2 = l ++ l2) \u2228 \u2203l. m1 = l1 ++ l \u2227 l2 = l ++ m2": "APPEND_EQ_APPEND", "\u2200l1 l2 l3. l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3": "APPEND_ASSOC", "(\u2200l1 l2 l1' l2'. LENGTH l1 = LENGTH l1' \u21d2 (l1 ++ l2 = l1' ++ l2' \u21d4 l1 = l1' \u2227 l2 = l2')) \u2227 \u2200l1 l2 l1' l2'. LENGTH l2 = LENGTH l2' \u21d2 (l1 ++ l2 = l1' ++ l2' \u21d4 l1 = l1' \u2227 l2 = l2')": "APPEND_11_LENGTH", "(\u2200l1 l2 l3. l1 ++ l2 = l1 ++ l3 \u21d4 l2 = l3) \u2227 \u2200l1 l2 l3. l2 ++ l1 = l3 ++ l1 \u21d4 l2 = l3": "APPEND_11", "\u2200l1 l2. ALL_DISTINCT (ZIP (l1,l2)) \u2227 LENGTH l1 = LENGTH l2 \u21d2 ALL_DISTINCT (ZIP (l2,l1))": "ALL_DISTINCT_ZIP_SWAP", "\u2200l1 l2. ALL_DISTINCT l1 \u2227 LENGTH l1 = LENGTH l2 \u21d2 ALL_DISTINCT (ZIP (l1,l2))": "ALL_DISTINCT_ZIP", "\u2200x l. ALL_DISTINCT (SNOC x l) \u21d4 \u00acMEM x l \u2227 ALL_DISTINCT l": "ALL_DISTINCT_SNOC", "\u2200x. ALL_DISTINCT [x]": "ALL_DISTINCT_SING", "\u2200s. FINITE s \u21d2 ALL_DISTINCT (SET_TO_LIST s)": "ALL_DISTINCT_SET_TO_LIST", "\u2200l. ALL_DISTINCT (REVERSE l) \u21d4 ALL_DISTINCT l": "ALL_DISTINCT_REVERSE", "\u2200l. ALL_DISTINCT (nub l)": "all_distinct_nub", "\u2200ls f. (\u2200x y. MEM x ls \u2227 MEM y ls \u2227 f x = f y \u21d2 x = y) \u2227 ALL_DISTINCT ls \u21d2 ALL_DISTINCT (MAP f ls)": "ALL_DISTINCT_MAP_INJ", "\u2200f ls. ALL_DISTINCT (MAP f ls) \u21d2 ALL_DISTINCT ls": "ALL_DISTINCT_MAP", "ALL_DISTINCT (GENLIST f n) \u21d4 \u2200m1 m2. m1 < n \u2227 m2 < n \u2227 f m1 = f m2 \u21d2 m1 = m2": "ALL_DISTINCT_GENLIST", "\u2200xs. ALL_DISTINCT (FLAT (REVERSE xs)) \u21d4 ALL_DISTINCT (FLAT xs)": "ALL_DISTINCT_FLAT_REVERSE", "\u2200P l n1 n2. ALL_DISTINCT (FILTER P l) \u2227 n1 < LENGTH l \u2227 n2 < LENGTH l \u2227 P (EL n1 l) \u2227 EL n1 l = EL n2 l \u21d2 n1 = n2": "ALL_DISTINCT_FILTER_EL_IMP", "\u2200l. ALL_DISTINCT l \u21d4 \u2200x. MEM x l \u21d2 FILTER ($= x) l = [x]": "ALL_DISTINCT_FILTER", "\u2200l n1 n2. ALL_DISTINCT l \u2227 n1 < LENGTH l \u2227 n2 < LENGTH l \u21d2 (EL n1 l = EL n2 l \u21d4 n1 = n2)": "ALL_DISTINCT_EL_IMP", "\u2200ls n. ALL_DISTINCT ls \u21d2 ALL_DISTINCT (DROP n ls)": "ALL_DISTINCT_DROP", "\u2200ls. ALL_DISTINCT ls \u21d2 CARD (set ls) = LENGTH ls": "ALL_DISTINCT_CARD_LIST_TO_SET", "\u2200l1 l2. ALL_DISTINCT (l1 ++ l2) \u21d4 ALL_DISTINCT l1 \u2227 ALL_DISTINCT l2 \u2227 \u2200e. MEM e l1 \u21d2 \u00acMEM e l2": "ALL_DISTINCT_APPEND"}