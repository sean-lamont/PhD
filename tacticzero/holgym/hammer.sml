load "holyHammer"; 
open holyHammer;

(* hh_pb [Vampire] ["arithmeticTheory.ADD_CLAUSES"] ([],``a <= b ==> (g ** (b - a) * g ** a = g ** b)``); *)

(* val l = [``(âˆ€(x :Î±). (P :Î± -> bool) x â‡’ (Q :Î± option -> bool) (SOME x)) âˆ§ ((âˆ€(x :Î±). Â¬P x) â‡’ Q (NONE :Î± option)) â‡’ Q ($some P)``, ``âˆ€(c :bool) (x :bool). (if c then T else x) â‡” Â¬c â‡’ x``, ``âˆ€(R :Î± -> Î± -> bool). irreflexive Ráµ€ â‡” irreflexive R``, ``âˆ€(v :Î±) (rs :(Î± -> Î² option) list). (EVERY (Î»(r :Î± -> Î² option). r v = (NONE :Î² option)) rs â‡’ F) â‡’ PMATCH_IS_EXHAUSTIVE v rs``, ``âˆ€(b :bool). Â¬b â‡’ (b â‡” F)``, ``âˆ€(x :Î± option). IS_NONE x â‡” x = (NONE :Î± option)``, ``âˆ€(v :Î±) (rows :(Î± -> Î² option) list) (i :num). i < LENGTH rows â‡’ (EL i (STRONGEST_REDUNDANT_ROWS_INFO v rows) â‡” EVERY (Î»(r :Î± -> Î² option). r v = (NONE :Î² option)) (TAKE i rows) â‡’ EL i rows v = (NONE :Î² option))``, ``INVOL (relinv :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``âˆ€(m :num) (n :num). m < n â‡’ SUC m < SUC n``, ``(R :Î± -> Î± -> bool)ê™³ (x :Î±) x``, ``âˆ€(t :bool). T â‡’ t â‡” t``, ``(n :num) â‰¤ tri n``, ``âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool)ê™³ x y â‡’ R^= x y``, ``âˆ€(R :Î± -> Î² -> bool). Ráµ€ áµ€ = R``, ``âˆ€(f1 :num -> Î± -> bool) (f1 :num -> Î± -> bool) (f2 :num -> Î± -> bool) (f2 :num -> Î± -> bool). ind_type$INJP f1 f2 = ind_type$INJP f1 f2 â‡” f1 = f1 âˆ§ f2 = f2``, ``IS_SOME (OPTION_MAP (f :Î± -> Î²) (x :Î± option)) â‡” IS_SOME x``, ``âˆ€(R :Î± -> Î± -> bool). symmetric (SC R)``, ``(âˆ…áµ£ :Î± -> Î± -> bool) âŠ†áµ£ (R :Î± -> Î± -> bool) âˆ§ (R âŠ†áµ£ (âˆ…áµ£ :Î± -> Î± -> bool) â‡” R = (âˆ…áµ£ :Î± -> Î± -> bool))``, ``âˆ€(t :bool). t âˆ§ T â‡” t``, ``âˆ€(R :Î± -> Î± -> bool) (P :Î± -> Î± -> bool). (âˆ€(x :Î±). P x x) âˆ§ (âˆ€(x :Î±) (y :Î±) (z :Î±). P x y âˆ§ R y z â‡’ P x z) â‡’ âˆ€(x :Î±) (y :Î±). Rê™³ x y â‡’ P x y``, ``âˆ€(p :Î± # Î²) (f :Î± -> Î³) (g :Î² -> Î´). SND ((f ## g) p) = g (SND p)``, ``(âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool) x y â‡’ R ((f :Î± -> Î±) x) (f y)) â‡’ âˆ€(x :Î±) (y :Î±). SC R x y â‡’ SC R (f x) (f y)``, ``(âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool) x y â‡’ R ((f :Î± -> Î±) x) (f y)) â‡’ âˆ€(x :Î±) (y :Î±). Rê™³ x y â‡’ Rê™³ (f x) (f y)``, ``Â¬((p :bool) â‡’ (q :bool)) â‡’ p``, ``(âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool) x y â‡’ (Q :Î± -> Î± -> bool) x y) â‡’ RC R (x :Î±) (y :Î±) â‡’ RC Q x y``, ``transitive (R :Î± -> Î± -> bool) â‡” R âˆ˜áµ£ R âŠ†áµ£ R``, ``âˆ€(R :Î± -> Î± -> bool). transitive Ráµ€ â‡” transitive R``, ``âˆ€(P :Î± -> bool) (v :Î²) (rows :(Î² -> Î± option) list). P (PMATCH v rows) â‡” PMATCH_EXPAND_PRED P v ([] :(Î² -> Î± option) list) rows``] *)

(* val l1 = [``âˆ€(m :num) (n :num). m â‰¤ n âŠ— m``, ``âˆ€(R :Î± -> Î± -> bool). (âˆ€(P :Î± -> bool). (âˆ€(x :Î±). (âˆ€(y :Î±). R y x â‡’ P y) â‡’ P x) â‡’ âˆ€(x :Î±). P x) â‡’ WF R``, ``symmetric (R1 :Î± -> Î± -> bool) âˆ§ symmetric (R2 :Î² -> Î² -> bool) â‡’ symmetric (R1 LEX R2)``, ``IDEM (RTC :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``PMATCH_ROW_COND_NOT_EX_OR_EQ (i :Î±) (r :Î± -> Î² option) ([] :(Î± -> Î² option) list) â‡” r i â‰  (NONE :Î² option) â‡’ F``, ``PMATCH_ROW_COND (pat :Î± -> Î²) (guard :Î± -> bool) (inp :Î²) (v :Î±) â‡” inp = pat v âˆ§ guard v``, ``Â¬T â‡” F``, ``OPTION_MAP (f :Î± -> Î²) (x :Î± option) = (option_CASE x (NONE :Î² option) ((SOME :Î² -> Î² option) âˆ˜ f) :Î² option)``, ``(some(x :Î±). F) = (NONE :Î± option)``, ``(y :Î±) âˆˆ RRANGE (R :Î² -> Î± -> bool) â‡” âˆƒ(x :Î²). R x y``, ``âˆ€(P :Î± + Î² -> bool). (âˆƒ(s :Î± + Î²). P s) â‡” (âˆƒ(x :Î±). P (INL x :Î± + Î²)) âˆ¨ âˆƒ(y :Î²). P (INR y :Î± + Î²)``, ``PMATCH (v :Î²) (rows :(Î² -> Î± option) list) = PMATCH v (SNOC (PMATCH_ROW (Î»(_0 :Î²). _0) (Î»(_0 :Î²). T) (Î»(_0 :Î²). (ARB :Î±))) rows)``, ``trichotomous (STRORD (R :Î± -> Î± -> bool)) â‡” trichotomous R``, ``(R :Î± -> Î² -> bool) âˆ˜áµ£ ($= :Î± -> Î± -> bool) = R``, ``âˆ€(R :Î± -> Î± -> bool). equivalence R â‡’ Ráµ€ = R``, ``(OPTION_BIND (p :Î± option) (f :Î± -> Î² option) = (NONE :Î² option) â‡” p = (NONE :Î± option) âˆ¨ âˆƒ(x :Î±). p = SOME x âˆ§ f x = (NONE :Î² option)) âˆ§ (OPTION_BIND p f = SOME (y :Î²) â‡” âˆƒ(x :Î±). p = SOME x âˆ§ f x = SOME y)``, ``DATATYPE ((pair :(Î± -> Î² -> Î± # Î²) -> Î³) ($, :Î± -> Î² -> Î± # Î²))``, ``âˆ€(n :num). Â¬(n < (0 :num))``, ``(option_CASE (x :Î± option) (e :Î²) (f :Î± -> Î²) :Î²) = if IS_SOME x then f (THE x) else e``, ``âˆ€(v :Î±) (p :Î² -> Î±) (g :Î² -> bool) (p :Î³ -> Î±) (g :Î³ -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g â‡’ (âˆ€(x :Î²). g x â‡’ ((âˆƒ(x :Î³). p x = p x âˆ§ g x) â‡” RES)) â‡’ (PMATCH_ROW_COND_EX v p g â‡” RES)``, ``Â¬((A :bool) âˆ¨ (B :bool)) â‡’ F â‡” Â¬A â‡’ Â¬B â‡’ F``, ``((if (P :bool) then SOME (x :Î±) else (NONE :Î± option)) = (NONE :Î± option) â‡” Â¬P) âˆ§ ((if P then (NONE :Î± option) else SOME x) = (NONE :Î± option) â‡” P) âˆ§ ((if P then SOME x else (NONE :Î± option)) = SOME (y :Î±) â‡” P âˆ§ x = y) âˆ§ ((if P then (NONE :Î± option) else SOME x) = SOME y â‡” Â¬P âˆ§ x = y)``, ``âˆ€(m :num) (n :num). SUC m = SUC n â‡” m = n``, ``âˆ€(n :num). SUC (m :num) = n â‡’ m < n``, ``Order (R :Î± -> Î± -> bool) â‡” WeakOrder (RC R)``, ``âˆ€(t :bool). F â‡’ t â‡” T``, ``PMATCH_ROW_REDUNDANT (v :Î±) ((r :Î± -> Î² option)::(rs :(Î± -> Î² option) list)) (0 :num) â‡” r v = (NONE :Î² option)``, ``PMATCH_ROW (p :Î² -> Î³) (g :Î² -> bool) (r :Î² -> Î±) (i :Î³) â‰  (NONE :Î± option) â‡” PMATCH_ROW_COND_EX i p g``, ``WF (R :Î± -> Î± -> bool) â‡’ irreflexive R``, ``(antisymmetric (R1 :Î± -> Î± -> bool) â‡’ antisymmetric (R1 âˆ©áµ£ (R2 :Î± -> Î± -> bool))) âˆ§ (antisymmetric R2 â‡’ antisymmetric (R1 âˆ©áµ£ R2))``, ``âˆ€(M :Î± + Î²) (M :Î± + Î²) (f :Î± -> Î³) (f1 :Î² -> Î³). M = M âˆ§ (âˆ€(x :Î±). M = (INL x :Î± + Î²) â‡’ f x = (f :Î± -> Î³) x) âˆ§ (âˆ€(y :Î²). M = (INR y :Î± + Î²) â‡’ f1 y = (f1 :Î² -> Î³) y) â‡’ (sum_CASE M f f1 :Î³) = (sum_CASE M f f1 :Î³)``, ``âˆ€(R :Î± -> Î± -> bool) (x :Î±) (y :Î±). Rê™³ x y â‡” x = y âˆ¨ Râº x y``, ``âˆ€(R :Î± -> Î± -> bool). (âˆ€(x :Î±). Rê™³ x x) âˆ§ âˆ€(x :Î±) (y :Î±) (z :Î±). R x y âˆ§ Rê™³ y z â‡’ Rê™³ x z``, ``âˆ€(P :Î± -> Î² -> bool). (âˆƒ(x :Î±) (y :Î²). P x y) â‡” âˆƒ((x :Î±),(y :Î²)). P x y``, ``OWHILE (G :Î± -> bool) (f :Î± -> Î±) (s :Î±) = (NONE :Î± option) â‡” âˆ€(n :num). G (FUNPOW f n s)``] *)

(* val l2 = [``âˆ€(t :bool). t â‡’ T â‡” T``, ``(x :Î±) âˆˆ RDOM ((R1 :Î± -> Î² -> bool) âˆªáµ£ (R2 :Î± -> Î² -> bool)) â‡” x âˆˆ RDOM R1 âˆ¨ x âˆˆ RDOM R2``, ``âˆ€(a1 :Î±) (a2 :Î±). ind_type$INJA a1 = ind_type$INJA a2 â‡” a1 = a2``, ``âˆ€(Q :num -> bool) (P :num -> bool). (âˆƒ(n :num). P n) âˆ§ (âˆ€(n :num). (âˆ€(m :num). m < n â‡’ Â¬P m) âˆ§ P n â‡’ Q n) â‡’ Q ($LEAST P)``, ``âˆ€(ss :Î± + Î²). (âˆƒ(x :Î±). ss = (INL x :Î± + Î²)) âˆ¨ âˆƒ(y :Î²). ss = (INR y :Î± + Î²)``, ``âˆ€(f :Î± # Î² -> Î³). UNCURRY (CURRY f) = f``, ``âˆ€(x :Î± + Î²). ISL x âˆ¨ ISR x``, ``âˆ€(R :Î± -> Î± -> bool) (RTC :Î± -> Î± -> bool). (âˆ€(x :Î±). RTC x x) âˆ§ (âˆ€(x :Î±) (y :Î±) (z :Î±). R x y âˆ§ RTC y z â‡’ RTC x z) â‡’ âˆ€(a0 :Î±) (a1 :Î±). Rê™³ a0 a1 â‡’ RTC a0 a1``, ``âˆ€(R :Î± -> Î± -> bool). StrongOrder R â‡’ Order R``, ``âˆ€(R :Î± -> Î± -> bool). transitive Rê™³``, ``IDEM (STRORD :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``âˆ€(p :Î± -> Î²) (g :Î± -> bool) (r :Î± -> Î³) (v :Î²) (rows :(Î² -> Î³ option) list). (âˆ€(x :Î±). r x = (ARB :Î³)) â‡’ PMATCH v (SNOC (PMATCH_ROW p g r) rows) = PMATCH v rows``, ``(âˆ€(x :Î±) (y :Î²). (P :Î± -> Î² -> bool) x y â‡’ (Q :Î± -> Î² -> bool) x y) â‡’ OPTREL P (x :Î± option) (y :Î² option) â‡’ OPTREL Q x y``, ``total (R1 :Î± -> Î± -> bool) âˆ§ total (R2 :Î² -> Î² -> bool) â‡’ total (R1 LEX R2)``, ``âˆ€(R :Î± -> Î± -> bool). symmetric R â‡’ SC R = R``, ``OPTION_MAP2 (f :Î± -> Î² -> Î³) (o1 :Î± option) (o2 :Î² option) = SOME (v :Î³) â‡” âˆƒ(x1 :Î±) (x2 :Î²). o1 = SOME x1 âˆ§ o2 = SOME x2 âˆ§ v = f x1 x2``, ``âˆ€(x :Î± option option) (y :Î±). OPTION_JOIN x = SOME y â‡” x = SOME (SOME y)``, ``âˆ€(R :Î± -> Î± -> bool). equivalence R â‡” âˆ€(x :Î±) (y :Î±). R x y â‡” R x = R y``, ``âˆ€(f :Î± -> Î²) (R :Î± -> Î± -> bool) (D :Î± -> bool) (P :Î± -> Î² -> bool) (M :(Î± -> Î²) -> Î± -> Î²) (x :Î±). f = WFREC R M âˆ§ WF R âˆ§ INDUCTIVE_INVARIANT_ON R D P M âˆ§ D x â‡’ P x (f x)``, ``IDEM (RC :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``âˆ€(x :Î±) (y :Î²). FST (x,y) = x``, ``(âˆ€(x :Î±) (y :Î±). (P :Î± -> bool) x âˆ§ (R :Î± -> Î± -> bool) x y â‡’ P y) â‡’ âˆ€(x :Î±) (y :Î±). P x âˆ§ Rê™³ x y â‡’ P y``, ``âˆ€(opt1 :Î± option) (opt2 :Î± option) (f1 :Î± -> Î²) (f2 :Î± -> Î²). opt1 = opt2 âˆ§ (âˆ€(x :Î±). opt2 = SOME x â‡’ f1 x = f2 x) â‡’ OPTION_MAP f1 opt1 = OPTION_MAP f2 opt2``, ``âˆ€(f :Î± -> Î²) (g :Î³ -> Î´) (x :Î±) (y :Î³). (f ## g) (x,y) = (f x,g y)``, ``âˆ€(t :bool). t âˆ¨ t â‡” t``, ``(âˆ€(x :Î±) (y :Î±). (R1 :Î± -> Î± -> bool) x y â‡’ (R2 :Î± -> Î± -> bool) x y) âˆ§ (âˆ€(x :Î²) (y :Î²). (R3 :Î² -> Î² -> bool) x y â‡’ (R4 :Î² -> Î² -> bool) x y) â‡’ (R1 LEX R3) (x :Î± # Î²) (y :Î± # Î²) â‡’ (R2 LEX R4) x y``, ``PMATCH_ROW_COND_EX (i :Î±) (p :Î² -> Î±) (g :Î² -> bool) â‡’ PMATCH_ROW p g (r :Î² -> Î³) i = SOME (r (@(x :Î²). PMATCH_ROW_COND p g i x))``, ``(R :Î± -> Î± -> bool)âº (x :Î±) (z :Î±) â‡” R x z âˆ¨ âˆƒ(y :Î±). Râº x y âˆ§ R y z``, ``âˆ€(R :Î± -> Î± -> bool). Order R â‡” StrongOrder (STRORD R)``] *)

val l = [``(âˆ€(x :Î±). (P :Î± -> bool) x â‡’ (Q :Î± option -> bool) (SOME x)) âˆ§ ((âˆ€(x :Î±). Â¬P x) â‡’ Q (NONE :Î± option)) â‡’ Q ($some P)``, ``âˆ€(c :bool) (x :bool). (if c then T else x) â‡” Â¬c â‡’ x``, ``âˆ€(R :Î± -> Î± -> bool). irreflexive Ráµ€ â‡” irreflexive R``, ``âˆ€(v :Î±) (rs :(Î± -> Î² option) list). (EVERY (Î»(r :Î± -> Î² option). r v = (NONE :Î² option)) rs â‡’ F) â‡’ PMATCH_IS_EXHAUSTIVE v rs``, ``âˆ€(b :bool). Â¬b â‡’ (b â‡” F)``, ``âˆ€(x :Î± option). IS_NONE x â‡” x = (NONE :Î± option)``, ``âˆ€(v :Î±) (rows :(Î± -> Î² option) list) (i :num). i < LENGTH rows â‡’ (EL i (STRONGEST_REDUNDANT_ROWS_INFO v rows) â‡” EVERY (Î»(r :Î± -> Î² option). r v = (NONE :Î² option)) (TAKE i rows) â‡’ EL i rows v = (NONE :Î² option))``, ``INVOL (relinv :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``âˆ€(m :num) (n :num). m < n â‡’ SUC m < SUC n``, ``(R :Î± -> Î± -> bool)ê™³ (x :Î±) x``, ``âˆ€(t :bool). T â‡’ t â‡” t``, ``(n :num) â‰¤ tri n``, ``âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool)ê™³ x y â‡’ R^= x y``, ``âˆ€(R :Î± -> Î² -> bool). Ráµ€ áµ€ = R``, ``âˆ€(f1 :num -> Î± -> bool) (f1' :num -> Î± -> bool) (f2 :num -> Î± -> bool) (f2' :num -> Î± -> bool). ind_type$INJP f1 f2 = ind_type$INJP f1' f2' â‡” f1 = f1' âˆ§ f2 = f2``, ``IS_SOME (OPTION_MAP (f :Î± -> Î²) (x :Î± option)) â‡” IS_SOME x``, ``âˆ€(R :Î± -> Î± -> bool). symmetric (SC R)``, ``(âˆ…áµ£ :Î± -> Î± -> bool) âŠ†áµ£ (R :Î± -> Î± -> bool) âˆ§ (R âŠ†áµ£ (âˆ…áµ£ :Î± -> Î± -> bool) â‡” R = (âˆ…áµ£ :Î± -> Î± -> bool))``, ``âˆ€(t :bool). t âˆ§ T â‡” t``, ``âˆ€(R :Î± -> Î± -> bool) (P :Î± -> Î± -> bool). (âˆ€(x :Î±). P x x) âˆ§ (âˆ€(x :Î±) (y :Î±) (z :Î±). P x y âˆ§ R y z â‡’ P x z) â‡’ âˆ€(x :Î±) (y :Î±). Rê™³ x y â‡’ P x y``, ``âˆ€(p :Î± # Î²) (f :Î± -> Î³) (g :Î² -> Î´). SND ((f ## g) p) = g (SND p)``, ``(âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool) x y â‡’ R ((f :Î± -> Î±) x) (f y)) â‡’ âˆ€(x :Î±) (y :Î±). SC R x y â‡’ SC R (f x) (f y)``, ``(âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool) x y â‡’ R ((f :Î± -> Î±) x) (f y)) â‡’ âˆ€(x :Î±) (y :Î±). Rê™³ x y â‡’ Rê™³ (f x) (f y)``, ``Â¬((p :bool) â‡’ (q :bool)) â‡’ p``, ``(âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool) x y â‡’ (Q :Î± -> Î± -> bool) x y) â‡’ RC R (x :Î±) (y :Î±) â‡’ RC Q x y``, ``transitive (R :Î± -> Î± -> bool) â‡” R âˆ˜áµ£ R âŠ†áµ£ R``, ``âˆ€(R :Î± -> Î± -> bool). transitive Ráµ€ â‡” transitive R``, ``âˆ€(P :Î± -> bool) (v :Î²) (rows :(Î² -> Î± option) list). P (PMATCH v rows) â‡” PMATCH_EXPAND_PRED P v ([] :(Î² -> Î± option) list) rows``, ``âˆ€(m :num) (n :num). m â‰¤ n âŠ— m``, ``âˆ€(R :Î± -> Î± -> bool). (âˆ€(P :Î± -> bool). (âˆ€(x :Î±). (âˆ€(y :Î±). R y x â‡’ P y) â‡’ P x) â‡’ âˆ€(x :Î±). P x) â‡’ WF R``, ``symmetric (R1 :Î± -> Î± -> bool) âˆ§ symmetric (R2 :Î² -> Î² -> bool) â‡’ symmetric (R1 LEX R2)``, ``IDEM (RTC :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``PMATCH_ROW_COND_NOT_EX_OR_EQ (i :Î±) (r :Î± -> Î² option) ([] :(Î± -> Î² option) list) â‡” r i â‰  (NONE :Î² option) â‡’ F``, ``PMATCH_ROW_COND (pat :Î± -> Î²) (guard :Î± -> bool) (inp :Î²) (v :Î±) â‡” inp = pat v âˆ§ guard v``, ``Â¬T â‡” F``, ``OPTION_MAP (f :Î± -> Î²) (x :Î± option) = (option_CASE x (NONE :Î² option) ((SOME :Î² -> Î² option) âˆ˜ f) :Î² option)``, ``(some(x :Î±). F) = (NONE :Î± option)``, ``(y :Î±) âˆˆ RRANGE (R :Î² -> Î± -> bool) â‡” âˆƒ(x :Î²). R x y``, ``âˆ€(P :Î± + Î² -> bool). (âˆƒ(s :Î± + Î²). P s) â‡” (âˆƒ(x :Î±). P (INL x :Î± + Î²)) âˆ¨ âˆƒ(y :Î²). P (INR y :Î± + Î²)``, ``PMATCH (v :Î²) (rows :(Î² -> Î± option) list) = PMATCH v (SNOC (PMATCH_ROW (Î»(_0 :Î²). _0) (Î»(_0 :Î²). T) (Î»(_0 :Î²). (ARB :Î±))) rows)``, ``trichotomous (STRORD (R :Î± -> Î± -> bool)) â‡” trichotomous R``, ``(R :Î± -> Î² -> bool) âˆ˜áµ£ ($= :Î± -> Î± -> bool) = R``, ``âˆ€(R :Î± -> Î± -> bool). equivalence R â‡’ Ráµ€ = R``, ``(OPTION_BIND (p :Î± option) (f :Î± -> Î² option) = (NONE :Î² option) â‡” p = (NONE :Î± option) âˆ¨ âˆƒ(x :Î±). p = SOME x âˆ§ f x = (NONE :Î² option)) âˆ§ (OPTION_BIND p f = SOME (y :Î²) â‡” âˆƒ(x :Î±). p = SOME x âˆ§ f x = SOME y)``, ``DATATYPE ((pair :(Î± -> Î² -> Î± # Î²) -> Î³) ($, :Î± -> Î² -> Î± # Î²))``, ``âˆ€(n :num). Â¬(n < (0 :num))``, ``(option_CASE (x :Î± option) (e :Î²) (f :Î± -> Î²) :Î²) = if IS_SOME x then f (THE x) else e``, ``âˆ€(v :Î±) (p :Î² -> Î±) (g :Î² -> bool) (p' :Î³ -> Î±) (g' :Î³ -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g â‡’ (âˆ€(x :Î²). g x â‡’ ((âˆƒ(x' :Î³). p' x' = p x âˆ§ g' x') â‡” RES)) â‡’ (PMATCH_ROW_COND_EX v p' g' â‡” RES)``, ``Â¬((A :bool) âˆ¨ (B :bool)) â‡’ F â‡” Â¬A â‡’ Â¬B â‡’ F``, ``((if (P :bool) then SOME (x :Î±) else (NONE :Î± option)) = (NONE :Î± option) â‡” Â¬P) âˆ§ ((if P then (NONE :Î± option) else SOME x) = (NONE :Î± option) â‡” P) âˆ§ ((if P then SOME x else (NONE :Î± option)) = SOME (y :Î±) â‡” P âˆ§ x = y) âˆ§ ((if P then (NONE :Î± option) else SOME x) = SOME y â‡” Â¬P âˆ§ x = y)``, ``âˆ€(m :num) (n :num). SUC m = SUC n â‡” m = n``, ``âˆ€(n :num). SUC (m :num) = n â‡’ m < n``, ``Order (R :Î± -> Î± -> bool) â‡” WeakOrder (RC R)``, ``âˆ€(t :bool). F â‡’ t â‡” T``, ``PMATCH_ROW_REDUNDANT (v :Î±) ((r :Î± -> Î² option)::(rs :(Î± -> Î² option) list)) (0 :num) â‡” r v = (NONE :Î² option)``, ``PMATCH_ROW (p :Î² -> Î³) (g :Î² -> bool) (r :Î² -> Î±) (i :Î³) â‰  (NONE :Î± option) â‡” PMATCH_ROW_COND_EX i p g``, ``WF (R :Î± -> Î± -> bool) â‡’ irreflexive R``, ``(antisymmetric (R1 :Î± -> Î± -> bool) â‡’ antisymmetric (R1 âˆ©áµ£ (R2 :Î± -> Î± -> bool))) âˆ§ (antisymmetric R2 â‡’ antisymmetric (R1 âˆ©áµ£ R2))``, ``âˆ€(M :Î± + Î²) (M' :Î± + Î²) (f :Î± -> Î³) (f1 :Î² -> Î³). M = M' âˆ§ (âˆ€(x :Î±). M' = (INL x :Î± + Î²) â‡’ f x = (f' :Î± -> Î³) x) âˆ§ (âˆ€(y :Î²). M' = (INR y :Î± + Î²) â‡’ f1 y = (f1' :Î² -> Î³) y) â‡’ (sum_CASE M f f1 :Î³) = (sum_CASE M' f' f1' :Î³)``, ``âˆ€(R :Î± -> Î± -> bool) (x :Î±) (y :Î±). Rê™³ x y â‡” x = y âˆ¨ Râº x y``, ``âˆ€(R :Î± -> Î± -> bool). (âˆ€(x :Î±). Rê™³ x x) âˆ§ âˆ€(x :Î±) (y :Î±) (z :Î±). R x y âˆ§ Rê™³ y z â‡’ Rê™³ x z``, ``âˆ€(P :Î± -> Î² -> bool). (âˆƒ(x :Î±) (y :Î²). P x y) â‡” âˆƒ((x :Î±),(y :Î²)). P x y``, ``OWHILE (G :Î± -> bool) (f :Î± -> Î±) (s :Î±) = (NONE :Î± option) â‡” âˆ€(n :num). G (FUNPOW f n s)``, ``âˆ€(t :bool). t â‡’ T â‡” T``, ``(x :Î±) âˆˆ RDOM ((R1 :Î± -> Î² -> bool) âˆªáµ£ (R2 :Î± -> Î² -> bool)) â‡” x âˆˆ RDOM R1 âˆ¨ x âˆˆ RDOM R2``, ``âˆ€(a1 :Î±) (a2 :Î±). ind_type$INJA a1 = ind_type$INJA a2 â‡” a1 = a2``, ``âˆ€(Q :num -> bool) (P :num -> bool). (âˆƒ(n :num). P n) âˆ§ (âˆ€(n :num). (âˆ€(m :num). m < n â‡’ Â¬P m) âˆ§ P n â‡’ Q n) â‡’ Q ($LEAST P)``, ``âˆ€(ss :Î± + Î²). (âˆƒ(x :Î±). ss = (INL x :Î± + Î²)) âˆ¨ âˆƒ(y :Î²). ss = (INR y :Î± + Î²)``, ``âˆ€(f :Î± # Î² -> Î³). UNCURRY (CURRY f) = f``, ``âˆ€(x :Î± + Î²). ISL x âˆ¨ ISR x``, ``âˆ€(R :Î± -> Î± -> bool) (RTC' :Î± -> Î± -> bool). (âˆ€(x :Î±). RTC' x x) âˆ§ (âˆ€(x :Î±) (y :Î±) (z :Î±). R x y âˆ§ RTC' y z â‡’ RTC' x z) â‡’ âˆ€(a0 :Î±) (a1 :Î±). Rê™³ a0 a1 â‡’ RTC' a0 a1``, ``âˆ€(R :Î± -> Î± -> bool). StrongOrder R â‡’ Order R``, ``âˆ€(R :Î± -> Î± -> bool). transitive Rê™³``, ``IDEM (STRORD :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``âˆ€(p :Î± -> Î²) (g :Î± -> bool) (r :Î± -> Î³) (v :Î²) (rows :(Î² -> Î³ option) list). (âˆ€(x :Î±). r x = (ARB :Î³)) â‡’ PMATCH v (SNOC (PMATCH_ROW p g r) rows) = PMATCH v rows``, ``(âˆ€(x :Î±) (y :Î²). (P :Î± -> Î² -> bool) x y â‡’ (Q :Î± -> Î² -> bool) x y) â‡’ OPTREL P (x :Î± option) (y :Î² option) â‡’ OPTREL Q x y``, ``total (R1 :Î± -> Î± -> bool) âˆ§ total (R2 :Î² -> Î² -> bool) â‡’ total (R1 LEX R2)``, ``âˆ€(R :Î± -> Î± -> bool). symmetric R â‡’ SC R = R``, ``OPTION_MAP2 (f :Î± -> Î² -> Î³) (o1 :Î± option) (o2 :Î² option) = SOME (v :Î³) â‡” âˆƒ(x1 :Î±) (x2 :Î²). o1 = SOME x1 âˆ§ o2 = SOME x2 âˆ§ v = f x1 x2``, ``âˆ€(x :Î± option option) (y :Î±). OPTION_JOIN x = SOME y â‡” x = SOME (SOME y)``, ``âˆ€(R :Î± -> Î± -> bool). equivalence R â‡” âˆ€(x :Î±) (y :Î±). R x y â‡” R x = R y``, ``âˆ€(f :Î± -> Î²) (R :Î± -> Î± -> bool) (D :Î± -> bool) (P :Î± -> Î² -> bool) (M :(Î± -> Î²) -> Î± -> Î²) (x :Î±). f = WFREC R M âˆ§ WF R âˆ§ INDUCTIVE_INVARIANT_ON R D P M âˆ§ D x â‡’ P x (f x)``, ``IDEM (RC :(Î± -> Î± -> bool) -> Î± -> Î± -> bool)``, ``âˆ€(x :Î±) (y :Î²). FST (x,y) = x``, ``(âˆ€(x :Î±) (y :Î±). (P :Î± -> bool) x âˆ§ (R :Î± -> Î± -> bool) x y â‡’ P y) â‡’ âˆ€(x :Î±) (y :Î±). P x âˆ§ Rê™³ x y â‡’ P y``, ``âˆ€(opt1 :Î± option) (opt2 :Î± option) (f1 :Î± -> Î²) (f2 :Î± -> Î²). opt1 = opt2 âˆ§ (âˆ€(x :Î±). opt2 = SOME x â‡’ f1 x = f2 x) â‡’ OPTION_MAP f1 opt1 = OPTION_MAP f2 opt2``, ``âˆ€(f :Î± -> Î²) (g :Î³ -> Î´) (x :Î±) (y :Î³). (f ## g) (x,y) = (f x,g y)``, ``âˆ€(t :bool). t âˆ¨ t â‡” t``, ``(âˆ€(x :Î±) (y :Î±). (R1 :Î± -> Î± -> bool) x y â‡’ (R2 :Î± -> Î± -> bool) x y) âˆ§ (âˆ€(x :Î²) (y :Î²). (R3 :Î² -> Î² -> bool) x y â‡’ (R4 :Î² -> Î² -> bool) x y) â‡’ (R1 LEX R3) (x :Î± # Î²) (y :Î± # Î²) â‡’ (R2 LEX R4) x y``, ``PMATCH_ROW_COND_EX (i :Î±) (p :Î² -> Î±) (g :Î² -> bool) â‡’ PMATCH_ROW p g (r :Î² -> Î³) i = SOME (r (@(x :Î²). PMATCH_ROW_COND p g i x))``, ``(R :Î± -> Î± -> bool)âº (x :Î±) (z :Î±) â‡” R x z âˆ¨ âˆƒ(y :Î±). Râº x y âˆ§ R y z``, ``âˆ€(R :Î± -> Î± -> bool). Order R â‡” StrongOrder (STRORD R)``]

val s = [``(âˆ€(x :Î±). (P :Î± -> bool) x â‡’ (Q :Î± option -> bool) (SOME x)) âˆ§ ((âˆ€(x :Î±). Â¬P x) â‡’ Q (NONE :Î± option)) â‡’ Q ($some P)``, ``âˆ€(c :bool) (x :bool). (if c then T else x) â‡” Â¬c â‡’ x``, ``âˆ€(R :Î± -> Î± -> bool). irreflexive Ráµ€ â‡” irreflexive R``, ``âˆ€(v :Î±) (rs :(Î± -> Î² option) list). (EVERY (Î»(r :Î± -> Î² option). r v = (NONE :Î² option)) rs â‡’ F) â‡’ PMATCH_IS_EXHAUSTIVE v rs``]

val lv = [``LIST_REL (R :Î± -> Î² -> bool) (xs :Î± list) ((h :Î²)::(t :Î² list)) â‡” âˆƒ(h' :Î±) (t' :Î± list). xs = h'::t' âˆ§ R h' h âˆ§ LIST_REL R t' t``, ``âˆ€(x :Î±) (n :num) (ys :Î± list). LENGTH (LUPDATE x n ys) = LENGTH ys``, ``âˆ€(l :num list). SUM (REVERSE l) = SUM l``, ``âˆ€(x :Î±) (l :Î± list). MEM x l â‡” FOLDR $\\/ F (MAP ($= x) l)``, ``âˆ€(P :Î± -> bool) (l :Î± list). FILTER P l â‰  ([] :Î± list) â‡” âˆƒ(x :Î±). MEM x l âˆ§ P x``, ``(0 :num) = LENGTH (l :Î± list) â‡” l = ([] :Î± list)``, ``âˆ€(L :num list) (n :num). SUM_ACC L n = SUM L + n``, ``âˆ€(l :(Î± # Î²) list). LENGTH (UNZIP_SND l) = LENGTH l``, ``âˆ€(l1 :Î± list) (l2 :Î± list). ALL_DISTINCT (l1 ++ l2) â‡” ALL_DISTINCT l1 âˆ§ ALL_DISTINCT l2 âˆ§ âˆ€(e :Î±). MEM e l1 â‡’ Â¬MEM e l2``, ``âˆ€(P :Î± -> bool) (l :Î± list). LENGTH (FILTER P l) â‰¤ LENGTH l``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ TAKE n (REVERSE l) = REVERSE (LASTN n l)``, ``âˆ€(l :Î± list) (m :num) (x :Î±). MEM x (DROP m l) â‡’ MEM x l``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ BUTLASTN n l = TAKE (LENGTH l âˆ’ n) l``, ``âˆ€(g :Î± -> Î± -> Î±) (f :Î² -> Î± -> Î±). FCOMM g f â‡’ âˆ€(e :Î±). LEFT_ID g e â‡’ âˆ€(l :Î² list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)``, ``(âˆ€(l :Î± list). DROP (0 :num) l = l) âˆ§ âˆ€(n :num) (x :Î±) (l :Î± list). DROP (SUC n) (x::l) = DROP n l``, ``NULL ([] :Î± list) âˆ§ âˆ€(h :Î±) (t :Î± list). Â¬NULL (h::t)``, ``GENLIST (f :num -> Î±) (0 :num) = ([] :Î± list) âˆ§ GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :Î± list)``, ``âˆ€(n :num). n â‰  (0 :num) â‡’ COUNT_LIST n = (0 :num)::MAP SUC (COUNT_LIST (n âˆ’ (1 :num)))``, ``âˆ€(n :num) (l1 :Î± list) (l2 :Î± list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n âˆ’ LENGTH l1) l2``, ``âˆ€(l :Î± list list). LENGTH (FLAT l) = SUM (MAP (LENGTH :Î± list -> num) l)``, ``âˆ€(f :Î± -> Î²) (n :num) (l :Î± list). MAP f (TAKE n l) = TAKE n (MAP f l)``, ``âˆ€(l1 :Î± list) (l2 :Î± list). l1 â‰  l2 â‡’ âˆ€(h1 :Î±) (h2 :Î±). h1::l1 â‰  h2::l2``, ``TAKE (0 :num) (l :Î± list) = ([] :Î± list)``, ``âˆ€(P :Î² -> bool) (f :Î± -> Î²) (l :Î± list). EXISTS P (MAP f l) â‡” EXISTS (Î»(x :Î±). P (f x)) l``, ``MAP (SND :Î² # Î± -> Î±) (FILTER (Î»((x :Î²),(y :Î±)). y â‰  (z :Î±)) (ls :(Î² # Î±) list)) = FILTER (Î»(y :Î±). z â‰  y) (MAP (SND :Î² # Î± -> Î±) ls)``, ``âˆ€(f :Î± -> Î² -> Î²) (e :Î²) (g :Î³ -> Î±) (l :Î³ list). FOLDR f e (MAP g l) = FOLDR (Î»(x :Î³) (y :Î²). f (g x) y) e l``, ``REPLICATE (x :num) (y :Î±) = ([] :Î± list) â‡” x = (0 :num)``, ``âˆ€(n :num). LENGTH (l1 :Î± list) < n â‡’ TAKE n (l1 ++ (l2 :Î± list)) = l1 ++ TAKE (n âˆ’ LENGTH l1) l2``, ``âˆ€(l1 :Î± list) (l2 :Î² list). LENGTH l1 = LENGTH l2 â‡’ LENGTH (ZIP (l1,l2)) = LENGTH l1 âˆ§ LENGTH (ZIP (l1,l2)) = LENGTH l2``, ``âˆ€(ls :Î± list) (n :num). DROP n ls = ([] :Î± list) â‡” LENGTH ls â‰¤ n``, ``âˆ€(n :num) (x :Î±). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x``, ``âˆ€(l1 :Î± list) (l2 :Î± list). Â¬NULL l1 â‡’ ELL (LENGTH l2) (l1 ++ l2) = LAST l1``, ``âˆ€(l :Î± list). NULL l â‡” FOLDL (Î»(x :bool) (l' :Î±). F) T l``, ``(âˆ€(x :Î±). LAST [x] = x) âˆ§ âˆ€(h1 :Î²) (h2 :Î²) (t :Î² list). LAST (h1::h2::t) = LAST (h2::t)``, ``âˆ€(P :Î± -> bool) (l :Î± list). FILTER P l = FOLDR (Î»(x :Î±) (l' :Î± list). if P x then x::l' else l') ([] :Î± list) l``, ``âˆ€(P :Î± -> bool) (l :Î± list). EXISTS P l â‡” FOLDR (Î»(x :Î±) (l' :bool). P x âˆ¨ l') F l``, ``âˆ€(n :num). TAKE n ([] :Î± list) = ([] :Î± list)``, ``âˆ€(l2 :Î± list) (l1 :Î± list). IS_SUFFIX (REVERSE l1) (REVERSE l2) â‡” l2 â‰¼ l1``, ``âˆ€(n :num) (m :num) (l :Î± list). n + m â‰¤ LENGTH l â‡’ LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l)``, ``âˆ€(l :Î± list). DROP (LENGTH l) l = ([] :Î± list)``, ``âˆ€(n :num) (f :num -> Î±). NULL (GENLIST f n) â‡” n = (0 :num)``, ``âˆ€(P :Î± list -> bool). (âˆ€(l :Î± list). LENGTH l = (0 :num) â‡’ P l) â‡” P ([] :Î± list)``, ``âˆ€(y :Î±) (x :Î±) (l :Î± list). MEM y (SNOC x l) â‡” y = x âˆ¨ MEM y l``, ``âˆ€(n :num) (k :num). SUM (REPLICATE n k) = n * k``, ``(n :num) = LENGTH (l1 :Î± list) â‡’ ZIP (l1,COUNT_LIST n) = GENLIST (Î»(n :num). (EL n l1,n)) (LENGTH l1)``, ``âˆ€(l1 :num list) (l2 :num list). SUM (l1 ++ l2) = SUM l1 + SUM l2``, ``âˆ€(n :num) (l :Î± list). n < LENGTH l â‡’ DROP n l = EL n l::DROP (SUC n) l``, ``âˆ€(x :Î± list). x â‰¼ x``, ``âˆ€(P :Î± -> bool) (l :Î± list). FILTER P l = ([] :Î± list) â‡” EVERY (Î»(x :Î±). Â¬P x) l``, ``âˆ€(l :Î± list). NULL l â‡” LENGTH l = (0 :num)``, ``âˆ€(n :num) (m :num) (l :Î± list). DROP n (DROP m l) = DROP (n + m) l``, ``âˆ€(P :Î± -> bool) (Q :Î± -> bool) (l :Î± list). (âˆ€(x :Î±). MEM x l âˆ§ P x â‡’ Q x) âˆ§ EVERY P l â‡’ EVERY Q l``, ``âˆ€(l :Î± list). NULL l â‡” l = ([] :Î± list)``, ``MAP (Î»((x :Î±),(y :Î²),(z :Î³)). x) (funs :(Î± # Î² # Î³) list) = MAP (FST :Î± # Î² # Î³ -> Î±) funs``, ``âˆ€(n :num) (ls :Î± list). n < LENGTH ls â‡’ LUPDATE (EL n ls) n ls = ls``, ``âˆ€(l :Î± list). LENGTH l = FOLDR (Î»(x :Î±) (l' :num). SUC l') (0 :num) l``, ``âˆ€(P :Î± -> bool) (l :Î± list). Â¬EXISTS P l â‡” EVERY ($Â¬ âˆ˜ P) l``, ``âˆ€(n :num) (x :Î±). LENGTH (REPLICATE n x) = n``, ``âˆ€(l1 :Î± list) (l2 :Î± list) (l3 :Î± list). (âˆ€(n :num). n < LENGTH l1 âˆ§ (R :Î± -> Î± -> bool) (EL n l1) (EL n l2) âˆ§ R (EL n l2) (EL n l3) â‡’ R (EL n l1) (EL n l3)) âˆ§ LIST_REL R l1 l2 âˆ§ LIST_REL R l2 l3 â‡’ LIST_REL R l1 l3``, ``âˆ€(x :Î±) (l :Î± list). REVERSE (SNOC x l) = x::REVERSE l``, ``âˆ€(ls :num list). SUM ls = (0 :num) â‡” âˆ€(x :num). MEM x ls â‡’ x = (0 :num)``, ``âˆ€(n :num) (l1 :Î± list) (l2 :Î± list). l1 â‰¼ l2 âˆ§ n < LENGTH l1 âˆ§ n < LENGTH l2 â‡’ EL n l1 = EL n l2``, ``âˆ€(l :Î± list) (x :Î±). l â‰  x::l âˆ§ x::l â‰  l``, ``âˆ€(l :Î± list). IS_SUFFIX l l``, ``âˆ€(a :Î± list) (b :Î± list) (c :Î± list). a ++ b â‰¼ a ++ c â‡” b â‰¼ c``, ``âˆ€(f :Î± -> Î² -> Î²) (e :Î²) (x :Î±) (l :Î± list). FOLDR f e (SNOC x l) = FOLDR f (f x e) l``, ``âˆ€(n :num) (l2 :Î± list). n â‰¤ LENGTH l2 â‡’ âˆ€(l1 :Î± list). LASTN n (l1 ++ l2) = LASTN n l2``, ``âˆ€(x :Î±) (l :Î± list). LENGTH (SNOC x l) = SUC (LENGTH l)``, ``âˆ€(l :Î± list) (f :Î± -> Î²). LENGTH (MAP f l) = LENGTH l``, ``LIST_BIND [(x :Î²)] (f :Î² -> Î± list) = f x``, ``âˆ€(l :Î± list) (x :Î±). ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l``, ``âˆ€(P :num -> bool) (n :num). EVERY P (COUNT_LIST n) â‡” âˆ€(m :num). m < n â‡’ P m``, ``(l1 :Î± list) ++ (l2 :Î± list) = [(e :Î±)] â‡” l1 = [e] âˆ§ l2 = ([] :Î± list) âˆ¨ l1 = ([] :Î± list) âˆ§ l2 = [e]``, ``âˆ€(P :Î± -> bool) (ls :Î± list). NULL (FILTER P ls) â‡” âˆ€(x :Î±). MEM x ls â‡’ Â¬P x``, ``âˆ€(f :Î± -> bool) (l :Î± list). FILTER f (FILTER f l) = FILTER f l``, ``âˆ€(l :Î± list). l â‰  ([] :Î± list) â‡’ FRONT l ++ [LAST l] = l``, ``âˆ€(pl :(Î± # Î²) list). LENGTH (FST (UNZIP pl)) = LENGTH pl âˆ§ LENGTH (SND (UNZIP pl)) = LENGTH pl``, ``âˆ€(l1 :Î± list) (l2 :Î± list). REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1``, ``âˆ€(x :Î± list) (l :Î± list list). FLAT (SNOC x l) = FLAT l ++ x``, ``âˆ€(xs :Î± list). FILTER (Î»(x :Î±). F) xs = ([] :Î± list)``, ``âˆ€(f :Î± -> Î²) (l :Î± list) (a :Î±). MEM a l â‡’ MEM (f a) (MAP f l)``, ``âˆ€(f :Î± -> Î²) (l1 :Î± list) (l2 :Î± list). INJ f (set l1 âˆª set l2) ð•Œ(:Î²) â‡’ (MAP f l1 = MAP f l2 â‡” l1 = l2)``, ``âˆ€(m :num) (n :num) (l :Î± list). m â‰¤ n âˆ§ n â‰¤ LENGTH l â‡’ BUTLASTN m (LASTN n l) = LASTN (n âˆ’ m) (BUTLASTN m l)``, ``(âˆ€(x :Î±) (y :Î²). (R1 :Î± -> Î² -> bool) x y â‡’ (R2 :Î± -> Î² -> bool) x y) â‡’ LIST_REL R1 (l1 :Î± list) (l2 :Î² list) â‡’ LIST_REL R2 l1 l2``, ``âˆ€(n :num) (x :Î±). REPLICATE n x = GENLIST (K x :num -> Î±) n``, ``âˆ€(l :Î± list) (x :Î±). BUTLASTN (LENGTH l) (x::l) = [x]``, ``âˆ€(x :Î±) (L :Î± list list). MEM x (FLAT L) â‡” âˆƒ(l :Î± list). MEM l L âˆ§ MEM x l``, ``MAP (Î»(x :Î±). x) (l :Î± list) = l âˆ§ MAP (I :Î± -> Î±) l = l``, ``âˆ€(f :Î² -> Î± -> Î²) (e :Î²) (x :Î±) (l :Î± list). FOLDL f e (SNOC x l) = f (FOLDL f e l) x``, ``(âˆ€(l :Î± list). l ++ ([] :Î± list) = l) âˆ§ âˆ€(l :Î² list). ([] :Î² list) ++ l = l``, ``EVERY (P :Î± -> bool) (FLAT (ls :Î± list list)) â‡” EVERY (EVERY P) ls``, ``âˆ€(P :Î± -> bool) (l1 :Î± list) (l2 :Î± list). EVERY P l1 â‡’ dropWhile P (l1 ++ l2) = dropWhile P l2``, ``âˆ€(l :Î± list) (m :num) (x :Î±). MEM x (TAKE m l) â‡’ MEM x l``, ``âˆ€(y :Î±) (l :Î± list). MEM y l â‡” FOLDR (Î»(x :Î±) (l' :bool). y = x âˆ¨ l') F l``]

val sv = [``âˆ€(s :Î² -> bool). FUNSET (âˆ… :Î± -> bool) s = ð•Œ(:Î± -> Î²)``, ``âˆ€(f :Î± -> Î²) (s :Î± -> bool) (t :Î² -> bool). INJ f s t â‡’ INJ f s (IMAGE f s)``, ``âˆ€(f :Î± -> Î²) (s :(Î² -> bool) -> bool). PREIMAGE f (BIGUNION s) = BIGUNION (IMAGE (PREIMAGE f) s)``, ``âˆ€(x :Î± -> bool) (y :Î± -> bool) (z :Î± -> bool). x DIFF (y âˆª z) = x DIFF y DIFF z``, ``âˆ€(f :Î± -> Î²). (âˆ€(s :Î² -> bool). SURJ f (âˆ… :Î± -> bool) s â‡” s = (âˆ… :Î² -> bool)) âˆ§ âˆ€(s :Î± -> bool). SURJ f s (âˆ… :Î² -> bool) â‡” s = (âˆ… :Î± -> bool)``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). s âˆ© t = t âˆ© s``, ``âˆ€(s :Î± -> bool). Â¬(s âŠ‚ (âˆ… :Î± -> bool))``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (x :Î±). (s DELETE x) âˆ© t = s âˆ© t DELETE x``, ``âˆ€(x :Î±) (P :Î± -> bool). x âˆˆ P â‡” P x``, ``âˆ€(P :Î± -> bool) (B :(Î± -> bool) -> bool). BIGINTER (P INSERT B) = P âˆ© BIGINTER B``, ``âˆ€(P :Î± -> bool). INFINITE P â‡’ âˆƒ(x :Î±). x âˆˆ P``, ``âˆ€(s :Î± -> bool). (âˆƒ(f :num -> Î±). BIJ f ð•Œ(:num) s) â‡’ countable s``, ``âˆ€(P :Î± -> bool) (s :Î± -> bool) (t :Î± -> bool). (âˆ€(x :Î±). x âˆˆ s âˆª t â‡’ P x) â‡” (âˆ€(x :Î±). x âˆˆ s â‡’ P x) âˆ§ âˆ€(x :Î±). x âˆˆ t â‡’ P x``, ``BIGUNION (âˆ… :(Î± -> bool) -> bool) = (âˆ… :Î± -> bool)``, ``BIJ (f :Î± -> Î²) ð•Œ(:Î±) ð•Œ(:Î²) â‡’ âˆ€(x :Î±) (y :Î±). f x = f y â‡” x = y``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (x :Î±). x âˆˆ s âˆ© t â‡” x âˆˆ s âˆ§ x âˆˆ t``, ``âˆ€(s :Î± -> bool). INFINITE s â‡” âˆ€(t :Î± -> bool). FINITE t â‡’ t âŠ† s â‡’ t âŠ‚ s``, ``âˆ€(s :Î± -> bool). s DIFF s = (âˆ… :Î± -> bool)``, ``âˆ€(x :Î±) (s :Î± -> bool). x âˆˆ s â‡’ x INSERT s DELETE x = s``, ``âˆ€(x :Î±) (y :Î±) (s :Î± -> bool). (x INSERT s) DELETE y = if x = y then s DELETE y else x INSERT s DELETE y``, ``âˆ€(s :Î± -> bool). FINITE s â‡’ âˆƒ(f :num -> Î±) (b :num). BIJ f (count b) s``, ``(y :Î±) âˆˆ {x | (P :Î± -> bool) x} â‡” P y``, ``{(x,y) | (P :Î± -> Î² -> bool) x y} = UNCURRY P``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). s âŠ† t âˆ§ countable t â‡’ countable s``, ``(âˆ€(s :Î± -> bool) (t :Î± -> bool). s âˆª (t DIFF s) = s âˆª t) âˆ§ âˆ€(s :Î± -> bool) (t :Î± -> bool). t DIFF s âˆª s = t âˆª s``, ``âˆ€(P :Î± -> bool) (f :Î² -> Î±) (s :Î² -> bool). (âˆƒ(y :Î±). y âˆˆ IMAGE f s âˆ§ P y) â‡” âˆƒ(x :Î²). x âˆˆ s âˆ§ P (f x)``, ``SURJ (f :Î± -> Î²) (s :Î± -> bool) (IMAGE f s)``, ``âˆ€(s :Î± -> bool). COMPL (COMPL s) = s``, ``âˆ€(x :Î±) (s :Î± -> bool). x âˆˆ s â‡’ x INSERT s = s``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). s âŠ‚ t â‡” s âŠ† t âˆ§ âˆƒ(y :Î±). y âˆˆ t âˆ§ y âˆ‰ s``, ``âˆ€(s1 :Î± -> bool) (s2 :Î± -> bool) (x :Î±). s1 âŠ† s2 â‡’ s1 DELETE x âŠ† s2 DELETE x``, ``âˆ€(s :Î± -> bool). (âˆ… :Î± -> bool) DIFF s = (âˆ… :Î± -> bool)``, ``âˆ€(f :Î± -> Î² -> bool) (s :Î³ -> bool) (t :Î± -> bool). s Ã— BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Î»(n :Î±). s Ã— f n) t)``, ``âˆ€(s :Î± -> bool). DISJOINT (âˆ… :Î± -> bool) s âˆ§ DISJOINT s (âˆ… :Î± -> bool)``, ``âˆ€(s :num -> bool). s â‰  (âˆ… :num -> bool) âˆ§ FINITE s â‡’ MIN_SET s â‰¤ MAX_SET s``, ``âˆ€(x :Î±). ð•Œ(:Î±) x``, ``âˆ€(s :Î± -> bool). s âŠ† (âˆ… :Î± -> bool) â‡” s = (âˆ… :Î± -> bool)``, ``âˆ€(s :Î± -> bool). s âˆª s = s``, ``âˆ€(P :Î± -> bool) (a :Î±) (s :Î± -> bool). (âˆƒ(x :Î±). x âˆˆ a INSERT s âˆ§ P x) â‡” P a âˆ¨ âˆƒ(x :Î±). x âˆˆ s âˆ§ P x``, ``âˆ€(s :Î± -> bool). ð•Œ(:Î±) âŠ† s â‡” s = ð•Œ(:Î±)``, ``âˆ€(x :Î±) (s :Î± -> bool). COMPL s x â‡” x âˆ‰ s``, ``(âˆ€(x :num). pair_to_num (num_to_pair x) = x) âˆ§ âˆ€(x :num) (y :num). num_to_pair (pair_to_num (x,y)) = (x,y)``, ``âˆ€(R :Î± -> Î± -> bool) (s :Î± -> bool) (t :Î± -> bool). t âˆˆ partition R s â‡’ t âŠ† s``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (u :Î± -> bool). s âŠ† t âˆ© u â‡” s âŠ† t âˆ§ s âŠ† u``, ``pairwise (R :Î± -> Î± -> bool) ((s1 :Î± -> bool) âˆª (s2 :Î± -> bool)) â‡” pairwise R s1 âˆ§ pairwise R s2 âˆ§ âˆ€(x :Î±) (y :Î±). x âˆˆ s1 âˆ§ y âˆˆ s2 â‡’ R x y âˆ§ R y x``, ``âˆ€(I :num -> bool) (J :num -> bool) (n :Î±). I â‰  (âˆ… :num -> bool) âˆ§ J â‰  (âˆ… :num -> bool) âˆ§ I âŠ† J â‡’ MIN_SET J â‰¤ MIN_SET I``, ``INFINITE ð•Œ(:Î±) â‡” âˆ€(s :Î± -> bool). FINITE s â‡’ âˆƒ(x :Î±). x âˆ‰ s``, ``âˆ€(s :Î± -> bool). FINITE s â‡’ countable s``, ``{x | (y :Î±) = x} = {y}``, ``âˆ€(x :Î±) (s :Î± -> bool). x âˆˆ REST s â‡” x âˆˆ s âˆ§ x â‰  CHOICE s``, ``âˆ€(f :Î± -> Î²) (s :Î± -> bool) (t :Î± -> bool). IMAGE f (s âˆ© t) âŠ† IMAGE f s âˆ© IMAGE f t``, ``âˆ€(s :Î± -> bool). Â¬(ð•Œ(:Î±) âŠ‚ s)``, ``âˆ€(X :Î± -> bool) (P :(Î± -> bool) -> bool). BIGUNION P âŠ† X â‡” âˆ€(Y :Î± -> bool). Y âˆˆ P â‡’ Y âŠ† X``, ``âˆ€(s :Î± -> bool) (n :num). s HAS_SIZE n â‡’ CARD s = n``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). INFINITE s âˆ§ FINITE t â‡’ s DIFF t â‰  (âˆ… :Î± -> bool)``, ``âˆ€(m :num) (n :num). count n m â‡” m < n``, ``IMAGE (f :Î² -> Î±) (s :Î² -> bool) = {(z :Î±)} â‡” s â‰  (âˆ… :Î² -> bool) âˆ§ âˆ€(x :Î²). x âˆˆ s â‡’ f x = z``, ``âˆ€(x :Î±) (y :Î±). {x} = {y} â‡” x = y``, ``(âˆ€(s :Î± -> bool). (âˆ… :Î± -> bool) âˆª s = s) âˆ§ âˆ€(s :Î± -> bool). s âˆª (âˆ… :Î± -> bool) = s``, ``âˆ€(f :Î± -> Î²) (s :Î² -> bool) (t :Î² -> bool). PREIMAGE f (s DIFF t) = PREIMAGE f s DIFF PREIMAGE f t``, ``âˆ€(f :Î± -> Î²) (x :Î±) (s :Î± -> bool) (t :Î² -> bool). INJ f (x INSERT s) t â‡” INJ f s t âˆ§ f x âˆˆ t âˆ§ âˆ€(y :Î±). y âˆˆ s âˆ§ f x = f y â‡’ x = y``, ``âˆ€(y :Î²) (s :Î± -> bool) (f :Î± -> Î²). IMAGE f s y â‡” âˆƒ(x :Î±). y = f x âˆ§ x âˆˆ s``, ``âˆ€(e :Î±) (s :Î± -> bool). POW (e INSERT s) = IMAGE ($INSERT e) (POW s) âˆª POW s``, ``âˆ€(r :Î± -> bool) (s :Î± -> bool) (t :Î± -> bool). r âŠ† s â‡’ r DIFF s âˆ© t = r DIFF t``, ``(âˆ€(s :Î± -> bool). ð•Œ(:Î±) âˆ© s = s) âˆ§ âˆ€(s :Î± -> bool). s âˆ© ð•Œ(:Î±) = s``, ``count (0 :num) = (âˆ… :num -> bool)``, ``âˆ€(x :Î±) (s :Î± -> bool) (t :Î± -> bool). (x INSERT s) âˆª t = if x âˆˆ t then s âˆª t else x INSERT s âˆª t``, ``âˆ€(P :Î± -> bool) (s :(Î± -> bool) -> bool). (âˆ€(x :Î±). x âˆˆ BIGUNION s â‡’ P x) â‡” âˆ€(t :Î± -> bool) (x :Î±). t âˆˆ s âˆ§ x âˆˆ t â‡’ P x``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (u :Î± -> bool). s âŠ‚ t âˆ§ t âŠ† u â‡’ s âŠ‚ u``, ``âˆ€(p :Î± -> bool) (q :Î± -> bool). p âˆ© q âˆª COMPL p âˆ© q = q``, ``(âˆ€(x :Î±). x âˆˆ (s :Î± -> bool) â‡’ (INR x :Î² + Î±) âˆˆ (t :Î² + Î± -> bool)) â‡’ INJ (INR :Î± -> Î² + Î±) s t``, ``(âˆ€(x :Î±). x âˆˆ (s :Î± -> bool) â‡’ (INL x :Î± + Î²) âˆˆ (t :Î± + Î² -> bool)) â‡’ INJ (INL :Î± -> Î± + Î²) s t``, ``âˆ€(x :Î±) (s :Î± -> bool) (t :Î± -> bool). DISJOINT (x INSERT s) t â‡” DISJOINT s t âˆ§ x âˆ‰ t``, ``âˆ€(s :Î± -> bool) (x :Î±). x âˆˆ s â‡” âˆƒ(t :Î± -> bool). s = x INSERT t âˆ§ x âˆ‰ t``, ``âˆ€(f :Î± -> Î²). (âˆ€(s :Î² -> bool). INJ f (âˆ… :Î± -> bool) s) âˆ§ âˆ€(s :Î± -> bool). INJ f s (âˆ… :Î² -> bool) â‡” s = (âˆ… :Î± -> bool)``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (u :Î± -> bool) (v :Î± -> bool). DISJOINT s t âˆ§ u âŠ† s âˆ§ v âŠ† t â‡’ DISJOINT u v``, ``(s0 :Î± -> bool) âŠ† (s :Î± -> bool) âˆ§ INJ (f :Î± -> Î²) s (t :Î² -> bool) â‡’ BIJ f s0 (IMAGE f s0)``, ``âˆ€(f :Î± -> Î² -> bool) (s :Î± -> bool) (t :Î³ -> bool). BIGUNION (IMAGE f s) Ã— t = BIGUNION (IMAGE (Î»(n :Î±). f n Ã— t) s)``, ``(R :Î± -> Î± -> bool) equiv_on (s :Î± -> bool) â‡’ âˆ€(t1 :Î± -> bool) (t2 :Î± -> bool). t1 âˆˆ partition R s âˆ§ t2 âˆˆ partition R s âˆ§ t1 â‰  t2 â‡’ DISJOINT t1 t2``, ``âˆ€(s :Î± -> bool) (x :Î±). x âˆˆ s â‡’ (s DELETE x = (âˆ… :Î± -> bool) â‡” s = {x})``, ``âˆ€(f :Î± -> Î²) (s :Î± -> bool) (t :Î² -> bool). INJ f s t âˆ§ INFINITE s â‡’ INFINITE t``, ``âˆ€(s :Î± -> bool). SING s â‡’ FINITE s``]

val lall = [``âˆ€(s :Î± -> bool) (t :Î± -> bool). t âŠ† s â‡’ s DIFF (s DIFF t) = t``, ``âˆ€(set :Î± -> bool) (e :Î± -> bool). e âˆˆ POW set â‡” e âŠ† set``, ``FINITE ð•Œ(:Î± # Î²) â‡” FINITE ð•Œ(:Î±) âˆ§ FINITE ð•Œ(:Î²)``, ``âˆ€(f :Î± -> Î²) (s :Î± -> bool) (t :Î² -> bool). FINITE s âˆ§ BIJ f s t â‡’ CARD s = CARD t``, ``{x | T} = ð•Œ(:Î±)``, ``COMPL (âˆ… :Î± -> bool) = ð•Œ(:Î±)``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). s = t â‡” âˆ€(x :Î±). x âˆˆ s â‡” x âˆˆ t``, ``âˆ€(s :Î± -> bool). (âˆƒ(f :num -> Î±). BIJ f ð•Œ(:num) s) â‡’ countable s``, ``âˆ€(a0 :Î±) (a1 :Î± list) (a0' :Î±) (a1' :Î± list). a0::a1 = a0'::a1' â‡” a0 = a0' âˆ§ a1 = a1``, ``âˆ€(s1 :(Î± -> bool) -> bool) (s2 :(Î± -> bool) -> bool). BIGINTER (s1 âˆª s2) = BIGINTER s1 âˆ© BIGINTER s2``, ``âˆ€(f :Î± -> Î² -> bool) (s :Î³ -> bool) (t :Î± -> bool). s Ã— BIGUNION (IMAGE f t) = BIGUNION (IMAGE (Î»(n :Î±). s Ã— f n) t)``, ``PMATCH_EQUIV_ROWS (v :Î±) (rows1 :(Î± -> Î² option) list) (rows2 :(Î± -> Î² option) list) â‡’ PMATCH v rows1 = PMATCH v rows2``, ``âˆ€(l :Î± list) (x :Î±). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]``, ``âˆ€(s :Î± -> bool). FINITE s â‡’ countable s``, ``âˆ€(l :Î± list). FINITE (set l)``, ``âˆ€(f :Î± -> num) (x :Î±) (ls :Î± list). MEM x ls â‡’ f x â‰¤ SUM (MAP f ls)``, ``âˆ€(x :Î±) (s :Î± -> bool). x âˆˆ x INSERT s``, ``âˆ€(n :num) (l :Î± list). n < LENGTH l â‡’ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)``, ``âˆ€(v :Î±) (p :Î² -> Î±) (g :Î² -> bool) (p' :Î³ -> Î±) (g' :Î³ -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g â‡’ (âˆ€(x :Î²). g x â‡’ ((âˆƒ(x' :Î³). p' x' = p x âˆ§ g' x') â‡” RES)) â‡’ (PMATCH_ROW_COND_EX v p' g' â‡” RES)``, ``âˆ€(x :Î±). (âˆ… :Î± -> bool) DELETE x = (âˆ… :Î± -> bool)``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). s DIFF t âˆ© s = s DIFF t``, ``âˆ€(n :num) (l1 :Î± list) (l2 :Î± list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n âˆ’ LENGTH l1) l2``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (u :Î± -> bool). s âˆ© (t âˆ© u) = s âˆ© t âˆ© u``, ``âˆ€(P :Î± list -> bool). (âˆ€(l :Î± list). LENGTH l = (0 :num) â‡’ P l) â‡” P ([] :Î± list)``, ``ASSOC ($++ :Î± list -> Î± list -> Î± list)``, ``PMATCH_ROW_REDUNDANT (v :Î±) ([] :(Î± -> Î² option) list) (i :num) â‡” F``, ``âˆ€(ZRECSPACE' :(num -> Î± -> bool) -> bool). ZRECSPACE' (ind_type$ZBOT :num -> Î± -> bool) âˆ§ (âˆ€(c :num) (i :Î±) (r :num -> num -> Î± -> bool). (âˆ€(n :num). ZRECSPACE' (r n)) â‡’ ZRECSPACE' (ind_type$ZCONSTR c i r)) â‡’ âˆ€(a0 :num -> Î± -> bool). ZRECSPACE a0 â‡’ ZRECSPACE' a0``, ``âˆ€(l1 :Î± list) (l2 :Î² list). LENGTH l1 = LENGTH l2 â‡’ âˆ€(x1 :Î±) (x2 :Î²). ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))``, ``Â¬SHORTLEX (R :Î± -> Î± -> bool) (l :Î± list) ([] :Î± list)``, ``âˆ€(e :Î±). âˆƒ(fn :unit -> Î±). fn () = e``, ``âˆ€(l :Î± list). l â‰  ([] :Î± list) â‡’ FRONT l ++ [LAST l] = l``, ``âˆ€(l :Î± list) (n :num). n < LENGTH l â‡’ LAST (DROP n l) = LAST l``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ âˆ€(x :Î±). BUTLASTN n (x::l) = x::BUTLASTN n l``, ``âˆ€(f :Î± -> Î²) (s :Î² -> bool) (t :Î² -> bool). DISJOINT s t â‡’ DISJOINT (PREIMAGE f s) (PREIMAGE f t)``, ``(âˆƒ(ls :Î± list). (P :Î± list -> bool) ls) â‡” âˆƒ(n :num) (f :num -> Î±). P (GENLIST f n)``, ``nub ([] :Î± list) = ([] :Î± list)``, ``WF (R :Î± -> Î± -> bool)âº â‡” WF R``, ``âˆ€(n :num). countable (count n)``, ``{x | (y :Î±) = x} = {y}``, ``âˆ€(x :Î±) (l :Î± list). SNOC x l = l ++ [x]``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). DISJOINT s t â‡” âˆ€(x :Î±). x âˆˆ s â‡’ x âˆ‰ t``, ``GENLIST (f :num -> Î±) (0 :num) = ([] :Î± list) âˆ§ GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :Î± list)``, ``âˆ€(s :Î±) (x :Î± -> bool). x âŠ‚ {s} â‡” x = (âˆ… :Î± -> bool)``, ``âˆ€(R :Î± -> Î± -> bool). symmetric Ráµ€ â‡” symmetric R``, ``âˆ€(t1 :Î±) (t2 :Î±). (if F then t1 else t2) = t2``, ``âˆ€(l1 :Î± list) (l2 :Î± list). set (l1 ++ l2) = set l1 âˆª set l2``, ``âˆ€(l1 :Î± list) (l2 :Î± list). l2 â‰¼ l1 â‡” âˆƒ(l :Î± list). l1 = l2 ++ l``, ``âˆ€(R :Î± -> Î± -> bool). irreflexive Ráµ€ â‡” irreflexive R``, ``âˆ€(s :Î± -> bool). CHOICE s âˆ‰ REST s``, ``âˆ€(l1 :Î± list) (l2 :Î± list). l1 ++ l2 = FOLDL (Î»(l' :Î± list) (x :Î±). SNOC x l') l1 l2``, ``âˆ€(L :Î± list) (n :num). LEN L n = LENGTH L + n``, ``âˆ€(x :bool) (x' :bool) (y :bool) (y' :bool). (x â‡’ y' â‡’ y) âˆ§ (Â¬y' â‡’ x â‡’ x') â‡’ (x' â‡’ y') â‡’ x â‡’ y``, ``âˆ€(P :Î± -> bool) (l :Î± list). EVERY P l â‡” âˆ€(e :Î±). MEM e l â‡’ P e``, ``âˆ€(n1 :num) (n2 :num). count n1 = count n2 â‡” n1 = n2``, ``âˆ€(n :num). (0 :num) < n â‡’ âˆ€(x :Î±) (l :Î± list). EL n (x::l) = EL (PRE n) l``, ``âˆ€(e :Î±) (l :Î± list). LIST_ELEM_COUNT e l > (0 :num) â‡” MEM e l``, ``âˆ€(t :bool). t âˆ¨ t â‡” t``, ``(âˆ€(x :Î±) (y :Î±). (f :Î± -> Î²) x = f y â‡” x = y) â‡’ (DISJOINT (IMAGE f (s1 :Î± -> bool)) (IMAGE f (s2 :Î± -> bool)) â‡” DISJOINT s1 s2)``, ``âˆ€(x :bool) (x' :bool) (y :bool) (y' :bool). (y â‡’ x' â‡’ x) âˆ§ (x' â‡’ y' â‡’ y) â‡’ x' âˆ§ y' â‡’ x âˆ§ y``, ``âˆ€(n :num). DROP n ([] :Î± list) = ([] :Î± list)``, ``âˆ€(s :Î± -> bool). s âŠ‚ ð•Œ(:Î±) â‡” âˆƒ(x :Î±). x âˆ‰ s``, ``(Q :Î± option -> bool) ($some (P :Î± -> bool)) â‡’ (âˆƒ(x :Î±). P x âˆ§ Q (SOME x)) âˆ¨ (âˆ€(x :Î±). Â¬P x) âˆ§ Q (NONE :Î± option)``, ``transitive ($SUBSET :(Î± -> bool) -> (Î± -> bool) -> bool)``, ``âˆ€(f :Î± -> Î²) (g :Î² -> Î³) (s :Î± -> bool) (t :Î² -> bool) (u :Î³ -> bool). INJ f s t âˆ§ INJ g t u â‡’ INJ (g âˆ˜ f) s u``, ``âˆ€(y :Î²) (s :Î± -> bool) (f :Î± -> Î²). IMAGE f s y â‡” âˆƒ(x :Î±). y = f x âˆ§ x âˆˆ s``, ``âˆ€(f :Î± -> Î²) (g :Î² -> Î³) (s :Î± -> bool) (t :Î² -> bool) (u :Î³ -> bool). SURJ f s t âˆ§ SURJ g t u â‡’ SURJ (g âˆ˜ f) s u``, ``âˆ€(f :'z -> 'z). INVOL f â‡’ âˆ€(a :'z) (b :'z). f a = f b â‡” a = b``, ``âˆ€(l1 :Î± list) (l2 :Î± list) (l3 :Î± list). l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3``, ``$OLEAST (P :num -> bool) = (NONE :num option) â‡” âˆ€(n :num). Â¬P n``, ``âˆ€(n :num) (l1 :Î± list) (l2 :Î± list). DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n âˆ’ LENGTH l1) l2``, ``âˆ€(ls :Î± list) (f :Î² -> Î±). EVERY (Î»(x :Î±). âˆƒ(y :Î²). x = f y) ls â‡’ âˆƒ(l :Î² list). ls = MAP f l``, ``âˆ€(opt :Î± option). (âˆƒ(x :Î±). opt = SOME x) âˆ¨ opt = (NONE :Î± option)``, ``SURJ (f :Î± -> Î²) (s :Î± -> bool) (t :Î² -> bool) â‡’ âˆƒ(g :Î² -> Î±). INJ g t s âˆ§ âˆ€(y :Î²). y âˆˆ t â‡’ f (g y) = y``, ``âˆ€(R :Î± -> Î± -> bool) (x :Î±) (y :Î±) (z :Î±). Rê™³ x y âˆ§ R y z â‡’ Râº x z``, ``âˆ€(f :Î± -> Î²) (s :Î± -> bool) (t :Î² -> bool). INJ f s t âˆ§ INFINITE s â‡’ INFINITE t``, ``âˆ€(x1 :Î±) (l1 :Î± list) (x2 :Î±) (l2 :Î± list). SNOC x1 l1 = SNOC x2 l2 â‡’ LENGTH l1 = LENGTH l2``, ``âˆ€(x :Î±) (l :Î± list). TL (SNOC x l) = if NULL l then ([] :Î± list) else SNOC x (TL l)``, ``âˆ€(P :Î± list -> bool) (n :num). (âˆ€(l :Î± list). LENGTH l = SUC n â‡’ P l) â‡” âˆ€(l :Î± list). LENGTH l = n â‡’ (Î»(l :Î± list). âˆ€(x :Î±). P (x::l)) l``, ``(x :Î±) âˆˆ RDOM (RRESTRICT (R :Î± -> Î² -> bool) (s :Î± -> bool)) â‡” x âˆˆ RDOM R âˆ§ x âˆˆ s``, ``âˆ€(x :Î±) (l :Î± list). FRONT (SNOC x l) = l``, ``âˆ€(l :Î± list) (x :Î±). MEM x (REVERSE l) â‡” MEM x l``, ``âˆ€(l :Î± list). NULL l â‡” FOLDL (Î»(x :bool) (l' :Î±). F) T l``, ``âˆ€(l :Î± list) (m :num) (x :Î±). MEM x (DROP m l) â‡’ MEM x l``, ``âˆ€(x :Î± + Î²). ISR x â‡’ (INR (OUTR x) :Î± + Î²) = x``, ``(([(f :Î² -> Î±)] <*> (l :Î² list)) :Î± list) = MAP f l``, ``âˆ€(n :num) (x :Î±). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x``, ``âˆ€(s :Î± -> bool) (x :Î±) (y :Î±). x INSERT s = {y} â‡” x = y âˆ§ s âŠ† {y}``, ``âˆ€(n :num) (l1 :Î± list) (l2 :Î± list). l1 â‰¼ l2 âˆ§ n < LENGTH l1 âˆ§ n < LENGTH l2 â‡’ EL n l1 = EL n l2``, ``âˆ€(R :Î± -> Î± -> bool). reflexive (RC R)``, ``(R1 :Î³ -> Î² -> bool) âˆ˜áµ£ (R2 :Î´ -> Î³ -> bool) âˆ˜áµ£ (R3 :Î± -> Î´ -> bool) = (R1 âˆ˜áµ£ R2) âˆ˜áµ£ R3``, ``âˆ€(n :num). (0 :num) < n â‡’ âˆ€(x :Î±) (l :Î± list). ELL n (SNOC x l) = ELL (PRE n) l``, ``âˆ€(l1 :Î± list) (l2 :Î± list). ALL_DISTINCT (l1 ++ l2) â‡” ALL_DISTINCT l1 âˆ§ ALL_DISTINCT l2 âˆ§ âˆ€(e :Î±). MEM e l1 â‡’ Â¬MEM e l2``, ``âˆ€(l :Î± list). l â‰  ([] :Î± list) â‡’ BUTLASTN (1 :num) l = FRONT l``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). BIGUNION {s; t} = s âˆª t``, ``âˆ€(l2 :Î± list) (l1 :Î± list). Â¬NULL l2 â‡’ EL (LENGTH l1) (l1 ++ l2) = HD l2``, ``reflexive ((R1 :Î± -> Î± -> bool) LEX (R2 :Î² -> Î² -> bool)) â‡” reflexive R1 âˆ¨ reflexive R2``, ``INJ (f :Î± -> Î²) (s :Î± -> bool) (IMAGE f s) â‡’ (countable (IMAGE f s) â‡” countable s)``, ``MAP (f :Î² -> Î±) (LIST_BIND (l :Î³ list) (g :Î³ -> Î² list)) = LIST_BIND l (MAP f âˆ˜ g)``, ``FUNSET ð•Œ(:Î±) ð•Œ(:Î²) = ð•Œ(:Î± -> Î²)``, ``âˆ€(A :bool) (B :bool) (C :bool). A âˆ§ B â‡’ C â‡” A â‡’ B â‡’ C``, ``MAP (SND :Î² # Î± -> Î±) (FILTER (Î»((x :Î²),(y :Î±)). y â‰  (z :Î±)) (ls :(Î² # Î±) list)) = FILTER (Î»(y :Î±). z â‰  y) (MAP (SND :Î² # Î± -> Î±) ls)``, ``REPLICATE (n :num) (a :Î±) ++ REPLICATE (m :num) a = REPLICATE (n + m) a``, ``âˆ€(b :bool). Â¬b â‡’ (b â‡” F)``, ``âˆ€(x :Î±) (y :Î²) (a :Î±) (b :Î²). (x,y) = (a,b) â‡” x = a âˆ§ y = b``, ``âˆ€(f :Î± -> Î²) (n :num) (x :Î±). MAP f (REPLICATE n x) = REPLICATE n (f x)``, ``âˆ€(n :num) (l :Î± list). n < LENGTH l â‡’ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l``, ``PMATCH_ROW_COND_EX (i :Î±) (p :Î² -> Î±) (g :Î² -> bool) â‡’ PMATCH_ROW p g (r :Î² -> Î³) i = SOME (r (@(x :Î²). PMATCH_ROW_COND p g i x))``, ``âˆ€(R1 :Î± -> Î± -> bool) (R2 :Î± -> Î± -> bool) (x :Î±) (y :Î±). (R1 âˆ©áµ£ R2)ê™³ x y â‡’ (R1ê™³ âˆ©áµ£ R2ê™³) x y``, ``âˆ€(P :Î± -> bool) (a :Î±) (s :Î± -> bool). (âˆƒ(x :Î±). x âˆˆ a INSERT s âˆ§ P x) â‡” P a âˆ¨ âˆƒ(x :Î±). x âˆˆ s âˆ§ P x``, ``âˆ€(f :Î± -> Î³) (g :Î² -> Î´) (z :Î± + Î²). SUM_MAP f g z = if ISL z then (INL (f (OUTL z)) :Î³ + Î´) else (INR (g (OUTR z)) :Î³ + Î´)``, ``âˆ€(l :Î± list list). REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :Î± list -> Î± list) l))``, ``âˆ€(f1 :Î± -> Î²) (f2 :Î± -> Î²) (l :Î± list). MAP f1 l = MAP f2 l â‡” âˆ€(e :Î±). MEM e l â‡’ f1 e = f2 e``, ``($= :Î± -> Î± -> bool)áµ€ = ($= :Î± -> Î± -> bool)``, ``âˆ€(n :num) (l :Î± list). n < LENGTH l â‡’ ELL n (REVERSE l) = ELL (PRE (LENGTH l âˆ’ n)) l``, ``âˆ€(x :Î±) (s :Î± -> bool). (âˆ… :Î± -> bool) â‰  x INSERT s``, ``(Â¬SHORTLEX (R :Î± -> Î± -> bool) ([] :Î± list) ([] :Î± list) âˆ§ Â¬SHORTLEX R ((h1 :Î±)::(t1 :Î± list)) ([] :Î± list)) âˆ§ SHORTLEX R ([] :Î± list) ((h2 :Î±)::(t2 :Î± list)) âˆ§ (SHORTLEX R (h1::t1) (h2::t2) â‡” LENGTH t1 < LENGTH t2 âˆ¨ LENGTH t1 = LENGTH t2 âˆ§ (R h1 h2 âˆ¨ h1 = h2 âˆ§ SHORTLEX R t1 t2))``, ``(âˆ€(v :Î±). PMATCH_IS_EXHAUSTIVE v ([] :(Î± -> Î² option) list) â‡” F) âˆ§ âˆ€(v :Î³) (r :Î³ -> Î´ option) (rs :(Î³ -> Î´ option) list). PMATCH_IS_EXHAUSTIVE v (r::rs) â‡” r v â‰  (NONE :Î´ option) âˆ¨ PMATCH_IS_EXHAUSTIVE v rs``, ``(âˆ€(s :Î± -> bool). ð•Œ(:Î±) âˆ© s = s) âˆ§ âˆ€(s :Î± -> bool). s âˆ© ð•Œ(:Î±) = s``, ``âˆ€(f :Î± -> Î²) (s :Î± -> bool) (t :Î² -> bool). BIJ f s t â‡” f âˆˆ FUNSET s t âˆ§ âˆ€(y :Î²). y âˆˆ t â‡’ âˆƒ!(x :Î±). x âˆˆ s âˆ§ y = f x``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ BUTLASTN n l = TAKE (LENGTH l âˆ’ n) l``, ``âˆ€(l2 :Î± list) (l1 :Î± list). IS_SUFFIX (REVERSE l1) (REVERSE l2) â‡” l2 â‰¼ l1``, ``âˆ€(s :Î± -> bool) (x :Î±) (y :Î±). x âˆˆ s DELETE y â‡” x âˆˆ s âˆ§ x â‰  y``, ``âˆ€(ls :Î± list) (n :num). n â‰¤ LENGTH ls â‡’ REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls âˆ’ n) ls)``, ``âˆ€(f :Î± -> Î²). PREIMAGE f (âˆ… :Î² -> bool) = (âˆ… :Î± -> bool)``, ``âˆ€(f :Î± -> Î²) (l :Î± list). MAP f (REVERSE l) = REVERSE (MAP f l)``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (x :Î±). (s âˆª t) x â‡” x âˆˆ s âˆ¨ x âˆˆ t``, ``âˆ€(n :num). LENGTH (COUNT_LIST n) = n``, ``(âˆƒ(p :Î± # Î²). (P :Î± # Î² -> bool) p) â‡” âˆƒ(p_1 :Î±) (p_2 :Î²). P (p_1,p_2)``, ``âˆ€(l1 :Î± list) (l2 :Î± list). l1 ++ l2 = FOLDR (CONS :Î± -> Î± list -> Î± list) l2 l1``, ``âˆ€(s :Î± -> bool) (x :Î±). COMPL (x INSERT s) = COMPL s DELETE x``, ``âˆ€(t :bool). t â‡’ T â‡” T``, ``countable (âˆ… :Î± -> bool)``, ``âˆ€(R :Î± -> Î± -> bool). Order R â‡” StrongOrder (STRORD R)``, ``âˆ€(x :bool) (x' :bool) (y :bool) (y' :bool). (x â‡’ y â‡’ y') âˆ§ (Â¬y' â‡’ x' â‡’ x) â‡’ (x â‡’ y) â‡’ x' â‡’ y``, ``(x :Î± list) â‰¼ (y :Î±)::(ys :Î± list) â‡” x = ([] :Î± list) âˆ¨ âˆƒ(xs :Î± list). x = y::xs âˆ§ xs â‰¼ ys``, ``âˆ€(P :Î± -> bool) (l :Î± list) (m :num). EVERY P l â‡’ EVERY P (TAKE m l)``, ``IS_SOME (OPTION_BIND (x :Î± option) (g :Î± -> Î² option)) â‡’ IS_SOME x``, ``(âˆ€(x :Î±) (y :Î±). (R :Î± -> Î± -> bool) x y â‡’ (Q :Î± -> Î± -> bool) x y) â‡’ Rê™³ (x :Î±) (y :Î±) â‡’ Qê™³ x y``, ``âˆ€(x :Î± list). x â‰¼ x``, ``count (0 :num) = (âˆ… :num -> bool)``, ``(âˆ€(x :Î±). (P :Î± -> bool) x â‡’ (Q :Î± -> bool) x) â‡’ EXISTS P (l :Î± list) â‡’ EXISTS Q l``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). s âŠ† t â‡’ s âˆ© t = s``, ``âˆ€(R :Î± -> Î± -> bool) (x :Î±) (y :Î±). R x y â‡’ Râº x y``, ``âˆ€(xs :Î± list). FILTER (Î»(x :Î±). T) xs = xs``, ``âˆ€(s :Î± -> bool). (Î»(x :Î±). x) PERMUTES s``, ``âˆ€(l1 :Î± list) (n :num). LENGTH l1 â‰¤ n â‡’ âˆ€(l2 :Î± list). TAKE n (l1 ++ l2) = l1 ++ TAKE (n âˆ’ LENGTH l1) l2``, ``âˆ€(s :Î± -> bool). INFINITE s â‡’ âˆ€(t :Î± -> bool). s âŠ† t â‡’ INFINITE t``, ``(option_CASE (NONE :Î± option) :Î² -> (Î± -> Î²) -> Î²) = (Î»(v :Î²) (f :Î± -> Î²). v) âˆ§ (option_CASE (SOME (x :Î±)) :Î² -> (Î± -> Î²) -> Î²) = (Î»(v :Î²) (f :Î± -> Î²). f x)``, ``âˆ€(t :bool). t â‡’ F â‡” Â¬t``, ``âˆ€(f1 :Î± -> bool) (f2 :Î± -> bool) (l :Î± list). FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)``, ``âˆ€(f :Î± -> Î²) (P :Î± -> bool) (Q :Î² -> bool). FUNSET P Q f â‡” âˆ€(x :Î±). x âˆˆ P â‡’ f x âˆˆ Q``, ``ð•Œ(:Î± + Î²) = IMAGE (INL :Î± -> Î± + Î²) ð•Œ(:Î±) âˆª IMAGE (INR :Î² -> Î± + Î²) ð•Œ(:Î²)``, ``âˆ€(x :Î±) (s :Î± -> bool). s âŠ† x INSERT s``, ``âˆ€(l :Î± list) (x :Î±). l â‰  x::l âˆ§ x::l â‰  l``, ``PROD_SET (âˆ… :num -> bool) = (1 :num) âˆ§ âˆ€(x :num) (s :num -> bool). FINITE s â‡’ PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)``, ``âˆ€(f :Î± -> Î²) (s :Î² -> bool) (x :Î±). PREIMAGE f s x â‡” f x âˆˆ s``, ``âˆ€(f :Î± -> Î² -> Î²) (e :Î²) (l1 :Î± list) (l2 :Î± list). FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ DROP n l = LASTN (LENGTH l âˆ’ n) l``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ LENGTH (TAKE n l) = n``, ``(0 :num) < (n :num) â‡’ DROP n ((x :Î±)::(xs :Î± list)) = DROP (n âˆ’ (1 :num)) xs``, ``âˆ€(l :bool list). AND_EL l â‡” FOLDL $/\\ T l``, ``âˆ€(P :Î± -> bool) (l :Î± list). FILTER P l = ([] :Î± list) â‡” EVERY (Î»(x :Î±). Â¬P x) l``, ``âˆ€(v :Î±) (rows :(Î± -> Î² option) list) (p :bool) (infos :bool list). FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) â‡” p âˆ§ EVERY (Î»(r :Î± -> Î² option). r v = (NONE :Î² option)) rows``, ``âˆ€(s :Î± -> bool). s âˆ© s = s``, ``âˆ€(x :Î± -> bool) (y :Î± -> bool) (z :Î± -> bool). x DIFF y DIFF z = x DIFF z DIFF y``, ``âˆ€(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool). (c â‡’ x' â‡’ x) âˆ§ (Â¬c â‡’ y' â‡’ y) â‡’ (if c then x' else y') â‡’ if c then x else y``, ``âˆ€(x :Î±). SING {x}``, ``((a :Î±),(b :Î±)) âˆˆ {(x,x) | (P :Î± -> bool) x} â‡” P a âˆ§ a = b``, ``âˆ€(M :Î± list) (M' :Î± list) (v :Î²) (f :Î± -> Î± list -> Î²). M = M' âˆ§ (M' = ([] :Î± list) â‡’ v = (v' :Î²)) âˆ§ (âˆ€(a0 :Î±) (a1 :Î± list). M' = a0::a1 â‡’ f a0 a1 = (f' :Î± -> Î± list -> Î²) a0 a1) â‡’ (list_CASE M v f :Î²) = (list_CASE M' v' f' :Î²)``, ``âˆ€(x :Î±) (l :Î± list). SNOC x l â‰  ([] :Î± list)``, ``âˆ€(g :Î± -> Î± -> Î±) (f :Î² -> Î± -> Î±). FCOMM g f â‡’ âˆ€(e :Î±). LEFT_ID g e â‡’ âˆ€(l :Î² list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)``, ``âˆ€(m :num) (n :num). m < SUC n â‡’ m â‰  n â‡’ m < n``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (u :Î± -> bool). s âŠ‚ t âˆ§ t âŠ‚ u â‡’ s âŠ‚ u``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). FINITE s âˆ§ FINITE t â‡’ CARD (s âˆª t) = CARD s + CARD t âˆ’ CARD (s âˆ© t)``, ``âˆ€(s :Î± -> bool). ð•Œ(:Î±) âŠ† s â‡” s = ð•Œ(:Î±)``, ``âˆ€(v :Î±) (rows :(Î± -> Î² option) list) (p :bool) (infos :bool list). LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) = LENGTH rows + LENGTH infos``, ``LIST_REL (R :Î± -> Î² -> bool) (xs :Î± list) ((h :Î²)::(t :Î² list)) â‡” âˆƒ(h' :Î±) (t' :Î± list). xs = h'::t' âˆ§ R h' h âˆ§ LIST_REL R t' t``, ``(âˆ€(x :Î±) (y :Î±). (P :Î± -> bool) x âˆ§ (R :Î± -> Î± -> bool) x y â‡’ P y) â‡’ âˆ€(x :Î±) (y :Î±). P x âˆ§ Rê™³ x y â‡’ P y``, ``((p :bool) â‡” if (q :bool) then (r :bool) else (s :bool)) â‡” (p âˆ¨ q âˆ¨ Â¬s) âˆ§ (p âˆ¨ Â¬r âˆ¨ Â¬q) âˆ§ (p âˆ¨ Â¬r âˆ¨ Â¬s) âˆ§ (Â¬q âˆ¨ r âˆ¨ Â¬p) âˆ§ (q âˆ¨ s âˆ¨ Â¬p)``, ``âˆ€(s :Î± -> bool) (x :Î±). x âˆˆ s â‡” âˆƒ(t :Î± -> bool). s = x INSERT t âˆ§ x âˆ‰ t``, ``PMATCH_ROW_REDUNDANT (v :Î±) ((r :Î± -> Î² option)::(rs :(Î± -> Î² option) list)) (0 :num) â‡” r v = (NONE :Î² option)``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). DISJOINT t (s DIFF t) âˆ§ DISJOINT (s DIFF t) t``, ``âˆ€(f :Î± -> Î² -> bool) (s :Î± -> bool) (y :Î²). y âˆˆ BIGUNION (IMAGE f s) â‡” âˆƒ(x :Î±). x âˆˆ s âˆ§ y âˆˆ f x``, ``(âˆ€(e :Î±). LIST_ELEM_COUNT e ([] :Î± list) = (0 :num)) âˆ§ (âˆ€(e :Î²) (l1 :Î² list) (l2 :Î² list). LIST_ELEM_COUNT e (l1 ++ l2) = LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) âˆ§ (âˆ€(e :Î³) (h :Î³) (l :Î³ list). h = e â‡’ LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) âˆ§ âˆ€(e :Î´) (h :Î´) (l :Î´ list). h â‰  e â‡’ LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (x :Î±). (s âˆ© t) x â‡” x âˆˆ s âˆ§ x âˆˆ t``, ``âˆ€(P :Î± -> bool) (l1 :Î± list) (l2 :Î± list). EXISTS P (l1 ++ l2) â‡” EXISTS P l1 âˆ¨ EXISTS P l2``, ``âˆ€(ls :Î± list) (f :Î± # Î± -> Î²). MAP f (ZIP (ls,ls)) = MAP (Î»(x :Î±). f (x,x)) ls``, ``MAP (f :Î± -> Î²) (l :Î± list) = (h :Î²)::(t :Î² list) â‡” âˆƒ(x0 :Î±) (t0 :Î± list). l = x0::t0 âˆ§ h = f x0 âˆ§ t = MAP f t0``, ``âˆ€(R :Î± -> Î± -> bool). symmetric R â‡’ SC R = R``, ``âˆ€(l1 :Î± list) (l2 :Î± list). SHORTLEX (R :Î± -> Î± -> bool) l1 l2 â‡’ LENGTH l1 â‰¤ LENGTH l2``, ``âˆ€(f :Î² -> Î± -> Î²) (e :Î²) (x :Î±) (l :Î± list). FOLDL f e (SNOC x l) = f (FOLDL f e l) x``, ``âˆ€(P :(Î± -> bool) -> bool). P (âˆ… :Î± -> bool) âˆ§ (âˆ€(s :Î± -> bool). FINITE s âˆ§ P s â‡’ âˆ€(e :Î±). e âˆ‰ s â‡’ P (e INSERT s)) â‡’ âˆ€(s :Î± -> bool). FINITE s â‡’ P s``, ``âˆ€(s :Î± -> bool). FINITE s â‡’ FINITE (REST s)``, ``âˆ€(s :Î± -> bool). FINITE s â‡’ âˆƒ(f :num -> Î±) (b :num). BIJ f (count b) s``, ``âˆ€(P :Î± -> bool) (l1 :Î± list) (l2 :Î± list). EVERY P l1 â‡’ dropWhile P (l1 ++ l2) = dropWhile P l2``, ``(OPTION_IGNORE_BIND (m1 :Î± option) (m2 :Î² option) = (NONE :Î² option) â‡” m1 = (NONE :Î± option) âˆ¨ m2 = (NONE :Î² option)) âˆ§ (OPTION_IGNORE_BIND m1 m2 = SOME (y :Î²) â‡” âˆƒ(x :Î±). m1 = SOME x âˆ§ m2 = SOME y)``, ``âˆ€(P :Î± -> bool) (l :Î± list). EVERY P l â‡” Â¬EXISTS (Î»(x :Î±). Â¬P x) l``, ``âˆ€(s :Î± -> bool). s = ð•Œ(:Î±) â‡’ âˆ€(v :Î±). v âˆˆ s``, ``âˆ€(n :num). SUC (m :num) = n â‡’ m < n``, ``((if (P :bool) then SOME (x :Î±) else (NONE :Î± option)) = (NONE :Î± option) â‡” Â¬P) âˆ§ ((if P then (NONE :Î± option) else SOME x) = (NONE :Î± option) â‡” P) âˆ§ ((if P then SOME x else (NONE :Î± option)) = SOME (y :Î±) â‡” P âˆ§ x = y) âˆ§ ((if P then (NONE :Î± option) else SOME x) = SOME y â‡” Â¬P âˆ§ x = y)``, ``(some(x :bool). x) = SOME T``, ``REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) âˆ§ REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list)) ((i2 :bool)::(is2 :bool list)) = (i1 âˆ§ i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2``, ``âˆ€(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)``, ``âˆ€(x :Î± recspace) (y :Î± recspace). dest_rec x = dest_rec y â‡” x = y``, ``((R1 :Î± -> Î± -> bool) LEX (R2 :Î² -> Î² -> bool)) ((a :Î±),(b :Î²)) ((c :Î±),(d :Î²)) â‡” R1 a c âˆ¨ a = c âˆ§ R2 b d``, ``(âˆ€(l :Î± list). ([] :Î± list) â‰¼ l â‡” T) âˆ§ (âˆ€(x :Î±) (l :Î± list). x::l â‰¼ ([] :Î± list) â‡” F) âˆ§ âˆ€(x1 :Î±) (l1 :Î± list) (x2 :Î±) (l2 :Î± list). x2::l2 â‰¼ x1::l1 â‡” x1 = x2 âˆ§ l2 â‰¼ l1``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ DROP n (REVERSE l) = REVERSE (BUTLASTN n l)``, ``âˆ€(l :Î± list) (f :Î± -> Î²) (x :Î²). MEM x (MAP f l) â‡” âˆƒ(y :Î±). x = f y âˆ§ MEM y l``, ``âˆ€(f :Î± -> Î²) (s :Î² -> bool) (t :Î² -> bool). s âŠ† t â‡’ PREIMAGE f s âŠ† PREIMAGE f t``, ``PROD_ALL (P :Î± -> bool) (Q :Î² -> bool) ((x :Î±),(y :Î²)) â‡” P x âˆ§ Q y``, ``âˆ€(R :Î± -> Î± -> bool) (x :Î±) (y :Î±). Râº x y â‡’ Rê™³ x y``, ``âˆ€(l2 :Î± list) (l1 :Î± list). BUTLASTN (LENGTH l2) (l1 ++ l2) = l1``, ``âˆ€(l :Î± list). LENGTH l = FOLDR (Î»(x :Î±) (l' :num). SUC l') (0 :num) l``, ``âˆ€(n :num) (l :Î± list). n â‰¤ LENGTH l â‡’ LASTN n l = DROP (LENGTH l âˆ’ n) l``, ``âˆ€(t :bool). F âˆ¨ t â‡” t``, ``âˆ€(f :Î± -> Î²) (s :Î² -> bool). IMAGE f (PREIMAGE f s) âŠ† s``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool). s âŠ‚ t â‡” s âŠ† t âˆ§ âˆƒ(y :Î±). y âˆˆ t âˆ§ y âˆ‰ s``, ``(R :Î± -> Î± -> bool)âº (x :Î±) (z :Î±) â‡” R x z âˆ¨ âˆƒ(y :Î±). R x y âˆ§ Râº y z``, ``âˆ€(m :num) (n :num) (l :Î± list). m â‰¤ n âˆ§ n â‰¤ LENGTH l â‡’ BUTLASTN m (LASTN n l) = LASTN (n âˆ’ m) (BUTLASTN m l)``, ``âˆ€(f :Î± -> Î²) (P :Î± -> bool) (Q :Î± -> Î² -> bool). f âˆˆ DFUNSET P Q â‡” âˆ€(x :Î±). x âˆˆ P â‡’ f x âˆˆ Q x``, ``(âˆ€(x :Î±). MEM x ([] :Î± list) â‡” F) âˆ§ âˆ€(x :Î±) (h :Î±) (t :Î± list). MEM x (h::t) â‡” x = h âˆ¨ MEM x t``, ``âˆ€(x :Î±) (s :Î± -> bool). x âˆ‰ s â‡” s DELETE x = s``, ``((INL (a :Î±) :Î± + Î²) âˆˆ (A :Î± -> bool) âŠ” (B :Î² -> bool) â‡” a âˆˆ A) âˆ§ ((INR (b :Î²) :Î± + Î²) âˆˆ A âŠ” B â‡” b âˆˆ B)``, ``WF (Î»(x :num) (y :num). y = SUC x)``, ``âˆ€(L :num list) (n :num). SUM_ACC L n = SUM L + n``, ``INFINITE ð•Œ(:Î±) â‡” âˆ€(s :Î± -> bool). FINITE s â‡’ s âŠ‚ ð•Œ(:Î±)``, ``âˆ€(ls :Î± list list). FLAT ls = ([] :Î± list) â‡” EVERY ($= ([] :Î± list)) ls``, ``âˆ€(f :Î± -> Î²). (âˆ€(s :Î² -> bool). INJ f (âˆ… :Î± -> bool) s) âˆ§ âˆ€(s :Î± -> bool). INJ f s (âˆ… :Î² -> bool) â‡” s = (âˆ… :Î± -> bool)``, ``âˆ€(l :Î± list) (f :Î± -> Î²). (MAP f l = ([] :Î² list) â‡” l = ([] :Î± list)) âˆ§ (([] :Î² list) = MAP f l â‡” l = ([] :Î± list))``, ``âˆ€(l :num list). SUM l = FOLDR $+ (0 :num) l``, ``âˆ€(R :Î± -> Î² -> bool) (l1 :Î± list) (l2 :Î² list) (n :num). LIST_REL R l1 l2 â‡’ LIST_REL R (DROP n l1) (DROP n l2)``, ``(some(x :Î±). F) = (NONE :Î± option)``, ``âˆ€(f :Î± -> Î²) (l1 :Î± list) (l2 :Î± list). MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2``, ``âˆ€(g :Î± -> Î± -> Î±) (f :Î² -> Î± -> Î±). FCOMM g f â‡’ âˆ€(e :Î±). LEFT_ID g e â‡’ âˆ€(l1 :Î² list) (l2 :Î² list). FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)``, ``âˆ… (x :Î±) â‡” F``, ``âˆ€(R :Î± -> Î± -> bool). WeakLinearOrder R â‡” WeakOrder R âˆ§ âˆ€(a :Î±) (b :Î±). R a b âˆ¨ R b a``, ``âˆ€(R :Î± -> Î² -> bool) (R' :Î³ -> Î± -> bool). (R âˆ˜áµ£ R')áµ€ = R'áµ€ âˆ˜áµ£ Ráµ€``, ``âˆ€(x :Î±) (l :Î± list). x::l = [x] ++ l``, ``âˆ€(f :Î± -> Î²) (l :Î± list). MAP f l = FOLDR (Î»(x :Î±) (l' :Î² list). f x::l') ([] :Î² list) l``, ``âˆ€(x :Î±). x âˆˆ ð•Œ(:Î±)``, ``ð•Œ(:Î± + Î²) = ð•Œ(:Î±) âŠ” ð•Œ(:Î²)``, ``âˆ€(s :Î± -> bool) (t :Î± -> bool) (g :Î± -> bool). (s DIFF t) âˆ© g = s âˆ© g DIFF t``, ``âˆ€(Q :num -> bool) (P :num -> bool). (âˆƒ(n :num). P n) âˆ§ (âˆ€(n :num). (âˆ€(m :num). m < n â‡’ Â¬P m) âˆ§ P n â‡’ Q n) â‡’ Q ($LEAST P)``, ``âˆ€(xs :Î± list). FILTER (Î»(x :Î±). F) xs = ([] :Î± list)``, ``âˆ€(f :Î± -> Î²) (x :Î±) (s :Î± -> bool). IMAGE f (x INSERT s) = f x INSERT IMAGE f s``, ``âˆ€(l1 :Î± list) (l2 :Î± list). TAKE (LENGTH l1) (l1 ++ l2) = l1``, ``âˆ€(l :Î± list list). FLAT l = FOLDR ($++ :Î± list -> Î± list -> Î± list) ([] :Î± list) l``, ``(Â¬LLEX (R :Î± -> Î± -> bool) ([] :Î± list) ([] :Î± list) âˆ§ Â¬LLEX R ((h1 :Î±)::(t1 :Î± list)) ([] :Î± list)) âˆ§ LLEX R ([] :Î± list) ((h2 :Î±)::(t2 :Î± list)) âˆ§ (LLEX R (h1::t1) (h2::t2) â‡” R h1 h2 âˆ¨ h1 = h2 âˆ§ LLEX R t1 t2)``, ``âˆ€(l :Î± list). l ++ ([] :Î± list) = l``, ``âˆ€(s :Î± -> bool) (f :Î± -> Î²). f âˆˆ FUNSET s (âˆ… :Î² -> bool) â‡” s = (âˆ… :Î± -> bool)``, ``âˆ€(b :bool). b â‡’ (b â‡” T)``, ``âˆ€(l :Î± list) (x :Î±). ELL (0 :num) (SNOC x l) = x``, ``âˆ€(ls :Î± list). ls â‰  ([] :Î± list) â‡’ MAP (f :Î± -> Î²) (FRONT ls) = FRONT (MAP f ls)``, ``âˆ€(n :num). (0 :num) < SUC n``, ``IMAGE (f :Î² -> Î±) (s :Î² -> bool) = {(z :Î±)} â‡” s â‰  (âˆ… :Î² -> bool) âˆ§ âˆ€(x :Î²). x âˆˆ s â‡’ f x = z``, ``âˆ€(f :Î± -> Î² -> Î²) (e :Î²) (l :Î± list). FOLDR f e l = FOLDL (Î»(x :Î²) (y :Î±). f y x) e (REVERSE l)``, ``âˆ€(l1 :Î± list) (l2 :Î± list) (a :Î±). IS_SUFFIX l1 l2 â‡’ IS_SUFFIX (a::l1) l2``, ``âˆ€(x :Î±) (P :Î± -> bool). x âˆˆ P â‡” P x``, ``âˆ€(R :Î± -> Î± -> bool). StrongOrder R â‡’ Order R``, ``âˆ€(n :num) (l :Î± list). n < LENGTH l â‡’ MEM (EL n l) l``, ``âˆ€(x :Î±) (y :Î±) (P :Î± -> bool). x âˆˆ y INSERT P â‡” x = y âˆ¨ x â‰  y âˆ§ x âˆˆ P``, ``OWHILE (G :Î± -> bool) (f :Î± -> Î±) (s :Î±) = SOME (s' :Î±) â‡’ Â¬G s``, ``symmetric (R1 :Î± -> Î± -> bool) âˆ§ symmetric (R2 :Î² -> Î² -> bool) â‡’ symmetric (R1 LEX R2)``, ``âˆ€(P :Î± -> bool) (l :Î± list). PREFIX P l â‰¼ l``, ``âˆ€(s :Î± -> bool) (f :Î± -> Î²). (âˆƒ(t :Î² -> bool). INJ f s t) â‡’ BIJ f s (IMAGE f s)``, ``âˆ€(s :Î± -> bool). s DIFF ð•Œ(:Î±) = (âˆ… :Î± -> bool)``, ``âˆ€(t :bool). t âˆ§ t â‡” t``, ``(âˆƒ(x :Î±). x âˆˆ (s :Î± -> bool)) âˆ§ (âˆ€(x :Î±). x âˆˆ s â‡’ (P :Î± -> bool) x) â‡’ P (CHOICE s)``]

fun run_hammer data =
    case data of
        [] => holyhammer â€œÂ¬T â‡” Fâ€
      | hd :: tl => 
let 
val v = holyhammer hd 
handle HOL_ERR msg =>
	    (* print "proof failed.\n" *)
let val _ = print "proof failed.\n" in
	    holyhammer â€œÂ¬T â‡” Fâ€
 end
in
run_hammer tl
end

fun run_hammer2 data =
    case data of
        [] => hh_pb [Vampire] [] ([], ``Â¬T â‡” F``)
      | hd :: tl => 
let 
val v = holyhammer hd 
handle HOL_ERR msg =>
	    (* print "proof failed.\n" *)
let val _ = print "proof failed.\n" in
	    holyhammer â€œÂ¬T â‡” Fâ€
 end
in
run_hammer tl
end

(* fun run_hammer data = *)
(*     case data of *)
(*         [] => holyhammer â€œÂ¬T â‡” Fâ€ *)
(*       | hd :: tl => holyhammer hd  *)
(* handle HOL_ERR msg => *)
(* 	    (* print "proof failed.\n" *) *)
(* let val _ = print "proof failed.\n" in *)
(* 	    run_hammer tl *)
(*  end *)

	(* let *)
	(*     val b = holyhammer hd handle HOL_ERR msg => *)
	(* let *)
	(*     val b = holyhammer hd in *)
	(*     print "proof failed.\n"; *)
	(*     run_hammer tl *)
	(* end *)
 
	(* in *)
	(*     run_hammer tl *)
	(* end *)


