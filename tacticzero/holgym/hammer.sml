load "holyHammer"; 
open holyHammer;

(* hh_pb [Vampire] ["arithmeticTheory.ADD_CLAUSES"] ([],``a <= b ==> (g ** (b - a) * g ** a = g ** b)``); *)

(* val l = [``(∀(x :α). (P :α -> bool) x ⇒ (Q :α option -> bool) (SOME x)) ∧ ((∀(x :α). ¬P x) ⇒ Q (NONE :α option)) ⇒ Q ($some P)``, ``∀(c :bool) (x :bool). (if c then T else x) ⇔ ¬c ⇒ x``, ``∀(R :α -> α -> bool). irreflexive Rᵀ ⇔ irreflexive R``, ``∀(v :α) (rs :(α -> β option) list). (EVERY (λ(r :α -> β option). r v = (NONE :β option)) rs ⇒ F) ⇒ PMATCH_IS_EXHAUSTIVE v rs``, ``∀(b :bool). ¬b ⇒ (b ⇔ F)``, ``∀(x :α option). IS_NONE x ⇔ x = (NONE :α option)``, ``∀(v :α) (rows :(α -> β option) list) (i :num). i < LENGTH rows ⇒ (EL i (STRONGEST_REDUNDANT_ROWS_INFO v rows) ⇔ EVERY (λ(r :α -> β option). r v = (NONE :β option)) (TAKE i rows) ⇒ EL i rows v = (NONE :β option))``, ``INVOL (relinv :(α -> α -> bool) -> α -> α -> bool)``, ``∀(m :num) (n :num). m < n ⇒ SUC m < SUC n``, ``(R :α -> α -> bool)꙳ (x :α) x``, ``∀(t :bool). T ⇒ t ⇔ t``, ``(n :num) ≤ tri n``, ``∀(x :α) (y :α). (R :α -> α -> bool)꙳ x y ⇒ R^= x y``, ``∀(R :α -> β -> bool). Rᵀ ᵀ = R``, ``∀(f1 :num -> α -> bool) (f1 :num -> α -> bool) (f2 :num -> α -> bool) (f2 :num -> α -> bool). ind_type$INJP f1 f2 = ind_type$INJP f1 f2 ⇔ f1 = f1 ∧ f2 = f2``, ``IS_SOME (OPTION_MAP (f :α -> β) (x :α option)) ⇔ IS_SOME x``, ``∀(R :α -> α -> bool). symmetric (SC R)``, ``(∅ᵣ :α -> α -> bool) ⊆ᵣ (R :α -> α -> bool) ∧ (R ⊆ᵣ (∅ᵣ :α -> α -> bool) ⇔ R = (∅ᵣ :α -> α -> bool))``, ``∀(t :bool). t ∧ T ⇔ t``, ``∀(R :α -> α -> bool) (P :α -> α -> bool). (∀(x :α). P x x) ∧ (∀(x :α) (y :α) (z :α). P x y ∧ R y z ⇒ P x z) ⇒ ∀(x :α) (y :α). R꙳ x y ⇒ P x y``, ``∀(p :α # β) (f :α -> γ) (g :β -> δ). SND ((f ## g) p) = g (SND p)``, ``(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ R ((f :α -> α) x) (f y)) ⇒ ∀(x :α) (y :α). SC R x y ⇒ SC R (f x) (f y)``, ``(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ R ((f :α -> α) x) (f y)) ⇒ ∀(x :α) (y :α). R꙳ x y ⇒ R꙳ (f x) (f y)``, ``¬((p :bool) ⇒ (q :bool)) ⇒ p``, ``(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ (Q :α -> α -> bool) x y) ⇒ RC R (x :α) (y :α) ⇒ RC Q x y``, ``transitive (R :α -> α -> bool) ⇔ R ∘ᵣ R ⊆ᵣ R``, ``∀(R :α -> α -> bool). transitive Rᵀ ⇔ transitive R``, ``∀(P :α -> bool) (v :β) (rows :(β -> α option) list). P (PMATCH v rows) ⇔ PMATCH_EXPAND_PRED P v ([] :(β -> α option) list) rows``] *)

(* val l1 = [``∀(m :num) (n :num). m ≤ n ⊗ m``, ``∀(R :α -> α -> bool). (∀(P :α -> bool). (∀(x :α). (∀(y :α). R y x ⇒ P y) ⇒ P x) ⇒ ∀(x :α). P x) ⇒ WF R``, ``symmetric (R1 :α -> α -> bool) ∧ symmetric (R2 :β -> β -> bool) ⇒ symmetric (R1 LEX R2)``, ``IDEM (RTC :(α -> α -> bool) -> α -> α -> bool)``, ``PMATCH_ROW_COND_NOT_EX_OR_EQ (i :α) (r :α -> β option) ([] :(α -> β option) list) ⇔ r i ≠ (NONE :β option) ⇒ F``, ``PMATCH_ROW_COND (pat :α -> β) (guard :α -> bool) (inp :β) (v :α) ⇔ inp = pat v ∧ guard v``, ``¬T ⇔ F``, ``OPTION_MAP (f :α -> β) (x :α option) = (option_CASE x (NONE :β option) ((SOME :β -> β option) ∘ f) :β option)``, ``(some(x :α). F) = (NONE :α option)``, ``(y :α) ∈ RRANGE (R :β -> α -> bool) ⇔ ∃(x :β). R x y``, ``∀(P :α + β -> bool). (∃(s :α + β). P s) ⇔ (∃(x :α). P (INL x :α + β)) ∨ ∃(y :β). P (INR y :α + β)``, ``PMATCH (v :β) (rows :(β -> α option) list) = PMATCH v (SNOC (PMATCH_ROW (λ(_0 :β). _0) (λ(_0 :β). T) (λ(_0 :β). (ARB :α))) rows)``, ``trichotomous (STRORD (R :α -> α -> bool)) ⇔ trichotomous R``, ``(R :α -> β -> bool) ∘ᵣ ($= :α -> α -> bool) = R``, ``∀(R :α -> α -> bool). equivalence R ⇒ Rᵀ = R``, ``(OPTION_BIND (p :α option) (f :α -> β option) = (NONE :β option) ⇔ p = (NONE :α option) ∨ ∃(x :α). p = SOME x ∧ f x = (NONE :β option)) ∧ (OPTION_BIND p f = SOME (y :β) ⇔ ∃(x :α). p = SOME x ∧ f x = SOME y)``, ``DATATYPE ((pair :(α -> β -> α # β) -> γ) ($, :α -> β -> α # β))``, ``∀(n :num). ¬(n < (0 :num))``, ``(option_CASE (x :α option) (e :β) (f :α -> β) :β) = if IS_SOME x then f (THE x) else e``, ``∀(v :α) (p :β -> α) (g :β -> bool) (p :γ -> α) (g :γ -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g ⇒ (∀(x :β). g x ⇒ ((∃(x :γ). p x = p x ∧ g x) ⇔ RES)) ⇒ (PMATCH_ROW_COND_EX v p g ⇔ RES)``, ``¬((A :bool) ∨ (B :bool)) ⇒ F ⇔ ¬A ⇒ ¬B ⇒ F``, ``((if (P :bool) then SOME (x :α) else (NONE :α option)) = (NONE :α option) ⇔ ¬P) ∧ ((if P then (NONE :α option) else SOME x) = (NONE :α option) ⇔ P) ∧ ((if P then SOME x else (NONE :α option)) = SOME (y :α) ⇔ P ∧ x = y) ∧ ((if P then (NONE :α option) else SOME x) = SOME y ⇔ ¬P ∧ x = y)``, ``∀(m :num) (n :num). SUC m = SUC n ⇔ m = n``, ``∀(n :num). SUC (m :num) = n ⇒ m < n``, ``Order (R :α -> α -> bool) ⇔ WeakOrder (RC R)``, ``∀(t :bool). F ⇒ t ⇔ T``, ``PMATCH_ROW_REDUNDANT (v :α) ((r :α -> β option)::(rs :(α -> β option) list)) (0 :num) ⇔ r v = (NONE :β option)``, ``PMATCH_ROW (p :β -> γ) (g :β -> bool) (r :β -> α) (i :γ) ≠ (NONE :α option) ⇔ PMATCH_ROW_COND_EX i p g``, ``WF (R :α -> α -> bool) ⇒ irreflexive R``, ``(antisymmetric (R1 :α -> α -> bool) ⇒ antisymmetric (R1 ∩ᵣ (R2 :α -> α -> bool))) ∧ (antisymmetric R2 ⇒ antisymmetric (R1 ∩ᵣ R2))``, ``∀(M :α + β) (M :α + β) (f :α -> γ) (f1 :β -> γ). M = M ∧ (∀(x :α). M = (INL x :α + β) ⇒ f x = (f :α -> γ) x) ∧ (∀(y :β). M = (INR y :α + β) ⇒ f1 y = (f1 :β -> γ) y) ⇒ (sum_CASE M f f1 :γ) = (sum_CASE M f f1 :γ)``, ``∀(R :α -> α -> bool) (x :α) (y :α). R꙳ x y ⇔ x = y ∨ R⁺ x y``, ``∀(R :α -> α -> bool). (∀(x :α). R꙳ x x) ∧ ∀(x :α) (y :α) (z :α). R x y ∧ R꙳ y z ⇒ R꙳ x z``, ``∀(P :α -> β -> bool). (∃(x :α) (y :β). P x y) ⇔ ∃((x :α),(y :β)). P x y``, ``OWHILE (G :α -> bool) (f :α -> α) (s :α) = (NONE :α option) ⇔ ∀(n :num). G (FUNPOW f n s)``] *)

(* val l2 = [``∀(t :bool). t ⇒ T ⇔ T``, ``(x :α) ∈ RDOM ((R1 :α -> β -> bool) ∪ᵣ (R2 :α -> β -> bool)) ⇔ x ∈ RDOM R1 ∨ x ∈ RDOM R2``, ``∀(a1 :α) (a2 :α). ind_type$INJA a1 = ind_type$INJA a2 ⇔ a1 = a2``, ``∀(Q :num -> bool) (P :num -> bool). (∃(n :num). P n) ∧ (∀(n :num). (∀(m :num). m < n ⇒ ¬P m) ∧ P n ⇒ Q n) ⇒ Q ($LEAST P)``, ``∀(ss :α + β). (∃(x :α). ss = (INL x :α + β)) ∨ ∃(y :β). ss = (INR y :α + β)``, ``∀(f :α # β -> γ). UNCURRY (CURRY f) = f``, ``∀(x :α + β). ISL x ∨ ISR x``, ``∀(R :α -> α -> bool) (RTC :α -> α -> bool). (∀(x :α). RTC x x) ∧ (∀(x :α) (y :α) (z :α). R x y ∧ RTC y z ⇒ RTC x z) ⇒ ∀(a0 :α) (a1 :α). R꙳ a0 a1 ⇒ RTC a0 a1``, ``∀(R :α -> α -> bool). StrongOrder R ⇒ Order R``, ``∀(R :α -> α -> bool). transitive R꙳``, ``IDEM (STRORD :(α -> α -> bool) -> α -> α -> bool)``, ``∀(p :α -> β) (g :α -> bool) (r :α -> γ) (v :β) (rows :(β -> γ option) list). (∀(x :α). r x = (ARB :γ)) ⇒ PMATCH v (SNOC (PMATCH_ROW p g r) rows) = PMATCH v rows``, ``(∀(x :α) (y :β). (P :α -> β -> bool) x y ⇒ (Q :α -> β -> bool) x y) ⇒ OPTREL P (x :α option) (y :β option) ⇒ OPTREL Q x y``, ``total (R1 :α -> α -> bool) ∧ total (R2 :β -> β -> bool) ⇒ total (R1 LEX R2)``, ``∀(R :α -> α -> bool). symmetric R ⇒ SC R = R``, ``OPTION_MAP2 (f :α -> β -> γ) (o1 :α option) (o2 :β option) = SOME (v :γ) ⇔ ∃(x1 :α) (x2 :β). o1 = SOME x1 ∧ o2 = SOME x2 ∧ v = f x1 x2``, ``∀(x :α option option) (y :α). OPTION_JOIN x = SOME y ⇔ x = SOME (SOME y)``, ``∀(R :α -> α -> bool). equivalence R ⇔ ∀(x :α) (y :α). R x y ⇔ R x = R y``, ``∀(f :α -> β) (R :α -> α -> bool) (D :α -> bool) (P :α -> β -> bool) (M :(α -> β) -> α -> β) (x :α). f = WFREC R M ∧ WF R ∧ INDUCTIVE_INVARIANT_ON R D P M ∧ D x ⇒ P x (f x)``, ``IDEM (RC :(α -> α -> bool) -> α -> α -> bool)``, ``∀(x :α) (y :β). FST (x,y) = x``, ``(∀(x :α) (y :α). (P :α -> bool) x ∧ (R :α -> α -> bool) x y ⇒ P y) ⇒ ∀(x :α) (y :α). P x ∧ R꙳ x y ⇒ P y``, ``∀(opt1 :α option) (opt2 :α option) (f1 :α -> β) (f2 :α -> β). opt1 = opt2 ∧ (∀(x :α). opt2 = SOME x ⇒ f1 x = f2 x) ⇒ OPTION_MAP f1 opt1 = OPTION_MAP f2 opt2``, ``∀(f :α -> β) (g :γ -> δ) (x :α) (y :γ). (f ## g) (x,y) = (f x,g y)``, ``∀(t :bool). t ∨ t ⇔ t``, ``(∀(x :α) (y :α). (R1 :α -> α -> bool) x y ⇒ (R2 :α -> α -> bool) x y) ∧ (∀(x :β) (y :β). (R3 :β -> β -> bool) x y ⇒ (R4 :β -> β -> bool) x y) ⇒ (R1 LEX R3) (x :α # β) (y :α # β) ⇒ (R2 LEX R4) x y``, ``PMATCH_ROW_COND_EX (i :α) (p :β -> α) (g :β -> bool) ⇒ PMATCH_ROW p g (r :β -> γ) i = SOME (r (@(x :β). PMATCH_ROW_COND p g i x))``, ``(R :α -> α -> bool)⁺ (x :α) (z :α) ⇔ R x z ∨ ∃(y :α). R⁺ x y ∧ R y z``, ``∀(R :α -> α -> bool). Order R ⇔ StrongOrder (STRORD R)``] *)

val l = [``(∀(x :α). (P :α -> bool) x ⇒ (Q :α option -> bool) (SOME x)) ∧ ((∀(x :α). ¬P x) ⇒ Q (NONE :α option)) ⇒ Q ($some P)``, ``∀(c :bool) (x :bool). (if c then T else x) ⇔ ¬c ⇒ x``, ``∀(R :α -> α -> bool). irreflexive Rᵀ ⇔ irreflexive R``, ``∀(v :α) (rs :(α -> β option) list). (EVERY (λ(r :α -> β option). r v = (NONE :β option)) rs ⇒ F) ⇒ PMATCH_IS_EXHAUSTIVE v rs``, ``∀(b :bool). ¬b ⇒ (b ⇔ F)``, ``∀(x :α option). IS_NONE x ⇔ x = (NONE :α option)``, ``∀(v :α) (rows :(α -> β option) list) (i :num). i < LENGTH rows ⇒ (EL i (STRONGEST_REDUNDANT_ROWS_INFO v rows) ⇔ EVERY (λ(r :α -> β option). r v = (NONE :β option)) (TAKE i rows) ⇒ EL i rows v = (NONE :β option))``, ``INVOL (relinv :(α -> α -> bool) -> α -> α -> bool)``, ``∀(m :num) (n :num). m < n ⇒ SUC m < SUC n``, ``(R :α -> α -> bool)꙳ (x :α) x``, ``∀(t :bool). T ⇒ t ⇔ t``, ``(n :num) ≤ tri n``, ``∀(x :α) (y :α). (R :α -> α -> bool)꙳ x y ⇒ R^= x y``, ``∀(R :α -> β -> bool). Rᵀ ᵀ = R``, ``∀(f1 :num -> α -> bool) (f1' :num -> α -> bool) (f2 :num -> α -> bool) (f2' :num -> α -> bool). ind_type$INJP f1 f2 = ind_type$INJP f1' f2' ⇔ f1 = f1' ∧ f2 = f2``, ``IS_SOME (OPTION_MAP (f :α -> β) (x :α option)) ⇔ IS_SOME x``, ``∀(R :α -> α -> bool). symmetric (SC R)``, ``(∅ᵣ :α -> α -> bool) ⊆ᵣ (R :α -> α -> bool) ∧ (R ⊆ᵣ (∅ᵣ :α -> α -> bool) ⇔ R = (∅ᵣ :α -> α -> bool))``, ``∀(t :bool). t ∧ T ⇔ t``, ``∀(R :α -> α -> bool) (P :α -> α -> bool). (∀(x :α). P x x) ∧ (∀(x :α) (y :α) (z :α). P x y ∧ R y z ⇒ P x z) ⇒ ∀(x :α) (y :α). R꙳ x y ⇒ P x y``, ``∀(p :α # β) (f :α -> γ) (g :β -> δ). SND ((f ## g) p) = g (SND p)``, ``(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ R ((f :α -> α) x) (f y)) ⇒ ∀(x :α) (y :α). SC R x y ⇒ SC R (f x) (f y)``, ``(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ R ((f :α -> α) x) (f y)) ⇒ ∀(x :α) (y :α). R꙳ x y ⇒ R꙳ (f x) (f y)``, ``¬((p :bool) ⇒ (q :bool)) ⇒ p``, ``(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ (Q :α -> α -> bool) x y) ⇒ RC R (x :α) (y :α) ⇒ RC Q x y``, ``transitive (R :α -> α -> bool) ⇔ R ∘ᵣ R ⊆ᵣ R``, ``∀(R :α -> α -> bool). transitive Rᵀ ⇔ transitive R``, ``∀(P :α -> bool) (v :β) (rows :(β -> α option) list). P (PMATCH v rows) ⇔ PMATCH_EXPAND_PRED P v ([] :(β -> α option) list) rows``, ``∀(m :num) (n :num). m ≤ n ⊗ m``, ``∀(R :α -> α -> bool). (∀(P :α -> bool). (∀(x :α). (∀(y :α). R y x ⇒ P y) ⇒ P x) ⇒ ∀(x :α). P x) ⇒ WF R``, ``symmetric (R1 :α -> α -> bool) ∧ symmetric (R2 :β -> β -> bool) ⇒ symmetric (R1 LEX R2)``, ``IDEM (RTC :(α -> α -> bool) -> α -> α -> bool)``, ``PMATCH_ROW_COND_NOT_EX_OR_EQ (i :α) (r :α -> β option) ([] :(α -> β option) list) ⇔ r i ≠ (NONE :β option) ⇒ F``, ``PMATCH_ROW_COND (pat :α -> β) (guard :α -> bool) (inp :β) (v :α) ⇔ inp = pat v ∧ guard v``, ``¬T ⇔ F``, ``OPTION_MAP (f :α -> β) (x :α option) = (option_CASE x (NONE :β option) ((SOME :β -> β option) ∘ f) :β option)``, ``(some(x :α). F) = (NONE :α option)``, ``(y :α) ∈ RRANGE (R :β -> α -> bool) ⇔ ∃(x :β). R x y``, ``∀(P :α + β -> bool). (∃(s :α + β). P s) ⇔ (∃(x :α). P (INL x :α + β)) ∨ ∃(y :β). P (INR y :α + β)``, ``PMATCH (v :β) (rows :(β -> α option) list) = PMATCH v (SNOC (PMATCH_ROW (λ(_0 :β). _0) (λ(_0 :β). T) (λ(_0 :β). (ARB :α))) rows)``, ``trichotomous (STRORD (R :α -> α -> bool)) ⇔ trichotomous R``, ``(R :α -> β -> bool) ∘ᵣ ($= :α -> α -> bool) = R``, ``∀(R :α -> α -> bool). equivalence R ⇒ Rᵀ = R``, ``(OPTION_BIND (p :α option) (f :α -> β option) = (NONE :β option) ⇔ p = (NONE :α option) ∨ ∃(x :α). p = SOME x ∧ f x = (NONE :β option)) ∧ (OPTION_BIND p f = SOME (y :β) ⇔ ∃(x :α). p = SOME x ∧ f x = SOME y)``, ``DATATYPE ((pair :(α -> β -> α # β) -> γ) ($, :α -> β -> α # β))``, ``∀(n :num). ¬(n < (0 :num))``, ``(option_CASE (x :α option) (e :β) (f :α -> β) :β) = if IS_SOME x then f (THE x) else e``, ``∀(v :α) (p :β -> α) (g :β -> bool) (p' :γ -> α) (g' :γ -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g ⇒ (∀(x :β). g x ⇒ ((∃(x' :γ). p' x' = p x ∧ g' x') ⇔ RES)) ⇒ (PMATCH_ROW_COND_EX v p' g' ⇔ RES)``, ``¬((A :bool) ∨ (B :bool)) ⇒ F ⇔ ¬A ⇒ ¬B ⇒ F``, ``((if (P :bool) then SOME (x :α) else (NONE :α option)) = (NONE :α option) ⇔ ¬P) ∧ ((if P then (NONE :α option) else SOME x) = (NONE :α option) ⇔ P) ∧ ((if P then SOME x else (NONE :α option)) = SOME (y :α) ⇔ P ∧ x = y) ∧ ((if P then (NONE :α option) else SOME x) = SOME y ⇔ ¬P ∧ x = y)``, ``∀(m :num) (n :num). SUC m = SUC n ⇔ m = n``, ``∀(n :num). SUC (m :num) = n ⇒ m < n``, ``Order (R :α -> α -> bool) ⇔ WeakOrder (RC R)``, ``∀(t :bool). F ⇒ t ⇔ T``, ``PMATCH_ROW_REDUNDANT (v :α) ((r :α -> β option)::(rs :(α -> β option) list)) (0 :num) ⇔ r v = (NONE :β option)``, ``PMATCH_ROW (p :β -> γ) (g :β -> bool) (r :β -> α) (i :γ) ≠ (NONE :α option) ⇔ PMATCH_ROW_COND_EX i p g``, ``WF (R :α -> α -> bool) ⇒ irreflexive R``, ``(antisymmetric (R1 :α -> α -> bool) ⇒ antisymmetric (R1 ∩ᵣ (R2 :α -> α -> bool))) ∧ (antisymmetric R2 ⇒ antisymmetric (R1 ∩ᵣ R2))``, ``∀(M :α + β) (M' :α + β) (f :α -> γ) (f1 :β -> γ). M = M' ∧ (∀(x :α). M' = (INL x :α + β) ⇒ f x = (f' :α -> γ) x) ∧ (∀(y :β). M' = (INR y :α + β) ⇒ f1 y = (f1' :β -> γ) y) ⇒ (sum_CASE M f f1 :γ) = (sum_CASE M' f' f1' :γ)``, ``∀(R :α -> α -> bool) (x :α) (y :α). R꙳ x y ⇔ x = y ∨ R⁺ x y``, ``∀(R :α -> α -> bool). (∀(x :α). R꙳ x x) ∧ ∀(x :α) (y :α) (z :α). R x y ∧ R꙳ y z ⇒ R꙳ x z``, ``∀(P :α -> β -> bool). (∃(x :α) (y :β). P x y) ⇔ ∃((x :α),(y :β)). P x y``, ``OWHILE (G :α -> bool) (f :α -> α) (s :α) = (NONE :α option) ⇔ ∀(n :num). G (FUNPOW f n s)``, ``∀(t :bool). t ⇒ T ⇔ T``, ``(x :α) ∈ RDOM ((R1 :α -> β -> bool) ∪ᵣ (R2 :α -> β -> bool)) ⇔ x ∈ RDOM R1 ∨ x ∈ RDOM R2``, ``∀(a1 :α) (a2 :α). ind_type$INJA a1 = ind_type$INJA a2 ⇔ a1 = a2``, ``∀(Q :num -> bool) (P :num -> bool). (∃(n :num). P n) ∧ (∀(n :num). (∀(m :num). m < n ⇒ ¬P m) ∧ P n ⇒ Q n) ⇒ Q ($LEAST P)``, ``∀(ss :α + β). (∃(x :α). ss = (INL x :α + β)) ∨ ∃(y :β). ss = (INR y :α + β)``, ``∀(f :α # β -> γ). UNCURRY (CURRY f) = f``, ``∀(x :α + β). ISL x ∨ ISR x``, ``∀(R :α -> α -> bool) (RTC' :α -> α -> bool). (∀(x :α). RTC' x x) ∧ (∀(x :α) (y :α) (z :α). R x y ∧ RTC' y z ⇒ RTC' x z) ⇒ ∀(a0 :α) (a1 :α). R꙳ a0 a1 ⇒ RTC' a0 a1``, ``∀(R :α -> α -> bool). StrongOrder R ⇒ Order R``, ``∀(R :α -> α -> bool). transitive R꙳``, ``IDEM (STRORD :(α -> α -> bool) -> α -> α -> bool)``, ``∀(p :α -> β) (g :α -> bool) (r :α -> γ) (v :β) (rows :(β -> γ option) list). (∀(x :α). r x = (ARB :γ)) ⇒ PMATCH v (SNOC (PMATCH_ROW p g r) rows) = PMATCH v rows``, ``(∀(x :α) (y :β). (P :α -> β -> bool) x y ⇒ (Q :α -> β -> bool) x y) ⇒ OPTREL P (x :α option) (y :β option) ⇒ OPTREL Q x y``, ``total (R1 :α -> α -> bool) ∧ total (R2 :β -> β -> bool) ⇒ total (R1 LEX R2)``, ``∀(R :α -> α -> bool). symmetric R ⇒ SC R = R``, ``OPTION_MAP2 (f :α -> β -> γ) (o1 :α option) (o2 :β option) = SOME (v :γ) ⇔ ∃(x1 :α) (x2 :β). o1 = SOME x1 ∧ o2 = SOME x2 ∧ v = f x1 x2``, ``∀(x :α option option) (y :α). OPTION_JOIN x = SOME y ⇔ x = SOME (SOME y)``, ``∀(R :α -> α -> bool). equivalence R ⇔ ∀(x :α) (y :α). R x y ⇔ R x = R y``, ``∀(f :α -> β) (R :α -> α -> bool) (D :α -> bool) (P :α -> β -> bool) (M :(α -> β) -> α -> β) (x :α). f = WFREC R M ∧ WF R ∧ INDUCTIVE_INVARIANT_ON R D P M ∧ D x ⇒ P x (f x)``, ``IDEM (RC :(α -> α -> bool) -> α -> α -> bool)``, ``∀(x :α) (y :β). FST (x,y) = x``, ``(∀(x :α) (y :α). (P :α -> bool) x ∧ (R :α -> α -> bool) x y ⇒ P y) ⇒ ∀(x :α) (y :α). P x ∧ R꙳ x y ⇒ P y``, ``∀(opt1 :α option) (opt2 :α option) (f1 :α -> β) (f2 :α -> β). opt1 = opt2 ∧ (∀(x :α). opt2 = SOME x ⇒ f1 x = f2 x) ⇒ OPTION_MAP f1 opt1 = OPTION_MAP f2 opt2``, ``∀(f :α -> β) (g :γ -> δ) (x :α) (y :γ). (f ## g) (x,y) = (f x,g y)``, ``∀(t :bool). t ∨ t ⇔ t``, ``(∀(x :α) (y :α). (R1 :α -> α -> bool) x y ⇒ (R2 :α -> α -> bool) x y) ∧ (∀(x :β) (y :β). (R3 :β -> β -> bool) x y ⇒ (R4 :β -> β -> bool) x y) ⇒ (R1 LEX R3) (x :α # β) (y :α # β) ⇒ (R2 LEX R4) x y``, ``PMATCH_ROW_COND_EX (i :α) (p :β -> α) (g :β -> bool) ⇒ PMATCH_ROW p g (r :β -> γ) i = SOME (r (@(x :β). PMATCH_ROW_COND p g i x))``, ``(R :α -> α -> bool)⁺ (x :α) (z :α) ⇔ R x z ∨ ∃(y :α). R⁺ x y ∧ R y z``, ``∀(R :α -> α -> bool). Order R ⇔ StrongOrder (STRORD R)``]

val s = [``(∀(x :α). (P :α -> bool) x ⇒ (Q :α option -> bool) (SOME x)) ∧ ((∀(x :α). ¬P x) ⇒ Q (NONE :α option)) ⇒ Q ($some P)``, ``∀(c :bool) (x :bool). (if c then T else x) ⇔ ¬c ⇒ x``, ``∀(R :α -> α -> bool). irreflexive Rᵀ ⇔ irreflexive R``, ``∀(v :α) (rs :(α -> β option) list). (EVERY (λ(r :α -> β option). r v = (NONE :β option)) rs ⇒ F) ⇒ PMATCH_IS_EXHAUSTIVE v rs``]

val lv = [``LIST_REL (R :α -> β -> bool) (xs :α list) ((h :β)::(t :β list)) ⇔ ∃(h' :α) (t' :α list). xs = h'::t' ∧ R h' h ∧ LIST_REL R t' t``, ``∀(x :α) (n :num) (ys :α list). LENGTH (LUPDATE x n ys) = LENGTH ys``, ``∀(l :num list). SUM (REVERSE l) = SUM l``, ``∀(x :α) (l :α list). MEM x l ⇔ FOLDR $\\/ F (MAP ($= x) l)``, ``∀(P :α -> bool) (l :α list). FILTER P l ≠ ([] :α list) ⇔ ∃(x :α). MEM x l ∧ P x``, ``(0 :num) = LENGTH (l :α list) ⇔ l = ([] :α list)``, ``∀(L :num list) (n :num). SUM_ACC L n = SUM L + n``, ``∀(l :(α # β) list). LENGTH (UNZIP_SND l) = LENGTH l``, ``∀(l1 :α list) (l2 :α list). ALL_DISTINCT (l1 ++ l2) ⇔ ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀(e :α). MEM e l1 ⇒ ¬MEM e l2``, ``∀(P :α -> bool) (l :α list). LENGTH (FILTER P l) ≤ LENGTH l``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ TAKE n (REVERSE l) = REVERSE (LASTN n l)``, ``∀(l :α list) (m :num) (x :α). MEM x (DROP m l) ⇒ MEM x l``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l``, ``∀(g :α -> α -> α) (f :β -> α -> α). FCOMM g f ⇒ ∀(e :α). LEFT_ID g e ⇒ ∀(l :β list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)``, ``(∀(l :α list). DROP (0 :num) l = l) ∧ ∀(n :num) (x :α) (l :α list). DROP (SUC n) (x::l) = DROP n l``, ``NULL ([] :α list) ∧ ∀(h :α) (t :α list). ¬NULL (h::t)``, ``GENLIST (f :num -> α) (0 :num) = ([] :α list) ∧ GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :α list)``, ``∀(n :num). n ≠ (0 :num) ⇒ COUNT_LIST n = (0 :num)::MAP SUC (COUNT_LIST (n − (1 :num)))``, ``∀(n :num) (l1 :α list) (l2 :α list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n − LENGTH l1) l2``, ``∀(l :α list list). LENGTH (FLAT l) = SUM (MAP (LENGTH :α list -> num) l)``, ``∀(f :α -> β) (n :num) (l :α list). MAP f (TAKE n l) = TAKE n (MAP f l)``, ``∀(l1 :α list) (l2 :α list). l1 ≠ l2 ⇒ ∀(h1 :α) (h2 :α). h1::l1 ≠ h2::l2``, ``TAKE (0 :num) (l :α list) = ([] :α list)``, ``∀(P :β -> bool) (f :α -> β) (l :α list). EXISTS P (MAP f l) ⇔ EXISTS (λ(x :α). P (f x)) l``, ``MAP (SND :β # α -> α) (FILTER (λ((x :β),(y :α)). y ≠ (z :α)) (ls :(β # α) list)) = FILTER (λ(y :α). z ≠ y) (MAP (SND :β # α -> α) ls)``, ``∀(f :α -> β -> β) (e :β) (g :γ -> α) (l :γ list). FOLDR f e (MAP g l) = FOLDR (λ(x :γ) (y :β). f (g x) y) e l``, ``REPLICATE (x :num) (y :α) = ([] :α list) ⇔ x = (0 :num)``, ``∀(n :num). LENGTH (l1 :α list) < n ⇒ TAKE n (l1 ++ (l2 :α list)) = l1 ++ TAKE (n − LENGTH l1) l2``, ``∀(l1 :α list) (l2 :β list). LENGTH l1 = LENGTH l2 ⇒ LENGTH (ZIP (l1,l2)) = LENGTH l1 ∧ LENGTH (ZIP (l1,l2)) = LENGTH l2``, ``∀(ls :α list) (n :num). DROP n ls = ([] :α list) ⇔ LENGTH ls ≤ n``, ``∀(n :num) (x :α). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x``, ``∀(l1 :α list) (l2 :α list). ¬NULL l1 ⇒ ELL (LENGTH l2) (l1 ++ l2) = LAST l1``, ``∀(l :α list). NULL l ⇔ FOLDL (λ(x :bool) (l' :α). F) T l``, ``(∀(x :α). LAST [x] = x) ∧ ∀(h1 :β) (h2 :β) (t :β list). LAST (h1::h2::t) = LAST (h2::t)``, ``∀(P :α -> bool) (l :α list). FILTER P l = FOLDR (λ(x :α) (l' :α list). if P x then x::l' else l') ([] :α list) l``, ``∀(P :α -> bool) (l :α list). EXISTS P l ⇔ FOLDR (λ(x :α) (l' :bool). P x ∨ l') F l``, ``∀(n :num). TAKE n ([] :α list) = ([] :α list)``, ``∀(l2 :α list) (l1 :α list). IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1``, ``∀(n :num) (m :num) (l :α list). n + m ≤ LENGTH l ⇒ LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l)``, ``∀(l :α list). DROP (LENGTH l) l = ([] :α list)``, ``∀(n :num) (f :num -> α). NULL (GENLIST f n) ⇔ n = (0 :num)``, ``∀(P :α list -> bool). (∀(l :α list). LENGTH l = (0 :num) ⇒ P l) ⇔ P ([] :α list)``, ``∀(y :α) (x :α) (l :α list). MEM y (SNOC x l) ⇔ y = x ∨ MEM y l``, ``∀(n :num) (k :num). SUM (REPLICATE n k) = n * k``, ``(n :num) = LENGTH (l1 :α list) ⇒ ZIP (l1,COUNT_LIST n) = GENLIST (λ(n :num). (EL n l1,n)) (LENGTH l1)``, ``∀(l1 :num list) (l2 :num list). SUM (l1 ++ l2) = SUM l1 + SUM l2``, ``∀(n :num) (l :α list). n < LENGTH l ⇒ DROP n l = EL n l::DROP (SUC n) l``, ``∀(x :α list). x ≼ x``, ``∀(P :α -> bool) (l :α list). FILTER P l = ([] :α list) ⇔ EVERY (λ(x :α). ¬P x) l``, ``∀(l :α list). NULL l ⇔ LENGTH l = (0 :num)``, ``∀(n :num) (m :num) (l :α list). DROP n (DROP m l) = DROP (n + m) l``, ``∀(P :α -> bool) (Q :α -> bool) (l :α list). (∀(x :α). MEM x l ∧ P x ⇒ Q x) ∧ EVERY P l ⇒ EVERY Q l``, ``∀(l :α list). NULL l ⇔ l = ([] :α list)``, ``MAP (λ((x :α),(y :β),(z :γ)). x) (funs :(α # β # γ) list) = MAP (FST :α # β # γ -> α) funs``, ``∀(n :num) (ls :α list). n < LENGTH ls ⇒ LUPDATE (EL n ls) n ls = ls``, ``∀(l :α list). LENGTH l = FOLDR (λ(x :α) (l' :num). SUC l') (0 :num) l``, ``∀(P :α -> bool) (l :α list). ¬EXISTS P l ⇔ EVERY ($¬ ∘ P) l``, ``∀(n :num) (x :α). LENGTH (REPLICATE n x) = n``, ``∀(l1 :α list) (l2 :α list) (l3 :α list). (∀(n :num). n < LENGTH l1 ∧ (R :α -> α -> bool) (EL n l1) (EL n l2) ∧ R (EL n l2) (EL n l3) ⇒ R (EL n l1) (EL n l3)) ∧ LIST_REL R l1 l2 ∧ LIST_REL R l2 l3 ⇒ LIST_REL R l1 l3``, ``∀(x :α) (l :α list). REVERSE (SNOC x l) = x::REVERSE l``, ``∀(ls :num list). SUM ls = (0 :num) ⇔ ∀(x :num). MEM x ls ⇒ x = (0 :num)``, ``∀(n :num) (l1 :α list) (l2 :α list). l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2``, ``∀(l :α list) (x :α). l ≠ x::l ∧ x::l ≠ l``, ``∀(l :α list). IS_SUFFIX l l``, ``∀(a :α list) (b :α list) (c :α list). a ++ b ≼ a ++ c ⇔ b ≼ c``, ``∀(f :α -> β -> β) (e :β) (x :α) (l :α list). FOLDR f e (SNOC x l) = FOLDR f (f x e) l``, ``∀(n :num) (l2 :α list). n ≤ LENGTH l2 ⇒ ∀(l1 :α list). LASTN n (l1 ++ l2) = LASTN n l2``, ``∀(x :α) (l :α list). LENGTH (SNOC x l) = SUC (LENGTH l)``, ``∀(l :α list) (f :α -> β). LENGTH (MAP f l) = LENGTH l``, ``LIST_BIND [(x :β)] (f :β -> α list) = f x``, ``∀(l :α list) (x :α). ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l``, ``∀(P :num -> bool) (n :num). EVERY P (COUNT_LIST n) ⇔ ∀(m :num). m < n ⇒ P m``, ``(l1 :α list) ++ (l2 :α list) = [(e :α)] ⇔ l1 = [e] ∧ l2 = ([] :α list) ∨ l1 = ([] :α list) ∧ l2 = [e]``, ``∀(P :α -> bool) (ls :α list). NULL (FILTER P ls) ⇔ ∀(x :α). MEM x ls ⇒ ¬P x``, ``∀(f :α -> bool) (l :α list). FILTER f (FILTER f l) = FILTER f l``, ``∀(l :α list). l ≠ ([] :α list) ⇒ FRONT l ++ [LAST l] = l``, ``∀(pl :(α # β) list). LENGTH (FST (UNZIP pl)) = LENGTH pl ∧ LENGTH (SND (UNZIP pl)) = LENGTH pl``, ``∀(l1 :α list) (l2 :α list). REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1``, ``∀(x :α list) (l :α list list). FLAT (SNOC x l) = FLAT l ++ x``, ``∀(xs :α list). FILTER (λ(x :α). F) xs = ([] :α list)``, ``∀(f :α -> β) (l :α list) (a :α). MEM a l ⇒ MEM (f a) (MAP f l)``, ``∀(f :α -> β) (l1 :α list) (l2 :α list). INJ f (set l1 ∪ set l2) 𝕌(:β) ⇒ (MAP f l1 = MAP f l2 ⇔ l1 = l2)``, ``∀(m :num) (n :num) (l :α list). m ≤ n ∧ n ≤ LENGTH l ⇒ BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l)``, ``(∀(x :α) (y :β). (R1 :α -> β -> bool) x y ⇒ (R2 :α -> β -> bool) x y) ⇒ LIST_REL R1 (l1 :α list) (l2 :β list) ⇒ LIST_REL R2 l1 l2``, ``∀(n :num) (x :α). REPLICATE n x = GENLIST (K x :num -> α) n``, ``∀(l :α list) (x :α). BUTLASTN (LENGTH l) (x::l) = [x]``, ``∀(x :α) (L :α list list). MEM x (FLAT L) ⇔ ∃(l :α list). MEM l L ∧ MEM x l``, ``MAP (λ(x :α). x) (l :α list) = l ∧ MAP (I :α -> α) l = l``, ``∀(f :β -> α -> β) (e :β) (x :α) (l :α list). FOLDL f e (SNOC x l) = f (FOLDL f e l) x``, ``(∀(l :α list). l ++ ([] :α list) = l) ∧ ∀(l :β list). ([] :β list) ++ l = l``, ``EVERY (P :α -> bool) (FLAT (ls :α list list)) ⇔ EVERY (EVERY P) ls``, ``∀(P :α -> bool) (l1 :α list) (l2 :α list). EVERY P l1 ⇒ dropWhile P (l1 ++ l2) = dropWhile P l2``, ``∀(l :α list) (m :num) (x :α). MEM x (TAKE m l) ⇒ MEM x l``, ``∀(y :α) (l :α list). MEM y l ⇔ FOLDR (λ(x :α) (l' :bool). y = x ∨ l') F l``]

val sv = [``∀(s :β -> bool). FUNSET (∅ :α -> bool) s = 𝕌(:α -> β)``, ``∀(f :α -> β) (s :α -> bool) (t :β -> bool). INJ f s t ⇒ INJ f s (IMAGE f s)``, ``∀(f :α -> β) (s :(β -> bool) -> bool). PREIMAGE f (BIGUNION s) = BIGUNION (IMAGE (PREIMAGE f) s)``, ``∀(x :α -> bool) (y :α -> bool) (z :α -> bool). x DIFF (y ∪ z) = x DIFF y DIFF z``, ``∀(f :α -> β). (∀(s :β -> bool). SURJ f (∅ :α -> bool) s ⇔ s = (∅ :β -> bool)) ∧ ∀(s :α -> bool). SURJ f s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)``, ``∀(s :α -> bool) (t :α -> bool). s ∩ t = t ∩ s``, ``∀(s :α -> bool). ¬(s ⊂ (∅ :α -> bool))``, ``∀(s :α -> bool) (t :α -> bool) (x :α). (s DELETE x) ∩ t = s ∩ t DELETE x``, ``∀(x :α) (P :α -> bool). x ∈ P ⇔ P x``, ``∀(P :α -> bool) (B :(α -> bool) -> bool). BIGINTER (P INSERT B) = P ∩ BIGINTER B``, ``∀(P :α -> bool). INFINITE P ⇒ ∃(x :α). x ∈ P``, ``∀(s :α -> bool). (∃(f :num -> α). BIJ f 𝕌(:num) s) ⇒ countable s``, ``∀(P :α -> bool) (s :α -> bool) (t :α -> bool). (∀(x :α). x ∈ s ∪ t ⇒ P x) ⇔ (∀(x :α). x ∈ s ⇒ P x) ∧ ∀(x :α). x ∈ t ⇒ P x``, ``BIGUNION (∅ :(α -> bool) -> bool) = (∅ :α -> bool)``, ``BIJ (f :α -> β) 𝕌(:α) 𝕌(:β) ⇒ ∀(x :α) (y :α). f x = f y ⇔ x = y``, ``∀(s :α -> bool) (t :α -> bool) (x :α). x ∈ s ∩ t ⇔ x ∈ s ∧ x ∈ t``, ``∀(s :α -> bool). INFINITE s ⇔ ∀(t :α -> bool). FINITE t ⇒ t ⊆ s ⇒ t ⊂ s``, ``∀(s :α -> bool). s DIFF s = (∅ :α -> bool)``, ``∀(x :α) (s :α -> bool). x ∈ s ⇒ x INSERT s DELETE x = s``, ``∀(x :α) (y :α) (s :α -> bool). (x INSERT s) DELETE y = if x = y then s DELETE y else x INSERT s DELETE y``, ``∀(s :α -> bool). FINITE s ⇒ ∃(f :num -> α) (b :num). BIJ f (count b) s``, ``(y :α) ∈ {x | (P :α -> bool) x} ⇔ P y``, ``{(x,y) | (P :α -> β -> bool) x y} = UNCURRY P``, ``∀(s :α -> bool) (t :α -> bool). s ⊆ t ∧ countable t ⇒ countable s``, ``(∀(s :α -> bool) (t :α -> bool). s ∪ (t DIFF s) = s ∪ t) ∧ ∀(s :α -> bool) (t :α -> bool). t DIFF s ∪ s = t ∪ s``, ``∀(P :α -> bool) (f :β -> α) (s :β -> bool). (∃(y :α). y ∈ IMAGE f s ∧ P y) ⇔ ∃(x :β). x ∈ s ∧ P (f x)``, ``SURJ (f :α -> β) (s :α -> bool) (IMAGE f s)``, ``∀(s :α -> bool). COMPL (COMPL s) = s``, ``∀(x :α) (s :α -> bool). x ∈ s ⇒ x INSERT s = s``, ``∀(s :α -> bool) (t :α -> bool). s ⊂ t ⇔ s ⊆ t ∧ ∃(y :α). y ∈ t ∧ y ∉ s``, ``∀(s1 :α -> bool) (s2 :α -> bool) (x :α). s1 ⊆ s2 ⇒ s1 DELETE x ⊆ s2 DELETE x``, ``∀(s :α -> bool). (∅ :α -> bool) DIFF s = (∅ :α -> bool)``, ``∀(f :α -> β -> bool) (s :γ -> bool) (t :α -> bool). s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λ(n :α). s × f n) t)``, ``∀(s :α -> bool). DISJOINT (∅ :α -> bool) s ∧ DISJOINT s (∅ :α -> bool)``, ``∀(s :num -> bool). s ≠ (∅ :num -> bool) ∧ FINITE s ⇒ MIN_SET s ≤ MAX_SET s``, ``∀(x :α). 𝕌(:α) x``, ``∀(s :α -> bool). s ⊆ (∅ :α -> bool) ⇔ s = (∅ :α -> bool)``, ``∀(s :α -> bool). s ∪ s = s``, ``∀(P :α -> bool) (a :α) (s :α -> bool). (∃(x :α). x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃(x :α). x ∈ s ∧ P x``, ``∀(s :α -> bool). 𝕌(:α) ⊆ s ⇔ s = 𝕌(:α)``, ``∀(x :α) (s :α -> bool). COMPL s x ⇔ x ∉ s``, ``(∀(x :num). pair_to_num (num_to_pair x) = x) ∧ ∀(x :num) (y :num). num_to_pair (pair_to_num (x,y)) = (x,y)``, ``∀(R :α -> α -> bool) (s :α -> bool) (t :α -> bool). t ∈ partition R s ⇒ t ⊆ s``, ``∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ⊆ t ∩ u ⇔ s ⊆ t ∧ s ⊆ u``, ``pairwise (R :α -> α -> bool) ((s1 :α -> bool) ∪ (s2 :α -> bool)) ⇔ pairwise R s1 ∧ pairwise R s2 ∧ ∀(x :α) (y :α). x ∈ s1 ∧ y ∈ s2 ⇒ R x y ∧ R y x``, ``∀(I :num -> bool) (J :num -> bool) (n :α). I ≠ (∅ :num -> bool) ∧ J ≠ (∅ :num -> bool) ∧ I ⊆ J ⇒ MIN_SET J ≤ MIN_SET I``, ``INFINITE 𝕌(:α) ⇔ ∀(s :α -> bool). FINITE s ⇒ ∃(x :α). x ∉ s``, ``∀(s :α -> bool). FINITE s ⇒ countable s``, ``{x | (y :α) = x} = {y}``, ``∀(x :α) (s :α -> bool). x ∈ REST s ⇔ x ∈ s ∧ x ≠ CHOICE s``, ``∀(f :α -> β) (s :α -> bool) (t :α -> bool). IMAGE f (s ∩ t) ⊆ IMAGE f s ∩ IMAGE f t``, ``∀(s :α -> bool). ¬(𝕌(:α) ⊂ s)``, ``∀(X :α -> bool) (P :(α -> bool) -> bool). BIGUNION P ⊆ X ⇔ ∀(Y :α -> bool). Y ∈ P ⇒ Y ⊆ X``, ``∀(s :α -> bool) (n :num). s HAS_SIZE n ⇒ CARD s = n``, ``∀(s :α -> bool) (t :α -> bool). INFINITE s ∧ FINITE t ⇒ s DIFF t ≠ (∅ :α -> bool)``, ``∀(m :num) (n :num). count n m ⇔ m < n``, ``IMAGE (f :β -> α) (s :β -> bool) = {(z :α)} ⇔ s ≠ (∅ :β -> bool) ∧ ∀(x :β). x ∈ s ⇒ f x = z``, ``∀(x :α) (y :α). {x} = {y} ⇔ x = y``, ``(∀(s :α -> bool). (∅ :α -> bool) ∪ s = s) ∧ ∀(s :α -> bool). s ∪ (∅ :α -> bool) = s``, ``∀(f :α -> β) (s :β -> bool) (t :β -> bool). PREIMAGE f (s DIFF t) = PREIMAGE f s DIFF PREIMAGE f t``, ``∀(f :α -> β) (x :α) (s :α -> bool) (t :β -> bool). INJ f (x INSERT s) t ⇔ INJ f s t ∧ f x ∈ t ∧ ∀(y :α). y ∈ s ∧ f x = f y ⇒ x = y``, ``∀(y :β) (s :α -> bool) (f :α -> β). IMAGE f s y ⇔ ∃(x :α). y = f x ∧ x ∈ s``, ``∀(e :α) (s :α -> bool). POW (e INSERT s) = IMAGE ($INSERT e) (POW s) ∪ POW s``, ``∀(r :α -> bool) (s :α -> bool) (t :α -> bool). r ⊆ s ⇒ r DIFF s ∩ t = r DIFF t``, ``(∀(s :α -> bool). 𝕌(:α) ∩ s = s) ∧ ∀(s :α -> bool). s ∩ 𝕌(:α) = s``, ``count (0 :num) = (∅ :num -> bool)``, ``∀(x :α) (s :α -> bool) (t :α -> bool). (x INSERT s) ∪ t = if x ∈ t then s ∪ t else x INSERT s ∪ t``, ``∀(P :α -> bool) (s :(α -> bool) -> bool). (∀(x :α). x ∈ BIGUNION s ⇒ P x) ⇔ ∀(t :α -> bool) (x :α). t ∈ s ∧ x ∈ t ⇒ P x``, ``∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ⊂ t ∧ t ⊆ u ⇒ s ⊂ u``, ``∀(p :α -> bool) (q :α -> bool). p ∩ q ∪ COMPL p ∩ q = q``, ``(∀(x :α). x ∈ (s :α -> bool) ⇒ (INR x :β + α) ∈ (t :β + α -> bool)) ⇒ INJ (INR :α -> β + α) s t``, ``(∀(x :α). x ∈ (s :α -> bool) ⇒ (INL x :α + β) ∈ (t :α + β -> bool)) ⇒ INJ (INL :α -> α + β) s t``, ``∀(x :α) (s :α -> bool) (t :α -> bool). DISJOINT (x INSERT s) t ⇔ DISJOINT s t ∧ x ∉ t``, ``∀(s :α -> bool) (x :α). x ∈ s ⇔ ∃(t :α -> bool). s = x INSERT t ∧ x ∉ t``, ``∀(f :α -> β). (∀(s :β -> bool). INJ f (∅ :α -> bool) s) ∧ ∀(s :α -> bool). INJ f s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)``, ``∀(s :α -> bool) (t :α -> bool) (u :α -> bool) (v :α -> bool). DISJOINT s t ∧ u ⊆ s ∧ v ⊆ t ⇒ DISJOINT u v``, ``(s0 :α -> bool) ⊆ (s :α -> bool) ∧ INJ (f :α -> β) s (t :β -> bool) ⇒ BIJ f s0 (IMAGE f s0)``, ``∀(f :α -> β -> bool) (s :α -> bool) (t :γ -> bool). BIGUNION (IMAGE f s) × t = BIGUNION (IMAGE (λ(n :α). f n × t) s)``, ``(R :α -> α -> bool) equiv_on (s :α -> bool) ⇒ ∀(t1 :α -> bool) (t2 :α -> bool). t1 ∈ partition R s ∧ t2 ∈ partition R s ∧ t1 ≠ t2 ⇒ DISJOINT t1 t2``, ``∀(s :α -> bool) (x :α). x ∈ s ⇒ (s DELETE x = (∅ :α -> bool) ⇔ s = {x})``, ``∀(f :α -> β) (s :α -> bool) (t :β -> bool). INJ f s t ∧ INFINITE s ⇒ INFINITE t``, ``∀(s :α -> bool). SING s ⇒ FINITE s``]

val lall = [``∀(s :α -> bool) (t :α -> bool). t ⊆ s ⇒ s DIFF (s DIFF t) = t``, ``∀(set :α -> bool) (e :α -> bool). e ∈ POW set ⇔ e ⊆ set``, ``FINITE 𝕌(:α # β) ⇔ FINITE 𝕌(:α) ∧ FINITE 𝕌(:β)``, ``∀(f :α -> β) (s :α -> bool) (t :β -> bool). FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t``, ``{x | T} = 𝕌(:α)``, ``COMPL (∅ :α -> bool) = 𝕌(:α)``, ``∀(s :α -> bool) (t :α -> bool). s = t ⇔ ∀(x :α). x ∈ s ⇔ x ∈ t``, ``∀(s :α -> bool). (∃(f :num -> α). BIJ f 𝕌(:num) s) ⇒ countable s``, ``∀(a0 :α) (a1 :α list) (a0' :α) (a1' :α list). a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1``, ``∀(s1 :(α -> bool) -> bool) (s2 :(α -> bool) -> bool). BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2``, ``∀(f :α -> β -> bool) (s :γ -> bool) (t :α -> bool). s × BIGUNION (IMAGE f t) = BIGUNION (IMAGE (λ(n :α). s × f n) t)``, ``PMATCH_EQUIV_ROWS (v :α) (rows1 :(α -> β option) list) (rows2 :(α -> β option) list) ⇒ PMATCH v rows1 = PMATCH v rows2``, ``∀(l :α list) (x :α). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]``, ``∀(s :α -> bool). FINITE s ⇒ countable s``, ``∀(l :α list). FINITE (set l)``, ``∀(f :α -> num) (x :α) (ls :α list). MEM x ls ⇒ f x ≤ SUM (MAP f ls)``, ``∀(x :α) (s :α -> bool). x ∈ x INSERT s``, ``∀(n :num) (l :α list). n < LENGTH l ⇒ BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)``, ``∀(v :α) (p :β -> α) (g :β -> bool) (p' :γ -> α) (g' :γ -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g ⇒ (∀(x :β). g x ⇒ ((∃(x' :γ). p' x' = p x ∧ g' x') ⇔ RES)) ⇒ (PMATCH_ROW_COND_EX v p' g' ⇔ RES)``, ``∀(x :α). (∅ :α -> bool) DELETE x = (∅ :α -> bool)``, ``∀(s :α -> bool) (t :α -> bool). s DIFF t ∩ s = s DIFF t``, ``∀(n :num) (l1 :α list) (l2 :α list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n − LENGTH l1) l2``, ``∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ∩ (t ∩ u) = s ∩ t ∩ u``, ``∀(P :α list -> bool). (∀(l :α list). LENGTH l = (0 :num) ⇒ P l) ⇔ P ([] :α list)``, ``ASSOC ($++ :α list -> α list -> α list)``, ``PMATCH_ROW_REDUNDANT (v :α) ([] :(α -> β option) list) (i :num) ⇔ F``, ``∀(ZRECSPACE' :(num -> α -> bool) -> bool). ZRECSPACE' (ind_type$ZBOT :num -> α -> bool) ∧ (∀(c :num) (i :α) (r :num -> num -> α -> bool). (∀(n :num). ZRECSPACE' (r n)) ⇒ ZRECSPACE' (ind_type$ZCONSTR c i r)) ⇒ ∀(a0 :num -> α -> bool). ZRECSPACE a0 ⇒ ZRECSPACE' a0``, ``∀(l1 :α list) (l2 :β list). LENGTH l1 = LENGTH l2 ⇒ ∀(x1 :α) (x2 :β). ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))``, ``¬SHORTLEX (R :α -> α -> bool) (l :α list) ([] :α list)``, ``∀(e :α). ∃(fn :unit -> α). fn () = e``, ``∀(l :α list). l ≠ ([] :α list) ⇒ FRONT l ++ [LAST l] = l``, ``∀(l :α list) (n :num). n < LENGTH l ⇒ LAST (DROP n l) = LAST l``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ ∀(x :α). BUTLASTN n (x::l) = x::BUTLASTN n l``, ``∀(f :α -> β) (s :β -> bool) (t :β -> bool). DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)``, ``(∃(ls :α list). (P :α list -> bool) ls) ⇔ ∃(n :num) (f :num -> α). P (GENLIST f n)``, ``nub ([] :α list) = ([] :α list)``, ``WF (R :α -> α -> bool)⁺ ⇔ WF R``, ``∀(n :num). countable (count n)``, ``{x | (y :α) = x} = {y}``, ``∀(x :α) (l :α list). SNOC x l = l ++ [x]``, ``∀(s :α -> bool) (t :α -> bool). DISJOINT s t ⇔ ∀(x :α). x ∈ s ⇒ x ∉ t``, ``GENLIST (f :num -> α) (0 :num) = ([] :α list) ∧ GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :α list)``, ``∀(s :α) (x :α -> bool). x ⊂ {s} ⇔ x = (∅ :α -> bool)``, ``∀(R :α -> α -> bool). symmetric Rᵀ ⇔ symmetric R``, ``∀(t1 :α) (t2 :α). (if F then t1 else t2) = t2``, ``∀(l1 :α list) (l2 :α list). set (l1 ++ l2) = set l1 ∪ set l2``, ``∀(l1 :α list) (l2 :α list). l2 ≼ l1 ⇔ ∃(l :α list). l1 = l2 ++ l``, ``∀(R :α -> α -> bool). irreflexive Rᵀ ⇔ irreflexive R``, ``∀(s :α -> bool). CHOICE s ∉ REST s``, ``∀(l1 :α list) (l2 :α list). l1 ++ l2 = FOLDL (λ(l' :α list) (x :α). SNOC x l') l1 l2``, ``∀(L :α list) (n :num). LEN L n = LENGTH L + n``, ``∀(x :bool) (x' :bool) (y :bool) (y' :bool). (x ⇒ y' ⇒ y) ∧ (¬y' ⇒ x ⇒ x') ⇒ (x' ⇒ y') ⇒ x ⇒ y``, ``∀(P :α -> bool) (l :α list). EVERY P l ⇔ ∀(e :α). MEM e l ⇒ P e``, ``∀(n1 :num) (n2 :num). count n1 = count n2 ⇔ n1 = n2``, ``∀(n :num). (0 :num) < n ⇒ ∀(x :α) (l :α list). EL n (x::l) = EL (PRE n) l``, ``∀(e :α) (l :α list). LIST_ELEM_COUNT e l > (0 :num) ⇔ MEM e l``, ``∀(t :bool). t ∨ t ⇔ t``, ``(∀(x :α) (y :α). (f :α -> β) x = f y ⇔ x = y) ⇒ (DISJOINT (IMAGE f (s1 :α -> bool)) (IMAGE f (s2 :α -> bool)) ⇔ DISJOINT s1 s2)``, ``∀(x :bool) (x' :bool) (y :bool) (y' :bool). (y ⇒ x' ⇒ x) ∧ (x' ⇒ y' ⇒ y) ⇒ x' ∧ y' ⇒ x ∧ y``, ``∀(n :num). DROP n ([] :α list) = ([] :α list)``, ``∀(s :α -> bool). s ⊂ 𝕌(:α) ⇔ ∃(x :α). x ∉ s``, ``(Q :α option -> bool) ($some (P :α -> bool)) ⇒ (∃(x :α). P x ∧ Q (SOME x)) ∨ (∀(x :α). ¬P x) ∧ Q (NONE :α option)``, ``transitive ($SUBSET :(α -> bool) -> (α -> bool) -> bool)``, ``∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool). INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u``, ``∀(y :β) (s :α -> bool) (f :α -> β). IMAGE f s y ⇔ ∃(x :α). y = f x ∧ x ∈ s``, ``∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool). SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u``, ``∀(f :'z -> 'z). INVOL f ⇒ ∀(a :'z) (b :'z). f a = f b ⇔ a = b``, ``∀(l1 :α list) (l2 :α list) (l3 :α list). l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3``, ``$OLEAST (P :num -> bool) = (NONE :num option) ⇔ ∀(n :num). ¬P n``, ``∀(n :num) (l1 :α list) (l2 :α list). DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n − LENGTH l1) l2``, ``∀(ls :α list) (f :β -> α). EVERY (λ(x :α). ∃(y :β). x = f y) ls ⇒ ∃(l :β list). ls = MAP f l``, ``∀(opt :α option). (∃(x :α). opt = SOME x) ∨ opt = (NONE :α option)``, ``SURJ (f :α -> β) (s :α -> bool) (t :β -> bool) ⇒ ∃(g :β -> α). INJ g t s ∧ ∀(y :β). y ∈ t ⇒ f (g y) = y``, ``∀(R :α -> α -> bool) (x :α) (y :α) (z :α). R꙳ x y ∧ R y z ⇒ R⁺ x z``, ``∀(f :α -> β) (s :α -> bool) (t :β -> bool). INJ f s t ∧ INFINITE s ⇒ INFINITE t``, ``∀(x1 :α) (l1 :α list) (x2 :α) (l2 :α list). SNOC x1 l1 = SNOC x2 l2 ⇒ LENGTH l1 = LENGTH l2``, ``∀(x :α) (l :α list). TL (SNOC x l) = if NULL l then ([] :α list) else SNOC x (TL l)``, ``∀(P :α list -> bool) (n :num). (∀(l :α list). LENGTH l = SUC n ⇒ P l) ⇔ ∀(l :α list). LENGTH l = n ⇒ (λ(l :α list). ∀(x :α). P (x::l)) l``, ``(x :α) ∈ RDOM (RRESTRICT (R :α -> β -> bool) (s :α -> bool)) ⇔ x ∈ RDOM R ∧ x ∈ s``, ``∀(x :α) (l :α list). FRONT (SNOC x l) = l``, ``∀(l :α list) (x :α). MEM x (REVERSE l) ⇔ MEM x l``, ``∀(l :α list). NULL l ⇔ FOLDL (λ(x :bool) (l' :α). F) T l``, ``∀(l :α list) (m :num) (x :α). MEM x (DROP m l) ⇒ MEM x l``, ``∀(x :α + β). ISR x ⇒ (INR (OUTR x) :α + β) = x``, ``(([(f :β -> α)] <*> (l :β list)) :α list) = MAP f l``, ``∀(n :num) (x :α). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x``, ``∀(s :α -> bool) (x :α) (y :α). x INSERT s = {y} ⇔ x = y ∧ s ⊆ {y}``, ``∀(n :num) (l1 :α list) (l2 :α list). l1 ≼ l2 ∧ n < LENGTH l1 ∧ n < LENGTH l2 ⇒ EL n l1 = EL n l2``, ``∀(R :α -> α -> bool). reflexive (RC R)``, ``(R1 :γ -> β -> bool) ∘ᵣ (R2 :δ -> γ -> bool) ∘ᵣ (R3 :α -> δ -> bool) = (R1 ∘ᵣ R2) ∘ᵣ R3``, ``∀(n :num). (0 :num) < n ⇒ ∀(x :α) (l :α list). ELL n (SNOC x l) = ELL (PRE n) l``, ``∀(l1 :α list) (l2 :α list). ALL_DISTINCT (l1 ++ l2) ⇔ ALL_DISTINCT l1 ∧ ALL_DISTINCT l2 ∧ ∀(e :α). MEM e l1 ⇒ ¬MEM e l2``, ``∀(l :α list). l ≠ ([] :α list) ⇒ BUTLASTN (1 :num) l = FRONT l``, ``∀(s :α -> bool) (t :α -> bool). BIGUNION {s; t} = s ∪ t``, ``∀(l2 :α list) (l1 :α list). ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ++ l2) = HD l2``, ``reflexive ((R1 :α -> α -> bool) LEX (R2 :β -> β -> bool)) ⇔ reflexive R1 ∨ reflexive R2``, ``INJ (f :α -> β) (s :α -> bool) (IMAGE f s) ⇒ (countable (IMAGE f s) ⇔ countable s)``, ``MAP (f :β -> α) (LIST_BIND (l :γ list) (g :γ -> β list)) = LIST_BIND l (MAP f ∘ g)``, ``FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)``, ``∀(A :bool) (B :bool) (C :bool). A ∧ B ⇒ C ⇔ A ⇒ B ⇒ C``, ``MAP (SND :β # α -> α) (FILTER (λ((x :β),(y :α)). y ≠ (z :α)) (ls :(β # α) list)) = FILTER (λ(y :α). z ≠ y) (MAP (SND :β # α -> α) ls)``, ``REPLICATE (n :num) (a :α) ++ REPLICATE (m :num) a = REPLICATE (n + m) a``, ``∀(b :bool). ¬b ⇒ (b ⇔ F)``, ``∀(x :α) (y :β) (a :α) (b :β). (x,y) = (a,b) ⇔ x = a ∧ y = b``, ``∀(f :α -> β) (n :num) (x :α). MAP f (REPLICATE n x) = REPLICATE n (f x)``, ``∀(n :num) (l :α list). n < LENGTH l ⇒ SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l``, ``PMATCH_ROW_COND_EX (i :α) (p :β -> α) (g :β -> bool) ⇒ PMATCH_ROW p g (r :β -> γ) i = SOME (r (@(x :β). PMATCH_ROW_COND p g i x))``, ``∀(R1 :α -> α -> bool) (R2 :α -> α -> bool) (x :α) (y :α). (R1 ∩ᵣ R2)꙳ x y ⇒ (R1꙳ ∩ᵣ R2꙳) x y``, ``∀(P :α -> bool) (a :α) (s :α -> bool). (∃(x :α). x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃(x :α). x ∈ s ∧ P x``, ``∀(f :α -> γ) (g :β -> δ) (z :α + β). SUM_MAP f g z = if ISL z then (INL (f (OUTL z)) :γ + δ) else (INR (g (OUTR z)) :γ + δ)``, ``∀(l :α list list). REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :α list -> α list) l))``, ``∀(f1 :α -> β) (f2 :α -> β) (l :α list). MAP f1 l = MAP f2 l ⇔ ∀(e :α). MEM e l ⇒ f1 e = f2 e``, ``($= :α -> α -> bool)ᵀ = ($= :α -> α -> bool)``, ``∀(n :num) (l :α list). n < LENGTH l ⇒ ELL n (REVERSE l) = ELL (PRE (LENGTH l − n)) l``, ``∀(x :α) (s :α -> bool). (∅ :α -> bool) ≠ x INSERT s``, ``(¬SHORTLEX (R :α -> α -> bool) ([] :α list) ([] :α list) ∧ ¬SHORTLEX R ((h1 :α)::(t1 :α list)) ([] :α list)) ∧ SHORTLEX R ([] :α list) ((h2 :α)::(t2 :α list)) ∧ (SHORTLEX R (h1::t1) (h2::t2) ⇔ LENGTH t1 < LENGTH t2 ∨ LENGTH t1 = LENGTH t2 ∧ (R h1 h2 ∨ h1 = h2 ∧ SHORTLEX R t1 t2))``, ``(∀(v :α). PMATCH_IS_EXHAUSTIVE v ([] :(α -> β option) list) ⇔ F) ∧ ∀(v :γ) (r :γ -> δ option) (rs :(γ -> δ option) list). PMATCH_IS_EXHAUSTIVE v (r::rs) ⇔ r v ≠ (NONE :δ option) ∨ PMATCH_IS_EXHAUSTIVE v rs``, ``(∀(s :α -> bool). 𝕌(:α) ∩ s = s) ∧ ∀(s :α -> bool). s ∩ 𝕌(:α) = s``, ``∀(f :α -> β) (s :α -> bool) (t :β -> bool). BIJ f s t ⇔ f ∈ FUNSET s t ∧ ∀(y :β). y ∈ t ⇒ ∃!(x :α). x ∈ s ∧ y = f x``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ BUTLASTN n l = TAKE (LENGTH l − n) l``, ``∀(l2 :α list) (l1 :α list). IS_SUFFIX (REVERSE l1) (REVERSE l2) ⇔ l2 ≼ l1``, ``∀(s :α -> bool) (x :α) (y :α). x ∈ s DELETE y ⇔ x ∈ s ∧ x ≠ y``, ``∀(ls :α list) (n :num). n ≤ LENGTH ls ⇒ REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls − n) ls)``, ``∀(f :α -> β). PREIMAGE f (∅ :β -> bool) = (∅ :α -> bool)``, ``∀(f :α -> β) (l :α list). MAP f (REVERSE l) = REVERSE (MAP f l)``, ``∀(s :α -> bool) (t :α -> bool) (x :α). (s ∪ t) x ⇔ x ∈ s ∨ x ∈ t``, ``∀(n :num). LENGTH (COUNT_LIST n) = n``, ``(∃(p :α # β). (P :α # β -> bool) p) ⇔ ∃(p_1 :α) (p_2 :β). P (p_1,p_2)``, ``∀(l1 :α list) (l2 :α list). l1 ++ l2 = FOLDR (CONS :α -> α list -> α list) l2 l1``, ``∀(s :α -> bool) (x :α). COMPL (x INSERT s) = COMPL s DELETE x``, ``∀(t :bool). t ⇒ T ⇔ T``, ``countable (∅ :α -> bool)``, ``∀(R :α -> α -> bool). Order R ⇔ StrongOrder (STRORD R)``, ``∀(x :bool) (x' :bool) (y :bool) (y' :bool). (x ⇒ y ⇒ y') ∧ (¬y' ⇒ x' ⇒ x) ⇒ (x ⇒ y) ⇒ x' ⇒ y``, ``(x :α list) ≼ (y :α)::(ys :α list) ⇔ x = ([] :α list) ∨ ∃(xs :α list). x = y::xs ∧ xs ≼ ys``, ``∀(P :α -> bool) (l :α list) (m :num). EVERY P l ⇒ EVERY P (TAKE m l)``, ``IS_SOME (OPTION_BIND (x :α option) (g :α -> β option)) ⇒ IS_SOME x``, ``(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ (Q :α -> α -> bool) x y) ⇒ R꙳ (x :α) (y :α) ⇒ Q꙳ x y``, ``∀(x :α list). x ≼ x``, ``count (0 :num) = (∅ :num -> bool)``, ``(∀(x :α). (P :α -> bool) x ⇒ (Q :α -> bool) x) ⇒ EXISTS P (l :α list) ⇒ EXISTS Q l``, ``∀(s :α -> bool) (t :α -> bool). s ⊆ t ⇒ s ∩ t = s``, ``∀(R :α -> α -> bool) (x :α) (y :α). R x y ⇒ R⁺ x y``, ``∀(xs :α list). FILTER (λ(x :α). T) xs = xs``, ``∀(s :α -> bool). (λ(x :α). x) PERMUTES s``, ``∀(l1 :α list) (n :num). LENGTH l1 ≤ n ⇒ ∀(l2 :α list). TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2``, ``∀(s :α -> bool). INFINITE s ⇒ ∀(t :α -> bool). s ⊆ t ⇒ INFINITE t``, ``(option_CASE (NONE :α option) :β -> (α -> β) -> β) = (λ(v :β) (f :α -> β). v) ∧ (option_CASE (SOME (x :α)) :β -> (α -> β) -> β) = (λ(v :β) (f :α -> β). f x)``, ``∀(t :bool). t ⇒ F ⇔ ¬t``, ``∀(f1 :α -> bool) (f2 :α -> bool) (l :α list). FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)``, ``∀(f :α -> β) (P :α -> bool) (Q :β -> bool). FUNSET P Q f ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q``, ``𝕌(:α + β) = IMAGE (INL :α -> α + β) 𝕌(:α) ∪ IMAGE (INR :β -> α + β) 𝕌(:β)``, ``∀(x :α) (s :α -> bool). s ⊆ x INSERT s``, ``∀(l :α list) (x :α). l ≠ x::l ∧ x::l ≠ l``, ``PROD_SET (∅ :num -> bool) = (1 :num) ∧ ∀(x :num) (s :num -> bool). FINITE s ⇒ PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)``, ``∀(f :α -> β) (s :β -> bool) (x :α). PREIMAGE f s x ⇔ f x ∈ s``, ``∀(f :α -> β -> β) (e :β) (l1 :α list) (l2 :α list). FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ DROP n l = LASTN (LENGTH l − n) l``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ LENGTH (TAKE n l) = n``, ``(0 :num) < (n :num) ⇒ DROP n ((x :α)::(xs :α list)) = DROP (n − (1 :num)) xs``, ``∀(l :bool list). AND_EL l ⇔ FOLDL $/\\ T l``, ``∀(P :α -> bool) (l :α list). FILTER P l = ([] :α list) ⇔ EVERY (λ(x :α). ¬P x) l``, ``∀(v :α) (rows :(α -> β option) list) (p :bool) (infos :bool list). FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) ⇔ p ∧ EVERY (λ(r :α -> β option). r v = (NONE :β option)) rows``, ``∀(s :α -> bool). s ∩ s = s``, ``∀(x :α -> bool) (y :α -> bool) (z :α -> bool). x DIFF y DIFF z = x DIFF z DIFF y``, ``∀(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool). (c ⇒ x' ⇒ x) ∧ (¬c ⇒ y' ⇒ y) ⇒ (if c then x' else y') ⇒ if c then x else y``, ``∀(x :α). SING {x}``, ``((a :α),(b :α)) ∈ {(x,x) | (P :α -> bool) x} ⇔ P a ∧ a = b``, ``∀(M :α list) (M' :α list) (v :β) (f :α -> α list -> β). M = M' ∧ (M' = ([] :α list) ⇒ v = (v' :β)) ∧ (∀(a0 :α) (a1 :α list). M' = a0::a1 ⇒ f a0 a1 = (f' :α -> α list -> β) a0 a1) ⇒ (list_CASE M v f :β) = (list_CASE M' v' f' :β)``, ``∀(x :α) (l :α list). SNOC x l ≠ ([] :α list)``, ``∀(g :α -> α -> α) (f :β -> α -> α). FCOMM g f ⇒ ∀(e :α). LEFT_ID g e ⇒ ∀(l :β list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)``, ``∀(m :num) (n :num). m < SUC n ⇒ m ≠ n ⇒ m < n``, ``∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ⊂ t ∧ t ⊂ u ⇒ s ⊂ u``, ``∀(s :α -> bool) (t :α -> bool). FINITE s ∧ FINITE t ⇒ CARD (s ∪ t) = CARD s + CARD t − CARD (s ∩ t)``, ``∀(s :α -> bool). 𝕌(:α) ⊆ s ⇔ s = 𝕌(:α)``, ``∀(v :α) (rows :(α -> β option) list) (p :bool) (infos :bool list). LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) = LENGTH rows + LENGTH infos``, ``LIST_REL (R :α -> β -> bool) (xs :α list) ((h :β)::(t :β list)) ⇔ ∃(h' :α) (t' :α list). xs = h'::t' ∧ R h' h ∧ LIST_REL R t' t``, ``(∀(x :α) (y :α). (P :α -> bool) x ∧ (R :α -> α -> bool) x y ⇒ P y) ⇒ ∀(x :α) (y :α). P x ∧ R꙳ x y ⇒ P y``, ``((p :bool) ⇔ if (q :bool) then (r :bool) else (s :bool)) ⇔ (p ∨ q ∨ ¬s) ∧ (p ∨ ¬r ∨ ¬q) ∧ (p ∨ ¬r ∨ ¬s) ∧ (¬q ∨ r ∨ ¬p) ∧ (q ∨ s ∨ ¬p)``, ``∀(s :α -> bool) (x :α). x ∈ s ⇔ ∃(t :α -> bool). s = x INSERT t ∧ x ∉ t``, ``PMATCH_ROW_REDUNDANT (v :α) ((r :α -> β option)::(rs :(α -> β option) list)) (0 :num) ⇔ r v = (NONE :β option)``, ``∀(s :α -> bool) (t :α -> bool). DISJOINT t (s DIFF t) ∧ DISJOINT (s DIFF t) t``, ``∀(f :α -> β -> bool) (s :α -> bool) (y :β). y ∈ BIGUNION (IMAGE f s) ⇔ ∃(x :α). x ∈ s ∧ y ∈ f x``, ``(∀(e :α). LIST_ELEM_COUNT e ([] :α list) = (0 :num)) ∧ (∀(e :β) (l1 :β list) (l2 :β list). LIST_ELEM_COUNT e (l1 ++ l2) = LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) ∧ (∀(e :γ) (h :γ) (l :γ list). h = e ⇒ LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) ∧ ∀(e :δ) (h :δ) (l :δ list). h ≠ e ⇒ LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l``, ``∀(s :α -> bool) (t :α -> bool) (x :α). (s ∩ t) x ⇔ x ∈ s ∧ x ∈ t``, ``∀(P :α -> bool) (l1 :α list) (l2 :α list). EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2``, ``∀(ls :α list) (f :α # α -> β). MAP f (ZIP (ls,ls)) = MAP (λ(x :α). f (x,x)) ls``, ``MAP (f :α -> β) (l :α list) = (h :β)::(t :β list) ⇔ ∃(x0 :α) (t0 :α list). l = x0::t0 ∧ h = f x0 ∧ t = MAP f t0``, ``∀(R :α -> α -> bool). symmetric R ⇒ SC R = R``, ``∀(l1 :α list) (l2 :α list). SHORTLEX (R :α -> α -> bool) l1 l2 ⇒ LENGTH l1 ≤ LENGTH l2``, ``∀(f :β -> α -> β) (e :β) (x :α) (l :α list). FOLDL f e (SNOC x l) = f (FOLDL f e l) x``, ``∀(P :(α -> bool) -> bool). P (∅ :α -> bool) ∧ (∀(s :α -> bool). FINITE s ∧ P s ⇒ ∀(e :α). e ∉ s ⇒ P (e INSERT s)) ⇒ ∀(s :α -> bool). FINITE s ⇒ P s``, ``∀(s :α -> bool). FINITE s ⇒ FINITE (REST s)``, ``∀(s :α -> bool). FINITE s ⇒ ∃(f :num -> α) (b :num). BIJ f (count b) s``, ``∀(P :α -> bool) (l1 :α list) (l2 :α list). EVERY P l1 ⇒ dropWhile P (l1 ++ l2) = dropWhile P l2``, ``(OPTION_IGNORE_BIND (m1 :α option) (m2 :β option) = (NONE :β option) ⇔ m1 = (NONE :α option) ∨ m2 = (NONE :β option)) ∧ (OPTION_IGNORE_BIND m1 m2 = SOME (y :β) ⇔ ∃(x :α). m1 = SOME x ∧ m2 = SOME y)``, ``∀(P :α -> bool) (l :α list). EVERY P l ⇔ ¬EXISTS (λ(x :α). ¬P x) l``, ``∀(s :α -> bool). s = 𝕌(:α) ⇒ ∀(v :α). v ∈ s``, ``∀(n :num). SUC (m :num) = n ⇒ m < n``, ``((if (P :bool) then SOME (x :α) else (NONE :α option)) = (NONE :α option) ⇔ ¬P) ∧ ((if P then (NONE :α option) else SOME x) = (NONE :α option) ⇔ P) ∧ ((if P then SOME x else (NONE :α option)) = SOME (y :α) ⇔ P ∧ x = y) ∧ ((if P then (NONE :α option) else SOME x) = SOME y ⇔ ¬P ∧ x = y)``, ``(some(x :bool). x) = SOME T``, ``REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) ∧ REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list)) ((i2 :bool)::(is2 :bool list)) = (i1 ∧ i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2``, ``∀(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)``, ``∀(x :α recspace) (y :α recspace). dest_rec x = dest_rec y ⇔ x = y``, ``((R1 :α -> α -> bool) LEX (R2 :β -> β -> bool)) ((a :α),(b :β)) ((c :α),(d :β)) ⇔ R1 a c ∨ a = c ∧ R2 b d``, ``(∀(l :α list). ([] :α list) ≼ l ⇔ T) ∧ (∀(x :α) (l :α list). x::l ≼ ([] :α list) ⇔ F) ∧ ∀(x1 :α) (l1 :α list) (x2 :α) (l2 :α list). x2::l2 ≼ x1::l1 ⇔ x1 = x2 ∧ l2 ≼ l1``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ DROP n (REVERSE l) = REVERSE (BUTLASTN n l)``, ``∀(l :α list) (f :α -> β) (x :β). MEM x (MAP f l) ⇔ ∃(y :α). x = f y ∧ MEM y l``, ``∀(f :α -> β) (s :β -> bool) (t :β -> bool). s ⊆ t ⇒ PREIMAGE f s ⊆ PREIMAGE f t``, ``PROD_ALL (P :α -> bool) (Q :β -> bool) ((x :α),(y :β)) ⇔ P x ∧ Q y``, ``∀(R :α -> α -> bool) (x :α) (y :α). R⁺ x y ⇒ R꙳ x y``, ``∀(l2 :α list) (l1 :α list). BUTLASTN (LENGTH l2) (l1 ++ l2) = l1``, ``∀(l :α list). LENGTH l = FOLDR (λ(x :α) (l' :num). SUC l') (0 :num) l``, ``∀(n :num) (l :α list). n ≤ LENGTH l ⇒ LASTN n l = DROP (LENGTH l − n) l``, ``∀(t :bool). F ∨ t ⇔ t``, ``∀(f :α -> β) (s :β -> bool). IMAGE f (PREIMAGE f s) ⊆ s``, ``∀(s :α -> bool) (t :α -> bool). s ⊂ t ⇔ s ⊆ t ∧ ∃(y :α). y ∈ t ∧ y ∉ s``, ``(R :α -> α -> bool)⁺ (x :α) (z :α) ⇔ R x z ∨ ∃(y :α). R x y ∧ R⁺ y z``, ``∀(m :num) (n :num) (l :α list). m ≤ n ∧ n ≤ LENGTH l ⇒ BUTLASTN m (LASTN n l) = LASTN (n − m) (BUTLASTN m l)``, ``∀(f :α -> β) (P :α -> bool) (Q :α -> β -> bool). f ∈ DFUNSET P Q ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q x``, ``(∀(x :α). MEM x ([] :α list) ⇔ F) ∧ ∀(x :α) (h :α) (t :α list). MEM x (h::t) ⇔ x = h ∨ MEM x t``, ``∀(x :α) (s :α -> bool). x ∉ s ⇔ s DELETE x = s``, ``((INL (a :α) :α + β) ∈ (A :α -> bool) ⊔ (B :β -> bool) ⇔ a ∈ A) ∧ ((INR (b :β) :α + β) ∈ A ⊔ B ⇔ b ∈ B)``, ``WF (λ(x :num) (y :num). y = SUC x)``, ``∀(L :num list) (n :num). SUM_ACC L n = SUM L + n``, ``INFINITE 𝕌(:α) ⇔ ∀(s :α -> bool). FINITE s ⇒ s ⊂ 𝕌(:α)``, ``∀(ls :α list list). FLAT ls = ([] :α list) ⇔ EVERY ($= ([] :α list)) ls``, ``∀(f :α -> β). (∀(s :β -> bool). INJ f (∅ :α -> bool) s) ∧ ∀(s :α -> bool). INJ f s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)``, ``∀(l :α list) (f :α -> β). (MAP f l = ([] :β list) ⇔ l = ([] :α list)) ∧ (([] :β list) = MAP f l ⇔ l = ([] :α list))``, ``∀(l :num list). SUM l = FOLDR $+ (0 :num) l``, ``∀(R :α -> β -> bool) (l1 :α list) (l2 :β list) (n :num). LIST_REL R l1 l2 ⇒ LIST_REL R (DROP n l1) (DROP n l2)``, ``(some(x :α). F) = (NONE :α option)``, ``∀(f :α -> β) (l1 :α list) (l2 :α list). MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2``, ``∀(g :α -> α -> α) (f :β -> α -> α). FCOMM g f ⇒ ∀(e :α). LEFT_ID g e ⇒ ∀(l1 :β list) (l2 :β list). FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)``, ``∅ (x :α) ⇔ F``, ``∀(R :α -> α -> bool). WeakLinearOrder R ⇔ WeakOrder R ∧ ∀(a :α) (b :α). R a b ∨ R b a``, ``∀(R :α -> β -> bool) (R' :γ -> α -> bool). (R ∘ᵣ R')ᵀ = R'ᵀ ∘ᵣ Rᵀ``, ``∀(x :α) (l :α list). x::l = [x] ++ l``, ``∀(f :α -> β) (l :α list). MAP f l = FOLDR (λ(x :α) (l' :β list). f x::l') ([] :β list) l``, ``∀(x :α). x ∈ 𝕌(:α)``, ``𝕌(:α + β) = 𝕌(:α) ⊔ 𝕌(:β)``, ``∀(s :α -> bool) (t :α -> bool) (g :α -> bool). (s DIFF t) ∩ g = s ∩ g DIFF t``, ``∀(Q :num -> bool) (P :num -> bool). (∃(n :num). P n) ∧ (∀(n :num). (∀(m :num). m < n ⇒ ¬P m) ∧ P n ⇒ Q n) ⇒ Q ($LEAST P)``, ``∀(xs :α list). FILTER (λ(x :α). F) xs = ([] :α list)``, ``∀(f :α -> β) (x :α) (s :α -> bool). IMAGE f (x INSERT s) = f x INSERT IMAGE f s``, ``∀(l1 :α list) (l2 :α list). TAKE (LENGTH l1) (l1 ++ l2) = l1``, ``∀(l :α list list). FLAT l = FOLDR ($++ :α list -> α list -> α list) ([] :α list) l``, ``(¬LLEX (R :α -> α -> bool) ([] :α list) ([] :α list) ∧ ¬LLEX R ((h1 :α)::(t1 :α list)) ([] :α list)) ∧ LLEX R ([] :α list) ((h2 :α)::(t2 :α list)) ∧ (LLEX R (h1::t1) (h2::t2) ⇔ R h1 h2 ∨ h1 = h2 ∧ LLEX R t1 t2)``, ``∀(l :α list). l ++ ([] :α list) = l``, ``∀(s :α -> bool) (f :α -> β). f ∈ FUNSET s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)``, ``∀(b :bool). b ⇒ (b ⇔ T)``, ``∀(l :α list) (x :α). ELL (0 :num) (SNOC x l) = x``, ``∀(ls :α list). ls ≠ ([] :α list) ⇒ MAP (f :α -> β) (FRONT ls) = FRONT (MAP f ls)``, ``∀(n :num). (0 :num) < SUC n``, ``IMAGE (f :β -> α) (s :β -> bool) = {(z :α)} ⇔ s ≠ (∅ :β -> bool) ∧ ∀(x :β). x ∈ s ⇒ f x = z``, ``∀(f :α -> β -> β) (e :β) (l :α list). FOLDR f e l = FOLDL (λ(x :β) (y :α). f y x) e (REVERSE l)``, ``∀(l1 :α list) (l2 :α list) (a :α). IS_SUFFIX l1 l2 ⇒ IS_SUFFIX (a::l1) l2``, ``∀(x :α) (P :α -> bool). x ∈ P ⇔ P x``, ``∀(R :α -> α -> bool). StrongOrder R ⇒ Order R``, ``∀(n :num) (l :α list). n < LENGTH l ⇒ MEM (EL n l) l``, ``∀(x :α) (y :α) (P :α -> bool). x ∈ y INSERT P ⇔ x = y ∨ x ≠ y ∧ x ∈ P``, ``OWHILE (G :α -> bool) (f :α -> α) (s :α) = SOME (s' :α) ⇒ ¬G s``, ``symmetric (R1 :α -> α -> bool) ∧ symmetric (R2 :β -> β -> bool) ⇒ symmetric (R1 LEX R2)``, ``∀(P :α -> bool) (l :α list). PREFIX P l ≼ l``, ``∀(s :α -> bool) (f :α -> β). (∃(t :β -> bool). INJ f s t) ⇒ BIJ f s (IMAGE f s)``, ``∀(s :α -> bool). s DIFF 𝕌(:α) = (∅ :α -> bool)``, ``∀(t :bool). t ∧ t ⇔ t``, ``(∃(x :α). x ∈ (s :α -> bool)) ∧ (∀(x :α). x ∈ s ⇒ (P :α -> bool) x) ⇒ P (CHOICE s)``]

fun run_hammer data =
    case data of
        [] => holyhammer “¬T ⇔ F”
      | hd :: tl => 
let 
val v = holyhammer hd 
handle HOL_ERR msg =>
	    (* print "proof failed.\n" *)
let val _ = print "proof failed.\n" in
	    holyhammer “¬T ⇔ F”
 end
in
run_hammer tl
end

fun run_hammer2 data =
    case data of
        [] => hh_pb [Vampire] [] ([], ``¬T ⇔ F``)
      | hd :: tl => 
let 
val v = holyhammer hd 
handle HOL_ERR msg =>
	    (* print "proof failed.\n" *)
let val _ = print "proof failed.\n" in
	    holyhammer “¬T ⇔ F”
 end
in
run_hammer tl
end

(* fun run_hammer data = *)
(*     case data of *)
(*         [] => holyhammer “¬T ⇔ F” *)
(*       | hd :: tl => holyhammer hd  *)
(* handle HOL_ERR msg => *)
(* 	    (* print "proof failed.\n" *) *)
(* let val _ = print "proof failed.\n" in *)
(* 	    run_hammer tl *)
(*  end *)

	(* let *)
	(*     val b = holyhammer hd handle HOL_ERR msg => *)
	(* let *)
	(*     val b = holyhammer hd in *)
	(*     print "proof failed.\n"; *)
	(*     run_hammer tl *)
	(* end *)
 
	(* in *)
	(*     run_hammer tl *)
	(* end *)


