{"(\u2200l2. ZIP ([],l2) = []) \u2227 (\u2200l1. ZIP (l1,[]) = []) \u2227 \u2200x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)": "ZIP_def", "UNZIP [] = ([],[]) \u2227 \u2200x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))": "UNZIP", "\u2200e L. UNIQUE e L \u21d4 \u2203L1 L2. L1 ++ [e] ++ L2 = L \u2227 \u00acMEM e L1 \u2227 \u00acMEM e L2": "UNIQUE_DEF", "TL [] = [] \u2227 \u2200h t. TL (h::t) = t": "TL_DEF", "(\u2200n. TAKE n [] = []) \u2227 \u2200n x xs. TAKE n (x::xs) = if n = 0 then [] else x::TAKE (n \u2212 1) xs": "TAKE_def", "(\u2200acc. SUM_ACC [] acc = acc) \u2227 \u2200h t acc. SUM_ACC (h::t) acc = SUM_ACC t (h + acc)": "SUM_ACC_DEF", "SUM [] = 0 \u2227 \u2200h t. SUM (h::t) = h + SUM t": "SUM", "(\u2200P k. splitAtPki P k [] = k [] []) \u2227 \u2200P k h t. splitAtPki P k (h::t) = if P 0 h then k [] (h::t) else splitAtPki (P \u2218 SUC) (\u03bbp s. k (h::p) s) t": "splitAtPki_def", "(\u2200x. SNOC x [] = [x]) \u2227 \u2200x x' l. SNOC x (x'::l) = x'::SNOC x l": "SNOC", "(\u2200R l2. SHORTLEX R [] l2 \u21d4 l2 \u2260 []) \u2227 \u2200R h1 t1 l2. SHORTLEX R (h1::t1) l2 \u21d4 case l2 of [] => F | h2::t2 => if LENGTH t1 < LENGTH t2 then T else if LENGTH t1 = LENGTH t2 then if R h1 h2 then T else if h1 = h2 then SHORTLEX R t1 t2 else F else F": "SHORTLEX_def", "SET_TO_LIST = WFREC (@R. WF R \u2227 \u2200s. FINITE s \u2227 s \u2260 \u2205 \u21d2 R (REST s) s) (\u03bbSET_TO_LIST a. I (if FINITE a then if a = \u2205 then [] else CHOICE a::SET_TO_LIST (REST a) else ARB))": "SET_TO_LIST_primitive_def", "REVERSE [] = [] \u2227 \u2200h t. REVERSE (h::t) = REVERSE t ++ [h]": "REVERSE_DEF", "(\u2200acc. REV [] acc = acc) \u2227 \u2200h t acc. REV (h::t) acc = REV t (h::acc)": "REV_DEF", "\u2200c n s. PAD_RIGHT c n s = s ++ GENLIST (K c) (n \u2212 LENGTH s)": "PAD_RIGHT", "\u2200c n s. PAD_LEFT c n s = GENLIST (K c) (n \u2212 LENGTH s) ++ s": "PAD_LEFT", "(\u2200f. OPT_MMAP f [] = SOME []) \u2227 \u2200f h0 t0. OPT_MMAP f (h0::t0) = OPTION_BIND (f h0) (\u03bbh. OPTION_BIND (OPT_MMAP f t0) (\u03bbt. SOME (h::t)))": "OPT_MMAP_def", "\u2200l. oHD l = case l of [] => NONE | h::v1 => SOME h": "oHD_def", "(\u2200n. oEL n [] = NONE) \u2227 \u2200n x xs. oEL n (x::xs) = if n = 0 then SOME x else oEL (n \u2212 1) xs": "oEL_def", "(NULL [] \u21d4 T) \u2227 \u2200h t. NULL (h::t) \u21d4 F": "NULL_DEF", "nub [] = [] \u2227 \u2200x l. nub (x::l) = if MEM x l then nub l else x::nub l": "nub_def", "(\u2200f. MAP f [] = []) \u2227 \u2200f h t. MAP f (h::t) = f h::MAP f t": "MAP", "(\u2200e n. LUPDATE e n [] = []) \u2227 (\u2200e x l. LUPDATE e 0 (x::l) = e::l) \u2227 \u2200e n x l. LUPDATE e (SUC n) (x::l) = x::LUPDATE e n l": "LUPDATE_def", "(\u2200R x y. LRC R [] x y \u21d4 x = y) \u2227 \u2200R h t x y. LRC R (h::t) x y \u21d4 x = h \u2227 \u2203z. R x z \u2227 LRC R t z y": "LRC_def", "(\u2200R l2. LLEX R [] l2 \u21d4 l2 \u2260 []) \u2227 \u2200R h1 t1 l2. LLEX R (h1::t1) l2 \u21d4 case l2 of [] => F | h2::t2 => if R h1 h2 then T else if h1 = h2 then LLEX R t1 t2 else F": "LLEX_def", "(\u2200x. set [] x \u21d4 F) \u2227 \u2200h t x. set (h::t) x \u21d4 x = h \u2228 set t x": "LIST_TO_SET_DEF", "(\u2200f. list_size f [] = 0) \u2227 \u2200f a0 a1. list_size f (a0::a1) = 1 + (f a0 + list_size f a1)": "list_size_def", "\u2200f xs ys. LIST_LIFT2 f xs ys = MAP f xs <*> ys": "LIST_LIFT2_def", "\u2200m1 m2. LIST_IGNORE_BIND m1 m2 = LIST_BIND m1 (K m2)": "LIST_IGNORE_BIND_def", "\u2200b. LIST_GUARD b = if b then [()] else []": "LIST_GUARD_def", "(\u2200v f. list_CASE [] v f = v) \u2227 \u2200a0 a1 v f. list_CASE (a0::a1) v f = f a0 a1": "list_case_def", "\u2200l f. LIST_BIND l f = FLAT (MAP f l)": "LIST_BIND_def", "\u2200fs xs. fs <*> xs = LIST_BIND fs (combin$C MAP xs)": "LIST_APPLY_def", "LENGTH [] = 0 \u2227 \u2200h t. LENGTH (h::t) = SUC (LENGTH t)": "LENGTH", "(\u2200n. LEN [] n = n) \u2227 \u2200h t n. LEN (h::t) n = LEN t (n + 1)": "LEN_DEF", "\u2200h t. LAST (h::t) = if t = [] then h else LAST t": "LAST_DEF", "(\u2200l. [] \u227c l \u21d4 T) \u2227 \u2200h t l. h::t \u227c l \u21d4 case l of [] => F | h'::t' => h = h' \u2227 t \u227c t'": "isPREFIX", "\u2200x. INDEX_OF x = OPTION_MAP FST \u2218 INDEX_FIND 0 ($= x)": "INDEX_OF_def", "(\u2200i P. INDEX_FIND i P [] = NONE) \u2227 \u2200i P h t. INDEX_FIND i P (h::t) = if P h then SOME (i,h) else INDEX_FIND (SUC i) P t": "INDEX_FIND_def", "\u2200h t. HD (h::t) = h": "HD", "(\u2200f l. GENLIST_AUX f 0 l = l) \u2227 \u2200f n l. GENLIST_AUX f (SUC n) l = GENLIST_AUX f n (f n::l)": "GENLIST_AUX", "(\u2200f. GENLIST f 0 = []) \u2227 \u2200f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)": "GENLIST", "\u2200h t. FRONT (h::t) = if t = [] then [] else h::FRONT t": "FRONT_DEF", "(\u2200f e. FOLDR f e [] = e) \u2227 \u2200f e x l. FOLDR f e (x::l) = f x (FOLDR f e l)": "FOLDR", "(\u2200f e. FOLDL f e [] = e) \u2227 \u2200f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l": "FOLDL", "FLAT [] = [] \u2227 \u2200h t. FLAT (h::t) = h ++ FLAT t": "FLAT", "\u2200P. FIND P = OPTION_MAP SND \u2218 INDEX_FIND 0 P": "FIND_def", "(\u2200P. FILTER P [] = []) \u2227 \u2200P h t. FILTER P (h::t) = if P h then h::FILTER P t else FILTER P t": "FILTER", "(\u2200P. EXISTS P [] \u21d4 F) \u2227 \u2200P h t. EXISTS P (h::t) \u21d4 P h \u2228 EXISTS P t": "EXISTS_DEF", "(\u2200P. EVERYi P [] \u21d4 T) \u2227 \u2200P h t. EVERYi P (h::t) \u21d4 P 0 h \u2227 EVERYi (P \u2218 SUC) t": "EVERYi_def", "(\u2200P. EVERY P [] \u21d4 T) \u2227 \u2200P h t. EVERY P (h::t) \u21d4 P h \u2227 EVERY P t": "EVERY_DEF", "(\u2200l. EL 0 l = HD l) \u2227 \u2200l n. EL (SUC n) l = EL n (TL l)": "EL", "(\u2200P. dropWhile P [] = []) \u2227 \u2200P h t. dropWhile P (h::t) = if P h then dropWhile P t else h::t": "dropWhile_def", "(\u2200n. DROP n [] = []) \u2227 \u2200n x xs. DROP n (x::xs) = if n = 0 then x::xs else DROP (n \u2212 1) xs": "DROP_def", "(\u2200l. [] ++ l = l) \u2227 \u2200l1 l2 h. h::l1 ++ l2 = h::(l1 ++ l2)": "APPEND", "(ALL_DISTINCT [] \u21d4 T) \u2227 \u2200h t. ALL_DISTINCT (h::t) \u21d4 \u00acMEM h t \u2227 ALL_DISTINCT t": "ALL_DISTINCT"}