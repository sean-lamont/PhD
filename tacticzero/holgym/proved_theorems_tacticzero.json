["∀(s :α -> bool) (t :α -> bool). t ⊆ s ⇒ s DIFF (s DIFF t) = t", "∀(f :α -> β) (s :α -> bool) (t :β -> bool). FINITE s ∧ BIJ f s t ⇒ CARD s = CARD t", "{x | T} = 𝕌(:α)", "COMPL (∅ :α -> bool) = 𝕌(:α)", "∀(s :α -> bool) (t :α -> bool). s = t ⇔ ∀(x :α). x ∈ s ⇔ x ∈ t", "∀(a0 :α) (a1 :α list) (a0' :α) (a1' :α list). a0::a1 = a0'::a1' ⇔ a0 = a0' ∧ a1 = a1'", "∀(s1 :(α -> bool) -> bool) (s2 :(α -> bool) -> bool). BIGINTER (s1 ∪ s2) = BIGINTER s1 ∩ BIGINTER s2", "∀(x :α) (s :α -> bool). x ∈ x INSERT s", "∀(x :α). (∅ :α -> bool) DELETE x = (∅ :α -> bool)", "∀(s :α -> bool) (t :α -> bool). s DIFF t ∩ s = s DIFF t", "∀(n :num) (l1 :α list) (l2 :α list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n − LENGTH l1) l2", "∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ∩ (t ∩ u) = s ∩ t ∩ u", "PMATCH_ROW_REDUNDANT (v :α) ([] :(α -> β option) list) (i :num) ⇔ F", "∀(f :α -> β) (s :β -> bool) (t :β -> bool). DISJOINT s t ⇒ DISJOINT (PREIMAGE f s) (PREIMAGE f t)", "nub ([] :α list) = ([] :α list)", "{x | (y :α) = x} = {y}", "∀(s :α -> bool) (t :α -> bool). DISJOINT s t ⇔ ∀(x :α). x ∈ s ⇒ x ∉ t", "GENLIST (f :num -> α) (0 :num) = ([] :α list) ∧ GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :α list)", "∀(R :α -> α -> bool). symmetric Rᵀ ⇔ symmetric R", "∀(t1 :α) (t2 :α). (if F then t1 else t2) = t2", "∀(l1 :α list) (l2 :α list). set (l1 ++ l2) = set l1 ∪ set l2", "∀(R :α -> α -> bool). irreflexive Rᵀ ⇔ irreflexive R", "∀(s :α -> bool). CHOICE s ∉ REST s", "∀(x :bool) (x' :bool) (y :bool) (y' :bool). (x ⇒ y' ⇒ y) ∧ (¬y' ⇒ x ⇒ x') ⇒ (x' ⇒ y') ⇒ x ⇒ y", "∀(n1 :num) (n2 :num). count n1 = count n2 ⇔ n1 = n2", "∀(t :bool). t ∨ t ⇔ t", "∀(x :bool) (x' :bool) (y :bool) (y' :bool). (y ⇒ x' ⇒ x) ∧ (x' ⇒ y' ⇒ y) ⇒ x' ∧ y' ⇒ x ∧ y", "∀(n :num). DROP n ([] :α list) = ([] :α list)", "∀(s :α -> bool). s ⊂ 𝕌(:α) ⇔ ∃(x :α). x ∉ s", "(Q :α option -> bool) ($some (P :α -> bool)) ⇒ (∃(x :α). P x ∧ Q (SOME x)) ∨ (∀(x :α). ¬P x) ∧ Q (NONE :α option)", "transitive ($SUBSET :(α -> bool) -> (α -> bool) -> bool)", "∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool). INJ f s t ∧ INJ g t u ⇒ INJ (g ∘ f) s u", "∀(y :β) (s :α -> bool) (f :α -> β). IMAGE f s y ⇔ ∃(x :α). y = f x ∧ x ∈ s", "∀(f :α -> β) (g :β -> γ) (s :α -> bool) (t :β -> bool) (u :γ -> bool). SURJ f s t ∧ SURJ g t u ⇒ SURJ (g ∘ f) s u", "∀(f :'z -> 'z). INVOL f ⇒ ∀(a :'z) (b :'z). f a = f b ⇔ a = b", "$OLEAST (P :num -> bool) = (NONE :num option) ⇔ ∀(n :num). ¬P n", "∀(n :num) (l1 :α list) (l2 :α list). DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n − LENGTH l1) l2", "SURJ (f :α -> β) (s :α -> bool) (t :β -> bool) ⇒ ∃(g :β -> α). INJ g t s ∧ ∀(y :β). y ∈ t ⇒ f (g y) = y", "∀(f :α -> β) (s :α -> bool) (t :β -> bool). INJ f s t ∧ INFINITE s ⇒ INFINITE t", "∀(x :α) (l :α list). TL (SNOC x l) = if NULL l then ([] :α list) else SNOC x (TL l)", "∀(l :α list). NULL l ⇔ FOLDL (λ(x :bool) (l' :α). F) T l", "∀(l :α list) (m :num) (x :α). MEM x (DROP m l) ⇒ MEM x l", "∀(n :num) (x :α). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x", "∀(R :α -> α -> bool). reflexive (RC R)", "(R1 :γ -> β -> bool) ∘ᵣ (R2 :δ -> γ -> bool) ∘ᵣ (R3 :α -> δ -> bool) = (R1 ∘ᵣ R2) ∘ᵣ R3", "∀(l2 :α list) (l1 :α list). ¬NULL l2 ⇒ EL (LENGTH l1) (l1 ++ l2) = HD l2", "FUNSET 𝕌(:α) 𝕌(:β) = 𝕌(:α -> β)", "∀(A :bool) (B :bool) (C :bool). A ∧ B ⇒ C ⇔ A ⇒ B ⇒ C", "∀(b :bool). ¬b ⇒ (b ⇔ F)", "∀(x :α) (y :β) (a :α) (b :β). (x,y) = (a,b) ⇔ x = a ∧ y = b", "PMATCH_ROW_COND_EX (i :α) (p :β -> α) (g :β -> bool) ⇒ PMATCH_ROW p g (r :β -> γ) i = SOME (r (@(x :β). PMATCH_ROW_COND p g i x))", "∀(P :α -> bool) (a :α) (s :α -> bool). (∃(x :α). x ∈ a INSERT s ∧ P x) ⇔ P a ∨ ∃(x :α). x ∈ s ∧ P x", "∀(l :α list list). REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :α list -> α list) l))", "($= :α -> α -> bool)ᵀ = ($= :α -> α -> bool)", "∀(x :α) (s :α -> bool). (∅ :α -> bool) ≠ x INSERT s", "∀(f :α -> β). PREIMAGE f (∅ :β -> bool) = (∅ :α -> bool)", "∀(f :α -> β) (l :α list). MAP f (REVERSE l) = REVERSE (MAP f l)", "∀(s :α -> bool) (t :α -> bool) (x :α). (s ∪ t) x ⇔ x ∈ s ∨ x ∈ t", "∀(n :num). LENGTH (COUNT_LIST n) = n", "(∃(p :α # β). (P :α # β -> bool) p) ⇔ ∃(p_1 :α) (p_2 :β). P (p_1,p_2)", "∀(s :α -> bool) (x :α). COMPL (x INSERT s) = COMPL s DELETE x", "∀(t :bool). t ⇒ T ⇔ T", "∀(x :bool) (x' :bool) (y :bool) (y' :bool). (x ⇒ y ⇒ y') ∧ (¬y' ⇒ x' ⇒ x) ⇒ (x ⇒ y) ⇒ x' ⇒ y'", "∀(P :α -> bool) (l :α list) (m :num). EVERY P l ⇒ EVERY P (TAKE m l)", "(∀(x :α) (y :α). (R :α -> α -> bool) x y ⇒ (Q :α -> α -> bool) x y) ⇒ R꙳ (x :α) (y :α) ⇒ Q꙳ x y", "(∀(x :α). (P :α -> bool) x ⇒ (Q :α -> bool) x) ⇒ EXISTS P (l :α list) ⇒ EXISTS Q l", "∀(s :α -> bool) (t :α -> bool). s ⊆ t ⇒ s ∩ t = s", "∀(R :α -> α -> bool) (x :α) (y :α). R x y ⇒ R⁺ x y", "∀(l1 :α list) (n :num). LENGTH l1 ≤ n ⇒ ∀(l2 :α list). TAKE n (l1 ++ l2) = l1 ++ TAKE (n − LENGTH l1) l2", "∀(s :α -> bool). INFINITE s ⇒ ∀(t :α -> bool). s ⊆ t ⇒ INFINITE t", "∀(t :bool). t ⇒ F ⇔ ¬t", "∀(f1 :α -> bool) (f2 :α -> bool) (l :α list). FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)", "∀(f :α -> β) (P :α -> bool) (Q :β -> bool). FUNSET P Q f ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q", "∀(x :α) (s :α -> bool). s ⊆ x INSERT s", "∀(f :α -> β) (s :β -> bool) (x :α). PREIMAGE f s x ⇔ f x ∈ s", "∀(f :α -> β -> β) (e :β) (l1 :α list) (l2 :α list). FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1", "(0 :num) < (n :num) ⇒ DROP n ((x :α)::(xs :α list)) = DROP (n − (1 :num)) xs", "∀(s :α -> bool). s ∩ s = s", "∀(x :α -> bool) (y :α -> bool) (z :α -> bool). x DIFF y DIFF z = x DIFF z DIFF y", "∀(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool). (c ⇒ x' ⇒ x) ∧ (¬c ⇒ y' ⇒ y) ⇒ (if c then x' else y') ⇒ if c then x else y", "∀(x :α). SING {x}", "((a :α),(b :α)) ∈ {(x,x) | (P :α -> bool) x} ⇔ P a ∧ a = b", "∀(x :α) (l :α list). SNOC x l ≠ ([] :α list)", "∀(m :num) (n :num). m < SUC n ⇒ m ≠ n ⇒ m < n", "∀(s :α -> bool) (t :α -> bool) (u :α -> bool). s ⊂ t ∧ t ⊂ u ⇒ s ⊂ u", "∀(s :α -> bool). 𝕌(:α) ⊆ s ⇔ s = 𝕌(:α)", "(∀(x :α) (y :α). (P :α -> bool) x ∧ (R :α -> α -> bool) x y ⇒ P y) ⇒ ∀(x :α) (y :α). P x ∧ R꙳ x y ⇒ P y", "((p :bool) ⇔ if (q :bool) then (r :bool) else (s :bool)) ⇔ (p ∨ q ∨ ¬s) ∧ (p ∨ ¬r ∨ ¬q) ∧ (p ∨ ¬r ∨ ¬s) ∧ (¬q ∨ r ∨ ¬p) ∧ (q ∨ s ∨ ¬p)", "∀(s :α -> bool) (x :α). x ∈ s ⇔ ∃(t :α -> bool). s = x INSERT t ∧ x ∉ t", "∀(s :α -> bool) (t :α -> bool). DISJOINT t (s DIFF t) ∧ DISJOINT (s DIFF t) t", "∀(s :α -> bool) (t :α -> bool) (x :α). (s ∩ t) x ⇔ x ∈ s ∧ x ∈ t", "∀(P :α -> bool) (l1 :α list) (l2 :α list). EXISTS P (l1 ++ l2) ⇔ EXISTS P l1 ∨ EXISTS P l2", "∀(R :α -> α -> bool). symmetric R ⇒ SC R = R", "∀(s :α -> bool). FINITE s ⇒ FINITE (REST s)", "∀(P :α -> bool) (l :α list). EVERY P l ⇔ ¬EXISTS (λ(x :α). ¬P x) l", "∀(s :α -> bool). s = 𝕌(:α) ⇒ ∀(v :α). v ∈ s", "∀(n :num). SUC (m :num) = n ⇒ m < n", "((if (P :bool) then SOME (x :α) else (NONE :α option)) = (NONE :α option) ⇔ ¬P) ∧ ((if P then (NONE :α option) else SOME x) = (NONE :α option) ⇔ P) ∧ ((if P then SOME x else (NONE :α option)) = SOME (y :α) ⇔ P ∧ x = y) ∧ ((if P then (NONE :α option) else SOME x) = SOME y ⇔ ¬P ∧ x = y)", "∀(n :num) (l :α list). n ≤ LENGTH l ⇒ DROP n (REVERSE l) = REVERSE (BUTLASTN n l)", "∀(f :α -> β) (s :β -> bool) (t :β -> bool). s ⊆ t ⇒ PREIMAGE f s ⊆ PREIMAGE f t", "∀(l :α list). LENGTH l = FOLDR (λ(x :α) (l' :num). SUC l') (0 :num) l", "∀(t :bool). F ∨ t ⇔ t", "∀(f :α -> β) (s :β -> bool). IMAGE f (PREIMAGE f s) ⊆ s", "∀(s :α -> bool) (t :α -> bool). s ⊂ t ⇔ s ⊆ t ∧ ∃(y :α). y ∈ t ∧ y ∉ s", "∀(f :α -> β) (P :α -> bool) (Q :α -> β -> bool). f ∈ DFUNSET P Q ⇔ ∀(x :α). x ∈ P ⇒ f x ∈ Q x", "∀(x :α) (s :α -> bool). x ∉ s ⇔ s DELETE x = s", "∀(f :α -> β). (∀(s :β -> bool). INJ f (∅ :α -> bool) s) ∧ ∀(s :α -> bool). INJ f s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)", "∀(l :α list) (f :α -> β). (MAP f l = ([] :β list) ⇔ l = ([] :α list)) ∧ (([] :β list) = MAP f l ⇔ l = ([] :α list))", "∀(l :num list). SUM l = FOLDR $+ (0 :num) l", "∀(R :α -> β -> bool) (l1 :α list) (l2 :β list) (n :num). LIST_REL R l1 l2 ⇒ LIST_REL R (DROP n l1) (DROP n l2)", "(some(x :α). F) = (NONE :α option)", "∀(f :α -> β) (l1 :α list) (l2 :α list). MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2", "∅ (x :α) ⇔ F", "∀(R :α -> β -> bool) (R' :γ -> α -> bool). (R ∘ᵣ R')ᵀ = R'ᵀ ∘ᵣ Rᵀ", "∀(x :α) (l :α list). x::l = [x] ++ l", "∀(f :α -> β) (l :α list). MAP f l = FOLDR (λ(x :α) (l' :β list). f x::l') ([] :β list) l", "∀(x :α). x ∈ 𝕌(:α)", "∀(s :α -> bool) (t :α -> bool) (g :α -> bool). (s DIFF t) ∩ g = s ∩ g DIFF t", "∀(f :α -> β) (x :α) (s :α -> bool). IMAGE f (x INSERT s) = f x INSERT IMAGE f s", "∀(l1 :α list) (l2 :α list). TAKE (LENGTH l1) (l1 ++ l2) = l1", "∀(l :α list list). FLAT l = FOLDR ($++ :α list -> α list -> α list) ([] :α list) l", "∀(l :α list). l ++ ([] :α list) = l", "∀(s :α -> bool) (f :α -> β). f ∈ FUNSET s (∅ :β -> bool) ⇔ s = (∅ :α -> bool)", "∀(b :bool). b ⇒ (b ⇔ T)", "∀(n :num). (0 :num) < SUC n", "∀(l1 :α list) (l2 :α list) (a :α). IS_SUFFIX l1 l2 ⇒ IS_SUFFIX (a::l1) l2", "∀(x :α) (P :α -> bool). x ∈ P ⇔ P x", "∀(R :α -> α -> bool). StrongOrder R ⇒ Order R", "∀(x :α) (y :α) (P :α -> bool). x ∈ y INSERT P ⇔ x = y ∨ x ≠ y ∧ x ∈ P", "symmetric (R1 :α -> α -> bool) ∧ symmetric (R2 :β -> β -> bool) ⇒ symmetric (R1 LEX R2)", "∀(s :α -> bool). s DIFF 𝕌(:α) = (∅ :α -> bool)", "∀(t :bool). t ∧ t ⇔ t"]